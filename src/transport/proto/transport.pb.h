// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: transport.proto

#ifndef PROTOBUF_INCLUDED_transport_2eproto
#define PROTOBUF_INCLUDED_transport_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_transport_2eproto 

namespace protobuf_transport_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[2];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_transport_2eproto
namespace tenon {
namespace transport {
namespace protobuf {
class BroadcastParam;
class BroadcastParamDefaultTypeInternal;
extern BroadcastParamDefaultTypeInternal _BroadcastParam_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
}  // namespace protobuf
}  // namespace transport
}  // namespace tenon
namespace google {
namespace protobuf {
template<> ::tenon::transport::protobuf::BroadcastParam* Arena::CreateMaybeMessage<::tenon::transport::protobuf::BroadcastParam>(Arena*);
template<> ::tenon::transport::protobuf::Header* Arena::CreateMaybeMessage<::tenon::transport::protobuf::Header>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace tenon {
namespace transport {
namespace protobuf {

// ===================================================================

class BroadcastParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tenon.transport.protobuf.BroadcastParam) */ {
 public:
  BroadcastParam();
  virtual ~BroadcastParam();

  BroadcastParam(const BroadcastParam& from);

  inline BroadcastParam& operator=(const BroadcastParam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BroadcastParam(BroadcastParam&& from) noexcept
    : BroadcastParam() {
    *this = ::std::move(from);
  }

  inline BroadcastParam& operator=(BroadcastParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BroadcastParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BroadcastParam* internal_default_instance() {
    return reinterpret_cast<const BroadcastParam*>(
               &_BroadcastParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(BroadcastParam* other);
  friend void swap(BroadcastParam& a, BroadcastParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BroadcastParam* New() const final {
    return CreateMaybeMessage<BroadcastParam>(NULL);
  }

  BroadcastParam* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BroadcastParam>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BroadcastParam& from);
  void MergeFrom(const BroadcastParam& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BroadcastParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 bloomfilter = 12;
  int bloomfilter_size() const;
  void clear_bloomfilter();
  static const int kBloomfilterFieldNumber = 12;
  ::google::protobuf::uint64 bloomfilter(int index) const;
  void set_bloomfilter(int index, ::google::protobuf::uint64 value);
  void add_bloomfilter(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      bloomfilter() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_bloomfilter();

  // optional bytes header = 9;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 9;
  const ::std::string& header() const;
  void set_header(const ::std::string& value);
  #if LANG_CXX11
  void set_header(::std::string&& value);
  #endif
  void set_header(const char* value);
  void set_header(const void* value, size_t size);
  ::std::string* mutable_header();
  ::std::string* release_header();
  void set_allocated_header(::std::string* header);

  // optional bytes body = 10;
  bool has_body() const;
  void clear_body();
  static const int kBodyFieldNumber = 10;
  const ::std::string& body() const;
  void set_body(const ::std::string& value);
  #if LANG_CXX11
  void set_body(::std::string&& value);
  #endif
  void set_body(const char* value);
  void set_body(const void* value, size_t size);
  ::std::string* mutable_body();
  ::std::string* release_body();
  void set_allocated_body(::std::string* body);

  // optional uint32 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // optional uint32 neighbor_count = 2;
  bool has_neighbor_count() const;
  void clear_neighbor_count();
  static const int kNeighborCountFieldNumber = 2;
  ::google::protobuf::uint32 neighbor_count() const;
  void set_neighbor_count(::google::protobuf::uint32 value);

  // optional uint32 stop_times = 3;
  bool has_stop_times() const;
  void clear_stop_times();
  static const int kStopTimesFieldNumber = 3;
  ::google::protobuf::uint32 stop_times() const;
  void set_stop_times(::google::protobuf::uint32 value);

  // optional uint32 hop_limit = 4;
  bool has_hop_limit() const;
  void clear_hop_limit();
  static const int kHopLimitFieldNumber = 4;
  ::google::protobuf::uint32 hop_limit() const;
  void set_hop_limit(::google::protobuf::uint32 value);

  // optional uint64 layer_left = 5;
  bool has_layer_left() const;
  void clear_layer_left();
  static const int kLayerLeftFieldNumber = 5;
  ::google::protobuf::uint64 layer_left() const;
  void set_layer_left(::google::protobuf::uint64 value);

  // optional uint64 layer_right = 6;
  bool has_layer_right() const;
  void clear_layer_right();
  static const int kLayerRightFieldNumber = 6;
  ::google::protobuf::uint64 layer_right() const;
  void set_layer_right(::google::protobuf::uint64 value);

  // optional float overlap = 7;
  bool has_overlap() const;
  void clear_overlap();
  static const int kOverlapFieldNumber = 7;
  float overlap() const;
  void set_overlap(float value);

  // optional uint32 hop_to_layer = 8;
  bool has_hop_to_layer() const;
  void clear_hop_to_layer();
  static const int kHopToLayerFieldNumber = 8;
  ::google::protobuf::uint32 hop_to_layer() const;
  void set_hop_to_layer(::google::protobuf::uint32 value);

  // optional bool net_crossed = 11;
  bool has_net_crossed() const;
  void clear_net_crossed();
  static const int kNetCrossedFieldNumber = 11;
  bool net_crossed() const;
  void set_net_crossed(bool value);

  // optional float evil_rate = 13;
  bool has_evil_rate() const;
  void clear_evil_rate();
  static const int kEvilRateFieldNumber = 13;
  float evil_rate() const;
  void set_evil_rate(float value);

  // optional uint32 ign_bloomfilter_hop = 14;
  bool has_ign_bloomfilter_hop() const;
  void clear_ign_bloomfilter_hop();
  static const int kIgnBloomfilterHopFieldNumber = 14;
  ::google::protobuf::uint32 ign_bloomfilter_hop() const;
  void set_ign_bloomfilter_hop(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:tenon.transport.protobuf.BroadcastParam)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_neighbor_count();
  void clear_has_neighbor_count();
  void set_has_stop_times();
  void clear_has_stop_times();
  void set_has_hop_limit();
  void clear_has_hop_limit();
  void set_has_layer_left();
  void clear_has_layer_left();
  void set_has_layer_right();
  void clear_has_layer_right();
  void set_has_overlap();
  void clear_has_overlap();
  void set_has_hop_to_layer();
  void clear_has_hop_to_layer();
  void set_has_header();
  void clear_has_header();
  void set_has_body();
  void clear_has_body();
  void set_has_net_crossed();
  void clear_has_net_crossed();
  void set_has_evil_rate();
  void clear_has_evil_rate();
  void set_has_ign_bloomfilter_hop();
  void clear_has_ign_bloomfilter_hop();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > bloomfilter_;
  ::google::protobuf::internal::ArenaStringPtr header_;
  ::google::protobuf::internal::ArenaStringPtr body_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 neighbor_count_;
  ::google::protobuf::uint32 stop_times_;
  ::google::protobuf::uint32 hop_limit_;
  ::google::protobuf::uint64 layer_left_;
  ::google::protobuf::uint64 layer_right_;
  float overlap_;
  ::google::protobuf::uint32 hop_to_layer_;
  bool net_crossed_;
  float evil_rate_;
  ::google::protobuf::uint32 ign_bloomfilter_hop_;
  friend struct ::protobuf_transport_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Header : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tenon.transport.protobuf.Header) */ {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(Header&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Header* other);
  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Header* New() const final {
    return CreateMaybeMessage<Header>(NULL);
  }

  Header* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes src_dht_key = 1;
  bool has_src_dht_key() const;
  void clear_src_dht_key();
  static const int kSrcDhtKeyFieldNumber = 1;
  const ::std::string& src_dht_key() const;
  void set_src_dht_key(const ::std::string& value);
  #if LANG_CXX11
  void set_src_dht_key(::std::string&& value);
  #endif
  void set_src_dht_key(const char* value);
  void set_src_dht_key(const void* value, size_t size);
  ::std::string* mutable_src_dht_key();
  ::std::string* release_src_dht_key();
  void set_allocated_src_dht_key(::std::string* src_dht_key);

  // optional bytes des_dht_key = 2;
  bool has_des_dht_key() const;
  void clear_des_dht_key();
  static const int kDesDhtKeyFieldNumber = 2;
  const ::std::string& des_dht_key() const;
  void set_des_dht_key(const ::std::string& value);
  #if LANG_CXX11
  void set_des_dht_key(::std::string&& value);
  #endif
  void set_des_dht_key(const char* value);
  void set_des_dht_key(const void* value, size_t size);
  ::std::string* mutable_des_dht_key();
  ::std::string* release_des_dht_key();
  void set_allocated_des_dht_key(::std::string* des_dht_key);

  // optional bytes src_node_id = 3;
  bool has_src_node_id() const;
  void clear_src_node_id();
  static const int kSrcNodeIdFieldNumber = 3;
  const ::std::string& src_node_id() const;
  void set_src_node_id(const ::std::string& value);
  #if LANG_CXX11
  void set_src_node_id(::std::string&& value);
  #endif
  void set_src_node_id(const char* value);
  void set_src_node_id(const void* value, size_t size);
  ::std::string* mutable_src_node_id();
  ::std::string* release_src_node_id();
  void set_allocated_src_node_id(::std::string* src_node_id);

  // optional bytes des_node_id = 4;
  bool has_des_node_id() const;
  void clear_des_node_id();
  static const int kDesNodeIdFieldNumber = 4;
  const ::std::string& des_node_id() const;
  void set_des_node_id(const ::std::string& value);
  #if LANG_CXX11
  void set_des_node_id(::std::string&& value);
  #endif
  void set_des_node_id(const char* value);
  void set_des_node_id(const void* value, size_t size);
  ::std::string* mutable_des_node_id();
  ::std::string* release_des_node_id();
  void set_allocated_des_node_id(::std::string* des_node_id);

  // optional bytes data = 6;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 6;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // optional bytes debug = 8;
  bool has_debug() const;
  void clear_debug();
  static const int kDebugFieldNumber = 8;
  const ::std::string& debug() const;
  void set_debug(const ::std::string& value);
  #if LANG_CXX11
  void set_debug(::std::string&& value);
  #endif
  void set_debug(const char* value);
  void set_debug(const void* value, size_t size);
  ::std::string* mutable_debug();
  ::std::string* release_debug();
  void set_allocated_debug(::std::string* debug);

  // optional bytes from_ip = 9;
  bool has_from_ip() const;
  void clear_from_ip();
  static const int kFromIpFieldNumber = 9;
  const ::std::string& from_ip() const;
  void set_from_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_from_ip(::std::string&& value);
  #endif
  void set_from_ip(const char* value);
  void set_from_ip(const void* value, size_t size);
  ::std::string* mutable_from_ip();
  ::std::string* release_from_ip();
  void set_allocated_from_ip(::std::string* from_ip);

  // optional bytes to_ip = 11;
  bool has_to_ip() const;
  void clear_to_ip();
  static const int kToIpFieldNumber = 11;
  const ::std::string& to_ip() const;
  void set_to_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_to_ip(::std::string&& value);
  #endif
  void set_to_ip(const char* value);
  void set_to_ip(const void* value, size_t size);
  ::std::string* mutable_to_ip();
  ::std::string* release_to_ip();
  void set_allocated_to_ip(::std::string* to_ip);

  // optional bytes client_dht_key = 19;
  bool has_client_dht_key() const;
  void clear_client_dht_key();
  static const int kClientDhtKeyFieldNumber = 19;
  const ::std::string& client_dht_key() const;
  void set_client_dht_key(const ::std::string& value);
  #if LANG_CXX11
  void set_client_dht_key(::std::string&& value);
  #endif
  void set_client_dht_key(const char* value);
  void set_client_dht_key(const void* value, size_t size);
  ::std::string* mutable_client_dht_key();
  ::std::string* release_client_dht_key();
  void set_allocated_client_dht_key(::std::string* client_dht_key);

  // optional bytes pubkey = 25;
  bool has_pubkey() const;
  void clear_pubkey();
  static const int kPubkeyFieldNumber = 25;
  const ::std::string& pubkey() const;
  void set_pubkey(const ::std::string& value);
  #if LANG_CXX11
  void set_pubkey(::std::string&& value);
  #endif
  void set_pubkey(const char* value);
  void set_pubkey(const void* value, size_t size);
  ::std::string* mutable_pubkey();
  ::std::string* release_pubkey();
  void set_allocated_pubkey(::std::string* pubkey);

  // optional bytes sign = 26;
  bool has_sign() const;
  void clear_sign();
  static const int kSignFieldNumber = 26;
  const ::std::string& sign() const;
  void set_sign(const ::std::string& value);
  #if LANG_CXX11
  void set_sign(::std::string&& value);
  #endif
  void set_sign(const char* value);
  void set_sign(const void* value, size_t size);
  ::std::string* mutable_sign();
  ::std::string* release_sign();
  void set_allocated_sign(::std::string* sign);

  // optional bytes des_country = 29;
  bool has_des_country() const;
  void clear_des_country();
  static const int kDesCountryFieldNumber = 29;
  const ::std::string& des_country() const;
  void set_des_country(const ::std::string& value);
  #if LANG_CXX11
  void set_des_country(::std::string&& value);
  #endif
  void set_des_country(const char* value);
  void set_des_country(const void* value, size_t size);
  ::std::string* mutable_des_country();
  ::std::string* release_des_country();
  void set_allocated_des_country(::std::string* des_country);

  // optional .tenon.transport.protobuf.BroadcastParam broadcast = 22;
  bool has_broadcast() const;
  void clear_broadcast();
  static const int kBroadcastFieldNumber = 22;
  private:
  const ::tenon::transport::protobuf::BroadcastParam& _internal_broadcast() const;
  public:
  const ::tenon::transport::protobuf::BroadcastParam& broadcast() const;
  ::tenon::transport::protobuf::BroadcastParam* release_broadcast();
  ::tenon::transport::protobuf::BroadcastParam* mutable_broadcast();
  void set_allocated_broadcast(::tenon::transport::protobuf::BroadcastParam* broadcast);

  // optional uint32 hop_count = 5;
  bool has_hop_count() const;
  void clear_hop_count();
  static const int kHopCountFieldNumber = 5;
  ::google::protobuf::uint32 hop_count() const;
  void set_hop_count(::google::protobuf::uint32 value);

  // optional uint32 priority = 7;
  bool has_priority() const;
  void clear_priority();
  static const int kPriorityFieldNumber = 7;
  ::google::protobuf::uint32 priority() const;
  void set_priority(::google::protobuf::uint32 value);

  // optional uint32 from_port = 10;
  bool has_from_port() const;
  void clear_from_port();
  static const int kFromPortFieldNumber = 10;
  ::google::protobuf::uint32 from_port() const;
  void set_from_port(::google::protobuf::uint32 value);

  // optional uint32 to_port = 12;
  bool has_to_port() const;
  void clear_to_port();
  static const int kToPortFieldNumber = 12;
  ::google::protobuf::uint32 to_port() const;
  void set_to_port(::google::protobuf::uint32 value);

  // optional uint64 hash = 14;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 14;
  ::google::protobuf::uint64 hash() const;
  void set_hash(::google::protobuf::uint64 value);

  // optional uint32 id = 13;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 13;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // optional uint32 type = 15;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 15;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // optional bool client = 16;
  bool has_client() const;
  void clear_client();
  static const int kClientFieldNumber = 16;
  bool client() const;
  void set_client(bool value);

  // optional bool client_relayed = 17;
  bool has_client_relayed() const;
  void clear_client_relayed();
  static const int kClientRelayedFieldNumber = 17;
  bool client_relayed() const;
  void set_client_relayed(bool value);

  // optional bool client_proxy = 18;
  bool has_client_proxy() const;
  void clear_client_proxy();
  static const int kClientProxyFieldNumber = 18;
  bool client_proxy() const;
  void set_client_proxy(bool value);

  // optional bool client_handled = 20;
  bool has_client_handled() const;
  void clear_client_handled();
  static const int kClientHandledFieldNumber = 20;
  bool client_handled() const;
  void set_client_handled(bool value);

  // optional bool universal = 21;
  bool has_universal() const;
  void clear_universal();
  static const int kUniversalFieldNumber = 21;
  bool universal() const;
  void set_universal(bool value);

  // optional bool handled = 23;
  bool has_handled() const;
  void clear_handled();
  static const int kHandledFieldNumber = 23;
  bool handled() const;
  void set_handled(bool value);

  // optional bool local = 27;
  bool has_local() const;
  void clear_local();
  static const int kLocalFieldNumber = 27;
  bool local() const;
  void set_local(bool value);

  // optional uint64 des_dht_key_hash = 24;
  bool has_des_dht_key_hash() const;
  void clear_des_dht_key_hash();
  static const int kDesDhtKeyHashFieldNumber = 24;
  ::google::protobuf::uint64 des_dht_key_hash() const;
  void set_des_dht_key_hash(::google::protobuf::uint64 value);

  // optional int32 des_network = 28;
  bool has_des_network() const;
  void clear_des_network();
  static const int kDesNetworkFieldNumber = 28;
  ::google::protobuf::int32 des_network() const;
  void set_des_network(::google::protobuf::int32 value);

  // optional int32 transport_type = 30;
  bool has_transport_type() const;
  void clear_transport_type();
  static const int kTransportTypeFieldNumber = 30;
  ::google::protobuf::int32 transport_type() const;
  void set_transport_type(::google::protobuf::int32 value);

  // optional int32 version = 31;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 31;
  ::google::protobuf::int32 version() const;
  void set_version(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tenon.transport.protobuf.Header)
 private:
  void set_has_src_dht_key();
  void clear_has_src_dht_key();
  void set_has_des_dht_key();
  void clear_has_des_dht_key();
  void set_has_src_node_id();
  void clear_has_src_node_id();
  void set_has_des_node_id();
  void clear_has_des_node_id();
  void set_has_hop_count();
  void clear_has_hop_count();
  void set_has_data();
  void clear_has_data();
  void set_has_priority();
  void clear_has_priority();
  void set_has_debug();
  void clear_has_debug();
  void set_has_from_ip();
  void clear_has_from_ip();
  void set_has_from_port();
  void clear_has_from_port();
  void set_has_to_ip();
  void clear_has_to_ip();
  void set_has_to_port();
  void clear_has_to_port();
  void set_has_id();
  void clear_has_id();
  void set_has_hash();
  void clear_has_hash();
  void set_has_type();
  void clear_has_type();
  void set_has_client();
  void clear_has_client();
  void set_has_client_relayed();
  void clear_has_client_relayed();
  void set_has_client_proxy();
  void clear_has_client_proxy();
  void set_has_client_dht_key();
  void clear_has_client_dht_key();
  void set_has_client_handled();
  void clear_has_client_handled();
  void set_has_universal();
  void clear_has_universal();
  void set_has_broadcast();
  void clear_has_broadcast();
  void set_has_handled();
  void clear_has_handled();
  void set_has_des_dht_key_hash();
  void clear_has_des_dht_key_hash();
  void set_has_pubkey();
  void clear_has_pubkey();
  void set_has_sign();
  void clear_has_sign();
  void set_has_local();
  void clear_has_local();
  void set_has_des_network();
  void clear_has_des_network();
  void set_has_des_country();
  void clear_has_des_country();
  void set_has_transport_type();
  void clear_has_transport_type();
  void set_has_version();
  void clear_has_version();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr src_dht_key_;
  ::google::protobuf::internal::ArenaStringPtr des_dht_key_;
  ::google::protobuf::internal::ArenaStringPtr src_node_id_;
  ::google::protobuf::internal::ArenaStringPtr des_node_id_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::internal::ArenaStringPtr debug_;
  ::google::protobuf::internal::ArenaStringPtr from_ip_;
  ::google::protobuf::internal::ArenaStringPtr to_ip_;
  ::google::protobuf::internal::ArenaStringPtr client_dht_key_;
  ::google::protobuf::internal::ArenaStringPtr pubkey_;
  ::google::protobuf::internal::ArenaStringPtr sign_;
  ::google::protobuf::internal::ArenaStringPtr des_country_;
  ::tenon::transport::protobuf::BroadcastParam* broadcast_;
  ::google::protobuf::uint32 hop_count_;
  ::google::protobuf::uint32 priority_;
  ::google::protobuf::uint32 from_port_;
  ::google::protobuf::uint32 to_port_;
  ::google::protobuf::uint64 hash_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 type_;
  bool client_;
  bool client_relayed_;
  bool client_proxy_;
  bool client_handled_;
  bool universal_;
  bool handled_;
  bool local_;
  ::google::protobuf::uint64 des_dht_key_hash_;
  ::google::protobuf::int32 des_network_;
  ::google::protobuf::int32 transport_type_;
  ::google::protobuf::int32 version_;
  friend struct ::protobuf_transport_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BroadcastParam

// optional uint32 type = 1;
inline bool BroadcastParam::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BroadcastParam::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BroadcastParam::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BroadcastParam::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 BroadcastParam::type() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.BroadcastParam.type)
  return type_;
}
inline void BroadcastParam::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.BroadcastParam.type)
}

// optional uint32 neighbor_count = 2;
inline bool BroadcastParam::has_neighbor_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BroadcastParam::set_has_neighbor_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BroadcastParam::clear_has_neighbor_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BroadcastParam::clear_neighbor_count() {
  neighbor_count_ = 0u;
  clear_has_neighbor_count();
}
inline ::google::protobuf::uint32 BroadcastParam::neighbor_count() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.BroadcastParam.neighbor_count)
  return neighbor_count_;
}
inline void BroadcastParam::set_neighbor_count(::google::protobuf::uint32 value) {
  set_has_neighbor_count();
  neighbor_count_ = value;
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.BroadcastParam.neighbor_count)
}

// optional uint32 stop_times = 3;
inline bool BroadcastParam::has_stop_times() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BroadcastParam::set_has_stop_times() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BroadcastParam::clear_has_stop_times() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BroadcastParam::clear_stop_times() {
  stop_times_ = 0u;
  clear_has_stop_times();
}
inline ::google::protobuf::uint32 BroadcastParam::stop_times() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.BroadcastParam.stop_times)
  return stop_times_;
}
inline void BroadcastParam::set_stop_times(::google::protobuf::uint32 value) {
  set_has_stop_times();
  stop_times_ = value;
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.BroadcastParam.stop_times)
}

// optional uint32 hop_limit = 4;
inline bool BroadcastParam::has_hop_limit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BroadcastParam::set_has_hop_limit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BroadcastParam::clear_has_hop_limit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BroadcastParam::clear_hop_limit() {
  hop_limit_ = 0u;
  clear_has_hop_limit();
}
inline ::google::protobuf::uint32 BroadcastParam::hop_limit() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.BroadcastParam.hop_limit)
  return hop_limit_;
}
inline void BroadcastParam::set_hop_limit(::google::protobuf::uint32 value) {
  set_has_hop_limit();
  hop_limit_ = value;
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.BroadcastParam.hop_limit)
}

// optional uint64 layer_left = 5;
inline bool BroadcastParam::has_layer_left() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BroadcastParam::set_has_layer_left() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BroadcastParam::clear_has_layer_left() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BroadcastParam::clear_layer_left() {
  layer_left_ = GOOGLE_ULONGLONG(0);
  clear_has_layer_left();
}
inline ::google::protobuf::uint64 BroadcastParam::layer_left() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.BroadcastParam.layer_left)
  return layer_left_;
}
inline void BroadcastParam::set_layer_left(::google::protobuf::uint64 value) {
  set_has_layer_left();
  layer_left_ = value;
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.BroadcastParam.layer_left)
}

// optional uint64 layer_right = 6;
inline bool BroadcastParam::has_layer_right() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BroadcastParam::set_has_layer_right() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BroadcastParam::clear_has_layer_right() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BroadcastParam::clear_layer_right() {
  layer_right_ = GOOGLE_ULONGLONG(0);
  clear_has_layer_right();
}
inline ::google::protobuf::uint64 BroadcastParam::layer_right() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.BroadcastParam.layer_right)
  return layer_right_;
}
inline void BroadcastParam::set_layer_right(::google::protobuf::uint64 value) {
  set_has_layer_right();
  layer_right_ = value;
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.BroadcastParam.layer_right)
}

// optional float overlap = 7;
inline bool BroadcastParam::has_overlap() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BroadcastParam::set_has_overlap() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BroadcastParam::clear_has_overlap() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BroadcastParam::clear_overlap() {
  overlap_ = 0;
  clear_has_overlap();
}
inline float BroadcastParam::overlap() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.BroadcastParam.overlap)
  return overlap_;
}
inline void BroadcastParam::set_overlap(float value) {
  set_has_overlap();
  overlap_ = value;
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.BroadcastParam.overlap)
}

// optional uint32 hop_to_layer = 8;
inline bool BroadcastParam::has_hop_to_layer() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BroadcastParam::set_has_hop_to_layer() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BroadcastParam::clear_has_hop_to_layer() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BroadcastParam::clear_hop_to_layer() {
  hop_to_layer_ = 0u;
  clear_has_hop_to_layer();
}
inline ::google::protobuf::uint32 BroadcastParam::hop_to_layer() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.BroadcastParam.hop_to_layer)
  return hop_to_layer_;
}
inline void BroadcastParam::set_hop_to_layer(::google::protobuf::uint32 value) {
  set_has_hop_to_layer();
  hop_to_layer_ = value;
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.BroadcastParam.hop_to_layer)
}

// optional bytes header = 9;
inline bool BroadcastParam::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BroadcastParam::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BroadcastParam::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BroadcastParam::clear_header() {
  header_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_header();
}
inline const ::std::string& BroadcastParam::header() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.BroadcastParam.header)
  return header_.GetNoArena();
}
inline void BroadcastParam::set_header(const ::std::string& value) {
  set_has_header();
  header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.BroadcastParam.header)
}
#if LANG_CXX11
inline void BroadcastParam::set_header(::std::string&& value) {
  set_has_header();
  header_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.transport.protobuf.BroadcastParam.header)
}
#endif
inline void BroadcastParam::set_header(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_header();
  header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.transport.protobuf.BroadcastParam.header)
}
inline void BroadcastParam::set_header(const void* value, size_t size) {
  set_has_header();
  header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.transport.protobuf.BroadcastParam.header)
}
inline ::std::string* BroadcastParam::mutable_header() {
  set_has_header();
  // @@protoc_insertion_point(field_mutable:tenon.transport.protobuf.BroadcastParam.header)
  return header_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BroadcastParam::release_header() {
  // @@protoc_insertion_point(field_release:tenon.transport.protobuf.BroadcastParam.header)
  if (!has_header()) {
    return NULL;
  }
  clear_has_header();
  return header_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BroadcastParam::set_allocated_header(::std::string* header) {
  if (header != NULL) {
    set_has_header();
  } else {
    clear_has_header();
  }
  header_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), header);
  // @@protoc_insertion_point(field_set_allocated:tenon.transport.protobuf.BroadcastParam.header)
}

// optional bytes body = 10;
inline bool BroadcastParam::has_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BroadcastParam::set_has_body() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BroadcastParam::clear_has_body() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BroadcastParam::clear_body() {
  body_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_body();
}
inline const ::std::string& BroadcastParam::body() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.BroadcastParam.body)
  return body_.GetNoArena();
}
inline void BroadcastParam::set_body(const ::std::string& value) {
  set_has_body();
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.BroadcastParam.body)
}
#if LANG_CXX11
inline void BroadcastParam::set_body(::std::string&& value) {
  set_has_body();
  body_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.transport.protobuf.BroadcastParam.body)
}
#endif
inline void BroadcastParam::set_body(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_body();
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.transport.protobuf.BroadcastParam.body)
}
inline void BroadcastParam::set_body(const void* value, size_t size) {
  set_has_body();
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.transport.protobuf.BroadcastParam.body)
}
inline ::std::string* BroadcastParam::mutable_body() {
  set_has_body();
  // @@protoc_insertion_point(field_mutable:tenon.transport.protobuf.BroadcastParam.body)
  return body_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BroadcastParam::release_body() {
  // @@protoc_insertion_point(field_release:tenon.transport.protobuf.BroadcastParam.body)
  if (!has_body()) {
    return NULL;
  }
  clear_has_body();
  return body_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BroadcastParam::set_allocated_body(::std::string* body) {
  if (body != NULL) {
    set_has_body();
  } else {
    clear_has_body();
  }
  body_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), body);
  // @@protoc_insertion_point(field_set_allocated:tenon.transport.protobuf.BroadcastParam.body)
}

// optional bool net_crossed = 11;
inline bool BroadcastParam::has_net_crossed() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BroadcastParam::set_has_net_crossed() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BroadcastParam::clear_has_net_crossed() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BroadcastParam::clear_net_crossed() {
  net_crossed_ = false;
  clear_has_net_crossed();
}
inline bool BroadcastParam::net_crossed() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.BroadcastParam.net_crossed)
  return net_crossed_;
}
inline void BroadcastParam::set_net_crossed(bool value) {
  set_has_net_crossed();
  net_crossed_ = value;
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.BroadcastParam.net_crossed)
}

// repeated uint64 bloomfilter = 12;
inline int BroadcastParam::bloomfilter_size() const {
  return bloomfilter_.size();
}
inline void BroadcastParam::clear_bloomfilter() {
  bloomfilter_.Clear();
}
inline ::google::protobuf::uint64 BroadcastParam::bloomfilter(int index) const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.BroadcastParam.bloomfilter)
  return bloomfilter_.Get(index);
}
inline void BroadcastParam::set_bloomfilter(int index, ::google::protobuf::uint64 value) {
  bloomfilter_.Set(index, value);
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.BroadcastParam.bloomfilter)
}
inline void BroadcastParam::add_bloomfilter(::google::protobuf::uint64 value) {
  bloomfilter_.Add(value);
  // @@protoc_insertion_point(field_add:tenon.transport.protobuf.BroadcastParam.bloomfilter)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
BroadcastParam::bloomfilter() const {
  // @@protoc_insertion_point(field_list:tenon.transport.protobuf.BroadcastParam.bloomfilter)
  return bloomfilter_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
BroadcastParam::mutable_bloomfilter() {
  // @@protoc_insertion_point(field_mutable_list:tenon.transport.protobuf.BroadcastParam.bloomfilter)
  return &bloomfilter_;
}

// optional float evil_rate = 13;
inline bool BroadcastParam::has_evil_rate() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BroadcastParam::set_has_evil_rate() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BroadcastParam::clear_has_evil_rate() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BroadcastParam::clear_evil_rate() {
  evil_rate_ = 0;
  clear_has_evil_rate();
}
inline float BroadcastParam::evil_rate() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.BroadcastParam.evil_rate)
  return evil_rate_;
}
inline void BroadcastParam::set_evil_rate(float value) {
  set_has_evil_rate();
  evil_rate_ = value;
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.BroadcastParam.evil_rate)
}

// optional uint32 ign_bloomfilter_hop = 14;
inline bool BroadcastParam::has_ign_bloomfilter_hop() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BroadcastParam::set_has_ign_bloomfilter_hop() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BroadcastParam::clear_has_ign_bloomfilter_hop() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BroadcastParam::clear_ign_bloomfilter_hop() {
  ign_bloomfilter_hop_ = 0u;
  clear_has_ign_bloomfilter_hop();
}
inline ::google::protobuf::uint32 BroadcastParam::ign_bloomfilter_hop() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.BroadcastParam.ign_bloomfilter_hop)
  return ign_bloomfilter_hop_;
}
inline void BroadcastParam::set_ign_bloomfilter_hop(::google::protobuf::uint32 value) {
  set_has_ign_bloomfilter_hop();
  ign_bloomfilter_hop_ = value;
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.BroadcastParam.ign_bloomfilter_hop)
}

// -------------------------------------------------------------------

// Header

// optional bytes src_dht_key = 1;
inline bool Header::has_src_dht_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header::set_has_src_dht_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header::clear_has_src_dht_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header::clear_src_dht_key() {
  src_dht_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_src_dht_key();
}
inline const ::std::string& Header::src_dht_key() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.Header.src_dht_key)
  return src_dht_key_.GetNoArena();
}
inline void Header::set_src_dht_key(const ::std::string& value) {
  set_has_src_dht_key();
  src_dht_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.Header.src_dht_key)
}
#if LANG_CXX11
inline void Header::set_src_dht_key(::std::string&& value) {
  set_has_src_dht_key();
  src_dht_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.transport.protobuf.Header.src_dht_key)
}
#endif
inline void Header::set_src_dht_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_src_dht_key();
  src_dht_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.transport.protobuf.Header.src_dht_key)
}
inline void Header::set_src_dht_key(const void* value, size_t size) {
  set_has_src_dht_key();
  src_dht_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.transport.protobuf.Header.src_dht_key)
}
inline ::std::string* Header::mutable_src_dht_key() {
  set_has_src_dht_key();
  // @@protoc_insertion_point(field_mutable:tenon.transport.protobuf.Header.src_dht_key)
  return src_dht_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_src_dht_key() {
  // @@protoc_insertion_point(field_release:tenon.transport.protobuf.Header.src_dht_key)
  if (!has_src_dht_key()) {
    return NULL;
  }
  clear_has_src_dht_key();
  return src_dht_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_src_dht_key(::std::string* src_dht_key) {
  if (src_dht_key != NULL) {
    set_has_src_dht_key();
  } else {
    clear_has_src_dht_key();
  }
  src_dht_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), src_dht_key);
  // @@protoc_insertion_point(field_set_allocated:tenon.transport.protobuf.Header.src_dht_key)
}

// optional bytes des_dht_key = 2;
inline bool Header::has_des_dht_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Header::set_has_des_dht_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Header::clear_has_des_dht_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Header::clear_des_dht_key() {
  des_dht_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_des_dht_key();
}
inline const ::std::string& Header::des_dht_key() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.Header.des_dht_key)
  return des_dht_key_.GetNoArena();
}
inline void Header::set_des_dht_key(const ::std::string& value) {
  set_has_des_dht_key();
  des_dht_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.Header.des_dht_key)
}
#if LANG_CXX11
inline void Header::set_des_dht_key(::std::string&& value) {
  set_has_des_dht_key();
  des_dht_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.transport.protobuf.Header.des_dht_key)
}
#endif
inline void Header::set_des_dht_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_des_dht_key();
  des_dht_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.transport.protobuf.Header.des_dht_key)
}
inline void Header::set_des_dht_key(const void* value, size_t size) {
  set_has_des_dht_key();
  des_dht_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.transport.protobuf.Header.des_dht_key)
}
inline ::std::string* Header::mutable_des_dht_key() {
  set_has_des_dht_key();
  // @@protoc_insertion_point(field_mutable:tenon.transport.protobuf.Header.des_dht_key)
  return des_dht_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_des_dht_key() {
  // @@protoc_insertion_point(field_release:tenon.transport.protobuf.Header.des_dht_key)
  if (!has_des_dht_key()) {
    return NULL;
  }
  clear_has_des_dht_key();
  return des_dht_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_des_dht_key(::std::string* des_dht_key) {
  if (des_dht_key != NULL) {
    set_has_des_dht_key();
  } else {
    clear_has_des_dht_key();
  }
  des_dht_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), des_dht_key);
  // @@protoc_insertion_point(field_set_allocated:tenon.transport.protobuf.Header.des_dht_key)
}

// optional bytes src_node_id = 3;
inline bool Header::has_src_node_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Header::set_has_src_node_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Header::clear_has_src_node_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Header::clear_src_node_id() {
  src_node_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_src_node_id();
}
inline const ::std::string& Header::src_node_id() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.Header.src_node_id)
  return src_node_id_.GetNoArena();
}
inline void Header::set_src_node_id(const ::std::string& value) {
  set_has_src_node_id();
  src_node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.Header.src_node_id)
}
#if LANG_CXX11
inline void Header::set_src_node_id(::std::string&& value) {
  set_has_src_node_id();
  src_node_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.transport.protobuf.Header.src_node_id)
}
#endif
inline void Header::set_src_node_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_src_node_id();
  src_node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.transport.protobuf.Header.src_node_id)
}
inline void Header::set_src_node_id(const void* value, size_t size) {
  set_has_src_node_id();
  src_node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.transport.protobuf.Header.src_node_id)
}
inline ::std::string* Header::mutable_src_node_id() {
  set_has_src_node_id();
  // @@protoc_insertion_point(field_mutable:tenon.transport.protobuf.Header.src_node_id)
  return src_node_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_src_node_id() {
  // @@protoc_insertion_point(field_release:tenon.transport.protobuf.Header.src_node_id)
  if (!has_src_node_id()) {
    return NULL;
  }
  clear_has_src_node_id();
  return src_node_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_src_node_id(::std::string* src_node_id) {
  if (src_node_id != NULL) {
    set_has_src_node_id();
  } else {
    clear_has_src_node_id();
  }
  src_node_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), src_node_id);
  // @@protoc_insertion_point(field_set_allocated:tenon.transport.protobuf.Header.src_node_id)
}

// optional bytes des_node_id = 4;
inline bool Header::has_des_node_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Header::set_has_des_node_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Header::clear_has_des_node_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Header::clear_des_node_id() {
  des_node_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_des_node_id();
}
inline const ::std::string& Header::des_node_id() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.Header.des_node_id)
  return des_node_id_.GetNoArena();
}
inline void Header::set_des_node_id(const ::std::string& value) {
  set_has_des_node_id();
  des_node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.Header.des_node_id)
}
#if LANG_CXX11
inline void Header::set_des_node_id(::std::string&& value) {
  set_has_des_node_id();
  des_node_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.transport.protobuf.Header.des_node_id)
}
#endif
inline void Header::set_des_node_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_des_node_id();
  des_node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.transport.protobuf.Header.des_node_id)
}
inline void Header::set_des_node_id(const void* value, size_t size) {
  set_has_des_node_id();
  des_node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.transport.protobuf.Header.des_node_id)
}
inline ::std::string* Header::mutable_des_node_id() {
  set_has_des_node_id();
  // @@protoc_insertion_point(field_mutable:tenon.transport.protobuf.Header.des_node_id)
  return des_node_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_des_node_id() {
  // @@protoc_insertion_point(field_release:tenon.transport.protobuf.Header.des_node_id)
  if (!has_des_node_id()) {
    return NULL;
  }
  clear_has_des_node_id();
  return des_node_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_des_node_id(::std::string* des_node_id) {
  if (des_node_id != NULL) {
    set_has_des_node_id();
  } else {
    clear_has_des_node_id();
  }
  des_node_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), des_node_id);
  // @@protoc_insertion_point(field_set_allocated:tenon.transport.protobuf.Header.des_node_id)
}

// optional uint32 hop_count = 5;
inline bool Header::has_hop_count() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Header::set_has_hop_count() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Header::clear_has_hop_count() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Header::clear_hop_count() {
  hop_count_ = 0u;
  clear_has_hop_count();
}
inline ::google::protobuf::uint32 Header::hop_count() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.Header.hop_count)
  return hop_count_;
}
inline void Header::set_hop_count(::google::protobuf::uint32 value) {
  set_has_hop_count();
  hop_count_ = value;
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.Header.hop_count)
}

// optional bytes data = 6;
inline bool Header::has_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Header::set_has_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Header::clear_has_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Header::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& Header::data() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.Header.data)
  return data_.GetNoArena();
}
inline void Header::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.Header.data)
}
#if LANG_CXX11
inline void Header::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.transport.protobuf.Header.data)
}
#endif
inline void Header::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.transport.protobuf.Header.data)
}
inline void Header::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.transport.protobuf.Header.data)
}
inline ::std::string* Header::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:tenon.transport.protobuf.Header.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_data() {
  // @@protoc_insertion_point(field_release:tenon.transport.protobuf.Header.data)
  if (!has_data()) {
    return NULL;
  }
  clear_has_data();
  return data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:tenon.transport.protobuf.Header.data)
}

// optional uint32 priority = 7;
inline bool Header::has_priority() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Header::set_has_priority() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Header::clear_has_priority() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Header::clear_priority() {
  priority_ = 0u;
  clear_has_priority();
}
inline ::google::protobuf::uint32 Header::priority() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.Header.priority)
  return priority_;
}
inline void Header::set_priority(::google::protobuf::uint32 value) {
  set_has_priority();
  priority_ = value;
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.Header.priority)
}

// optional bytes debug = 8;
inline bool Header::has_debug() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Header::set_has_debug() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Header::clear_has_debug() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Header::clear_debug() {
  debug_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_debug();
}
inline const ::std::string& Header::debug() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.Header.debug)
  return debug_.GetNoArena();
}
inline void Header::set_debug(const ::std::string& value) {
  set_has_debug();
  debug_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.Header.debug)
}
#if LANG_CXX11
inline void Header::set_debug(::std::string&& value) {
  set_has_debug();
  debug_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.transport.protobuf.Header.debug)
}
#endif
inline void Header::set_debug(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_debug();
  debug_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.transport.protobuf.Header.debug)
}
inline void Header::set_debug(const void* value, size_t size) {
  set_has_debug();
  debug_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.transport.protobuf.Header.debug)
}
inline ::std::string* Header::mutable_debug() {
  set_has_debug();
  // @@protoc_insertion_point(field_mutable:tenon.transport.protobuf.Header.debug)
  return debug_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_debug() {
  // @@protoc_insertion_point(field_release:tenon.transport.protobuf.Header.debug)
  if (!has_debug()) {
    return NULL;
  }
  clear_has_debug();
  return debug_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_debug(::std::string* debug) {
  if (debug != NULL) {
    set_has_debug();
  } else {
    clear_has_debug();
  }
  debug_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), debug);
  // @@protoc_insertion_point(field_set_allocated:tenon.transport.protobuf.Header.debug)
}

// optional bytes from_ip = 9;
inline bool Header::has_from_ip() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Header::set_has_from_ip() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Header::clear_has_from_ip() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Header::clear_from_ip() {
  from_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_from_ip();
}
inline const ::std::string& Header::from_ip() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.Header.from_ip)
  return from_ip_.GetNoArena();
}
inline void Header::set_from_ip(const ::std::string& value) {
  set_has_from_ip();
  from_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.Header.from_ip)
}
#if LANG_CXX11
inline void Header::set_from_ip(::std::string&& value) {
  set_has_from_ip();
  from_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.transport.protobuf.Header.from_ip)
}
#endif
inline void Header::set_from_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_from_ip();
  from_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.transport.protobuf.Header.from_ip)
}
inline void Header::set_from_ip(const void* value, size_t size) {
  set_has_from_ip();
  from_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.transport.protobuf.Header.from_ip)
}
inline ::std::string* Header::mutable_from_ip() {
  set_has_from_ip();
  // @@protoc_insertion_point(field_mutable:tenon.transport.protobuf.Header.from_ip)
  return from_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_from_ip() {
  // @@protoc_insertion_point(field_release:tenon.transport.protobuf.Header.from_ip)
  if (!has_from_ip()) {
    return NULL;
  }
  clear_has_from_ip();
  return from_ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_from_ip(::std::string* from_ip) {
  if (from_ip != NULL) {
    set_has_from_ip();
  } else {
    clear_has_from_ip();
  }
  from_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from_ip);
  // @@protoc_insertion_point(field_set_allocated:tenon.transport.protobuf.Header.from_ip)
}

// optional uint32 from_port = 10;
inline bool Header::has_from_port() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Header::set_has_from_port() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Header::clear_has_from_port() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Header::clear_from_port() {
  from_port_ = 0u;
  clear_has_from_port();
}
inline ::google::protobuf::uint32 Header::from_port() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.Header.from_port)
  return from_port_;
}
inline void Header::set_from_port(::google::protobuf::uint32 value) {
  set_has_from_port();
  from_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.Header.from_port)
}

// optional bytes to_ip = 11;
inline bool Header::has_to_ip() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Header::set_has_to_ip() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Header::clear_has_to_ip() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Header::clear_to_ip() {
  to_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_to_ip();
}
inline const ::std::string& Header::to_ip() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.Header.to_ip)
  return to_ip_.GetNoArena();
}
inline void Header::set_to_ip(const ::std::string& value) {
  set_has_to_ip();
  to_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.Header.to_ip)
}
#if LANG_CXX11
inline void Header::set_to_ip(::std::string&& value) {
  set_has_to_ip();
  to_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.transport.protobuf.Header.to_ip)
}
#endif
inline void Header::set_to_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_to_ip();
  to_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.transport.protobuf.Header.to_ip)
}
inline void Header::set_to_ip(const void* value, size_t size) {
  set_has_to_ip();
  to_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.transport.protobuf.Header.to_ip)
}
inline ::std::string* Header::mutable_to_ip() {
  set_has_to_ip();
  // @@protoc_insertion_point(field_mutable:tenon.transport.protobuf.Header.to_ip)
  return to_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_to_ip() {
  // @@protoc_insertion_point(field_release:tenon.transport.protobuf.Header.to_ip)
  if (!has_to_ip()) {
    return NULL;
  }
  clear_has_to_ip();
  return to_ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_to_ip(::std::string* to_ip) {
  if (to_ip != NULL) {
    set_has_to_ip();
  } else {
    clear_has_to_ip();
  }
  to_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to_ip);
  // @@protoc_insertion_point(field_set_allocated:tenon.transport.protobuf.Header.to_ip)
}

// optional uint32 to_port = 12;
inline bool Header::has_to_port() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Header::set_has_to_port() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Header::clear_has_to_port() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Header::clear_to_port() {
  to_port_ = 0u;
  clear_has_to_port();
}
inline ::google::protobuf::uint32 Header::to_port() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.Header.to_port)
  return to_port_;
}
inline void Header::set_to_port(::google::protobuf::uint32 value) {
  set_has_to_port();
  to_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.Header.to_port)
}

// optional uint32 id = 13;
inline bool Header::has_id() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Header::set_has_id() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Header::clear_has_id() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Header::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Header::id() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.Header.id)
  return id_;
}
inline void Header::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.Header.id)
}

// optional uint64 hash = 14;
inline bool Header::has_hash() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Header::set_has_hash() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Header::clear_has_hash() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Header::clear_hash() {
  hash_ = GOOGLE_ULONGLONG(0);
  clear_has_hash();
}
inline ::google::protobuf::uint64 Header::hash() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.Header.hash)
  return hash_;
}
inline void Header::set_hash(::google::protobuf::uint64 value) {
  set_has_hash();
  hash_ = value;
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.Header.hash)
}

// optional uint32 type = 15;
inline bool Header::has_type() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Header::set_has_type() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Header::clear_has_type() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Header::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 Header::type() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.Header.type)
  return type_;
}
inline void Header::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.Header.type)
}

// optional bool client = 16;
inline bool Header::has_client() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Header::set_has_client() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Header::clear_has_client() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Header::clear_client() {
  client_ = false;
  clear_has_client();
}
inline bool Header::client() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.Header.client)
  return client_;
}
inline void Header::set_client(bool value) {
  set_has_client();
  client_ = value;
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.Header.client)
}

// optional bool client_relayed = 17;
inline bool Header::has_client_relayed() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Header::set_has_client_relayed() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Header::clear_has_client_relayed() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Header::clear_client_relayed() {
  client_relayed_ = false;
  clear_has_client_relayed();
}
inline bool Header::client_relayed() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.Header.client_relayed)
  return client_relayed_;
}
inline void Header::set_client_relayed(bool value) {
  set_has_client_relayed();
  client_relayed_ = value;
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.Header.client_relayed)
}

// optional bool client_proxy = 18;
inline bool Header::has_client_proxy() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Header::set_has_client_proxy() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Header::clear_has_client_proxy() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Header::clear_client_proxy() {
  client_proxy_ = false;
  clear_has_client_proxy();
}
inline bool Header::client_proxy() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.Header.client_proxy)
  return client_proxy_;
}
inline void Header::set_client_proxy(bool value) {
  set_has_client_proxy();
  client_proxy_ = value;
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.Header.client_proxy)
}

// optional bytes client_dht_key = 19;
inline bool Header::has_client_dht_key() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Header::set_has_client_dht_key() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Header::clear_has_client_dht_key() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Header::clear_client_dht_key() {
  client_dht_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_client_dht_key();
}
inline const ::std::string& Header::client_dht_key() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.Header.client_dht_key)
  return client_dht_key_.GetNoArena();
}
inline void Header::set_client_dht_key(const ::std::string& value) {
  set_has_client_dht_key();
  client_dht_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.Header.client_dht_key)
}
#if LANG_CXX11
inline void Header::set_client_dht_key(::std::string&& value) {
  set_has_client_dht_key();
  client_dht_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.transport.protobuf.Header.client_dht_key)
}
#endif
inline void Header::set_client_dht_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_client_dht_key();
  client_dht_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.transport.protobuf.Header.client_dht_key)
}
inline void Header::set_client_dht_key(const void* value, size_t size) {
  set_has_client_dht_key();
  client_dht_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.transport.protobuf.Header.client_dht_key)
}
inline ::std::string* Header::mutable_client_dht_key() {
  set_has_client_dht_key();
  // @@protoc_insertion_point(field_mutable:tenon.transport.protobuf.Header.client_dht_key)
  return client_dht_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_client_dht_key() {
  // @@protoc_insertion_point(field_release:tenon.transport.protobuf.Header.client_dht_key)
  if (!has_client_dht_key()) {
    return NULL;
  }
  clear_has_client_dht_key();
  return client_dht_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_client_dht_key(::std::string* client_dht_key) {
  if (client_dht_key != NULL) {
    set_has_client_dht_key();
  } else {
    clear_has_client_dht_key();
  }
  client_dht_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_dht_key);
  // @@protoc_insertion_point(field_set_allocated:tenon.transport.protobuf.Header.client_dht_key)
}

// optional bool client_handled = 20;
inline bool Header::has_client_handled() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Header::set_has_client_handled() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Header::clear_has_client_handled() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Header::clear_client_handled() {
  client_handled_ = false;
  clear_has_client_handled();
}
inline bool Header::client_handled() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.Header.client_handled)
  return client_handled_;
}
inline void Header::set_client_handled(bool value) {
  set_has_client_handled();
  client_handled_ = value;
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.Header.client_handled)
}

// optional bool universal = 21;
inline bool Header::has_universal() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Header::set_has_universal() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Header::clear_has_universal() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Header::clear_universal() {
  universal_ = false;
  clear_has_universal();
}
inline bool Header::universal() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.Header.universal)
  return universal_;
}
inline void Header::set_universal(bool value) {
  set_has_universal();
  universal_ = value;
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.Header.universal)
}

// optional .tenon.transport.protobuf.BroadcastParam broadcast = 22;
inline bool Header::has_broadcast() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Header::set_has_broadcast() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Header::clear_has_broadcast() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Header::clear_broadcast() {
  if (broadcast_ != NULL) broadcast_->Clear();
  clear_has_broadcast();
}
inline const ::tenon::transport::protobuf::BroadcastParam& Header::_internal_broadcast() const {
  return *broadcast_;
}
inline const ::tenon::transport::protobuf::BroadcastParam& Header::broadcast() const {
  const ::tenon::transport::protobuf::BroadcastParam* p = broadcast_;
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.Header.broadcast)
  return p != NULL ? *p : *reinterpret_cast<const ::tenon::transport::protobuf::BroadcastParam*>(
      &::tenon::transport::protobuf::_BroadcastParam_default_instance_);
}
inline ::tenon::transport::protobuf::BroadcastParam* Header::release_broadcast() {
  // @@protoc_insertion_point(field_release:tenon.transport.protobuf.Header.broadcast)
  clear_has_broadcast();
  ::tenon::transport::protobuf::BroadcastParam* temp = broadcast_;
  broadcast_ = NULL;
  return temp;
}
inline ::tenon::transport::protobuf::BroadcastParam* Header::mutable_broadcast() {
  set_has_broadcast();
  if (broadcast_ == NULL) {
    auto* p = CreateMaybeMessage<::tenon::transport::protobuf::BroadcastParam>(GetArenaNoVirtual());
    broadcast_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tenon.transport.protobuf.Header.broadcast)
  return broadcast_;
}
inline void Header::set_allocated_broadcast(::tenon::transport::protobuf::BroadcastParam* broadcast) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete broadcast_;
  }
  if (broadcast) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      broadcast = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, broadcast, submessage_arena);
    }
    set_has_broadcast();
  } else {
    clear_has_broadcast();
  }
  broadcast_ = broadcast;
  // @@protoc_insertion_point(field_set_allocated:tenon.transport.protobuf.Header.broadcast)
}

// optional bool handled = 23;
inline bool Header::has_handled() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Header::set_has_handled() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Header::clear_has_handled() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Header::clear_handled() {
  handled_ = false;
  clear_has_handled();
}
inline bool Header::handled() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.Header.handled)
  return handled_;
}
inline void Header::set_handled(bool value) {
  set_has_handled();
  handled_ = value;
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.Header.handled)
}

// optional uint64 des_dht_key_hash = 24;
inline bool Header::has_des_dht_key_hash() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Header::set_has_des_dht_key_hash() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Header::clear_has_des_dht_key_hash() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Header::clear_des_dht_key_hash() {
  des_dht_key_hash_ = GOOGLE_ULONGLONG(0);
  clear_has_des_dht_key_hash();
}
inline ::google::protobuf::uint64 Header::des_dht_key_hash() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.Header.des_dht_key_hash)
  return des_dht_key_hash_;
}
inline void Header::set_des_dht_key_hash(::google::protobuf::uint64 value) {
  set_has_des_dht_key_hash();
  des_dht_key_hash_ = value;
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.Header.des_dht_key_hash)
}

// optional bytes pubkey = 25;
inline bool Header::has_pubkey() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Header::set_has_pubkey() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Header::clear_has_pubkey() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Header::clear_pubkey() {
  pubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pubkey();
}
inline const ::std::string& Header::pubkey() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.Header.pubkey)
  return pubkey_.GetNoArena();
}
inline void Header::set_pubkey(const ::std::string& value) {
  set_has_pubkey();
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.Header.pubkey)
}
#if LANG_CXX11
inline void Header::set_pubkey(::std::string&& value) {
  set_has_pubkey();
  pubkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.transport.protobuf.Header.pubkey)
}
#endif
inline void Header::set_pubkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pubkey();
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.transport.protobuf.Header.pubkey)
}
inline void Header::set_pubkey(const void* value, size_t size) {
  set_has_pubkey();
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.transport.protobuf.Header.pubkey)
}
inline ::std::string* Header::mutable_pubkey() {
  set_has_pubkey();
  // @@protoc_insertion_point(field_mutable:tenon.transport.protobuf.Header.pubkey)
  return pubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_pubkey() {
  // @@protoc_insertion_point(field_release:tenon.transport.protobuf.Header.pubkey)
  if (!has_pubkey()) {
    return NULL;
  }
  clear_has_pubkey();
  return pubkey_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_pubkey(::std::string* pubkey) {
  if (pubkey != NULL) {
    set_has_pubkey();
  } else {
    clear_has_pubkey();
  }
  pubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pubkey);
  // @@protoc_insertion_point(field_set_allocated:tenon.transport.protobuf.Header.pubkey)
}

// optional bytes sign = 26;
inline bool Header::has_sign() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Header::set_has_sign() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Header::clear_has_sign() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Header::clear_sign() {
  sign_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sign();
}
inline const ::std::string& Header::sign() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.Header.sign)
  return sign_.GetNoArena();
}
inline void Header::set_sign(const ::std::string& value) {
  set_has_sign();
  sign_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.Header.sign)
}
#if LANG_CXX11
inline void Header::set_sign(::std::string&& value) {
  set_has_sign();
  sign_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.transport.protobuf.Header.sign)
}
#endif
inline void Header::set_sign(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sign();
  sign_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.transport.protobuf.Header.sign)
}
inline void Header::set_sign(const void* value, size_t size) {
  set_has_sign();
  sign_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.transport.protobuf.Header.sign)
}
inline ::std::string* Header::mutable_sign() {
  set_has_sign();
  // @@protoc_insertion_point(field_mutable:tenon.transport.protobuf.Header.sign)
  return sign_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_sign() {
  // @@protoc_insertion_point(field_release:tenon.transport.protobuf.Header.sign)
  if (!has_sign()) {
    return NULL;
  }
  clear_has_sign();
  return sign_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_sign(::std::string* sign) {
  if (sign != NULL) {
    set_has_sign();
  } else {
    clear_has_sign();
  }
  sign_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sign);
  // @@protoc_insertion_point(field_set_allocated:tenon.transport.protobuf.Header.sign)
}

// optional bool local = 27;
inline bool Header::has_local() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Header::set_has_local() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Header::clear_has_local() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Header::clear_local() {
  local_ = false;
  clear_has_local();
}
inline bool Header::local() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.Header.local)
  return local_;
}
inline void Header::set_local(bool value) {
  set_has_local();
  local_ = value;
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.Header.local)
}

// optional int32 des_network = 28;
inline bool Header::has_des_network() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Header::set_has_des_network() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Header::clear_has_des_network() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Header::clear_des_network() {
  des_network_ = 0;
  clear_has_des_network();
}
inline ::google::protobuf::int32 Header::des_network() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.Header.des_network)
  return des_network_;
}
inline void Header::set_des_network(::google::protobuf::int32 value) {
  set_has_des_network();
  des_network_ = value;
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.Header.des_network)
}

// optional bytes des_country = 29;
inline bool Header::has_des_country() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Header::set_has_des_country() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Header::clear_has_des_country() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Header::clear_des_country() {
  des_country_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_des_country();
}
inline const ::std::string& Header::des_country() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.Header.des_country)
  return des_country_.GetNoArena();
}
inline void Header::set_des_country(const ::std::string& value) {
  set_has_des_country();
  des_country_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.Header.des_country)
}
#if LANG_CXX11
inline void Header::set_des_country(::std::string&& value) {
  set_has_des_country();
  des_country_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.transport.protobuf.Header.des_country)
}
#endif
inline void Header::set_des_country(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_des_country();
  des_country_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.transport.protobuf.Header.des_country)
}
inline void Header::set_des_country(const void* value, size_t size) {
  set_has_des_country();
  des_country_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.transport.protobuf.Header.des_country)
}
inline ::std::string* Header::mutable_des_country() {
  set_has_des_country();
  // @@protoc_insertion_point(field_mutable:tenon.transport.protobuf.Header.des_country)
  return des_country_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_des_country() {
  // @@protoc_insertion_point(field_release:tenon.transport.protobuf.Header.des_country)
  if (!has_des_country()) {
    return NULL;
  }
  clear_has_des_country();
  return des_country_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_des_country(::std::string* des_country) {
  if (des_country != NULL) {
    set_has_des_country();
  } else {
    clear_has_des_country();
  }
  des_country_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), des_country);
  // @@protoc_insertion_point(field_set_allocated:tenon.transport.protobuf.Header.des_country)
}

// optional int32 transport_type = 30;
inline bool Header::has_transport_type() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Header::set_has_transport_type() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Header::clear_has_transport_type() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Header::clear_transport_type() {
  transport_type_ = 0;
  clear_has_transport_type();
}
inline ::google::protobuf::int32 Header::transport_type() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.Header.transport_type)
  return transport_type_;
}
inline void Header::set_transport_type(::google::protobuf::int32 value) {
  set_has_transport_type();
  transport_type_ = value;
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.Header.transport_type)
}

// optional int32 version = 31;
inline bool Header::has_version() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Header::set_has_version() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Header::clear_has_version() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void Header::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 Header::version() const {
  // @@protoc_insertion_point(field_get:tenon.transport.protobuf.Header.version)
  return version_;
}
inline void Header::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:tenon.transport.protobuf.Header.version)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace transport
}  // namespace tenon

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_transport_2eproto
