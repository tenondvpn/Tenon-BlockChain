// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dht.proto

#ifndef PROTOBUF_INCLUDED_dht_2eproto
#define PROTOBUF_INCLUDED_dht_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_dht_2eproto 

namespace protobuf_dht_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[12];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_dht_2eproto
namespace tenon {
namespace dht {
namespace protobuf {
class BootstrapRequest;
class BootstrapRequestDefaultTypeInternal;
extern BootstrapRequestDefaultTypeInternal _BootstrapRequest_default_instance_;
class BootstrapResponse;
class BootstrapResponseDefaultTypeInternal;
extern BootstrapResponseDefaultTypeInternal _BootstrapResponse_default_instance_;
class ConnectReqeust;
class ConnectReqeustDefaultTypeInternal;
extern ConnectReqeustDefaultTypeInternal _ConnectReqeust_default_instance_;
class DhtMessage;
class DhtMessageDefaultTypeInternal;
extern DhtMessageDefaultTypeInternal _DhtMessage_default_instance_;
class HeartbeatRequest;
class HeartbeatRequestDefaultTypeInternal;
extern HeartbeatRequestDefaultTypeInternal _HeartbeatRequest_default_instance_;
class HeartbeatResponse;
class HeartbeatResponseDefaultTypeInternal;
extern HeartbeatResponseDefaultTypeInternal _HeartbeatResponse_default_instance_;
class InitMessage;
class InitMessageDefaultTypeInternal;
extern InitMessageDefaultTypeInternal _InitMessage_default_instance_;
class NodeInfo;
class NodeInfoDefaultTypeInternal;
extern NodeInfoDefaultTypeInternal _NodeInfo_default_instance_;
class RefreshNeighborsRequest;
class RefreshNeighborsRequestDefaultTypeInternal;
extern RefreshNeighborsRequestDefaultTypeInternal _RefreshNeighborsRequest_default_instance_;
class RefreshNeighborsResponse;
class RefreshNeighborsResponseDefaultTypeInternal;
extern RefreshNeighborsResponseDefaultTypeInternal _RefreshNeighborsResponse_default_instance_;
class RelayVpnNodeInfo;
class RelayVpnNodeInfoDefaultTypeInternal;
extern RelayVpnNodeInfoDefaultTypeInternal _RelayVpnNodeInfo_default_instance_;
class VpnNodeInfo;
class VpnNodeInfoDefaultTypeInternal;
extern VpnNodeInfoDefaultTypeInternal _VpnNodeInfo_default_instance_;
}  // namespace protobuf
}  // namespace dht
}  // namespace tenon
namespace google {
namespace protobuf {
template<> ::tenon::dht::protobuf::BootstrapRequest* Arena::CreateMaybeMessage<::tenon::dht::protobuf::BootstrapRequest>(Arena*);
template<> ::tenon::dht::protobuf::BootstrapResponse* Arena::CreateMaybeMessage<::tenon::dht::protobuf::BootstrapResponse>(Arena*);
template<> ::tenon::dht::protobuf::ConnectReqeust* Arena::CreateMaybeMessage<::tenon::dht::protobuf::ConnectReqeust>(Arena*);
template<> ::tenon::dht::protobuf::DhtMessage* Arena::CreateMaybeMessage<::tenon::dht::protobuf::DhtMessage>(Arena*);
template<> ::tenon::dht::protobuf::HeartbeatRequest* Arena::CreateMaybeMessage<::tenon::dht::protobuf::HeartbeatRequest>(Arena*);
template<> ::tenon::dht::protobuf::HeartbeatResponse* Arena::CreateMaybeMessage<::tenon::dht::protobuf::HeartbeatResponse>(Arena*);
template<> ::tenon::dht::protobuf::InitMessage* Arena::CreateMaybeMessage<::tenon::dht::protobuf::InitMessage>(Arena*);
template<> ::tenon::dht::protobuf::NodeInfo* Arena::CreateMaybeMessage<::tenon::dht::protobuf::NodeInfo>(Arena*);
template<> ::tenon::dht::protobuf::RefreshNeighborsRequest* Arena::CreateMaybeMessage<::tenon::dht::protobuf::RefreshNeighborsRequest>(Arena*);
template<> ::tenon::dht::protobuf::RefreshNeighborsResponse* Arena::CreateMaybeMessage<::tenon::dht::protobuf::RefreshNeighborsResponse>(Arena*);
template<> ::tenon::dht::protobuf::RelayVpnNodeInfo* Arena::CreateMaybeMessage<::tenon::dht::protobuf::RelayVpnNodeInfo>(Arena*);
template<> ::tenon::dht::protobuf::VpnNodeInfo* Arena::CreateMaybeMessage<::tenon::dht::protobuf::VpnNodeInfo>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace tenon {
namespace dht {
namespace protobuf {

// ===================================================================

class BootstrapRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tenon.dht.protobuf.BootstrapRequest) */ {
 public:
  BootstrapRequest();
  virtual ~BootstrapRequest();

  BootstrapRequest(const BootstrapRequest& from);

  inline BootstrapRequest& operator=(const BootstrapRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BootstrapRequest(BootstrapRequest&& from) noexcept
    : BootstrapRequest() {
    *this = ::std::move(from);
  }

  inline BootstrapRequest& operator=(BootstrapRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BootstrapRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BootstrapRequest* internal_default_instance() {
    return reinterpret_cast<const BootstrapRequest*>(
               &_BootstrapRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(BootstrapRequest* other);
  friend void swap(BootstrapRequest& a, BootstrapRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BootstrapRequest* New() const final {
    return CreateMaybeMessage<BootstrapRequest>(NULL);
  }

  BootstrapRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BootstrapRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BootstrapRequest& from);
  void MergeFrom(const BootstrapRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BootstrapRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string local_ip = 1;
  bool has_local_ip() const;
  void clear_local_ip();
  static const int kLocalIpFieldNumber = 1;
  const ::std::string& local_ip() const;
  void set_local_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_local_ip(::std::string&& value);
  #endif
  void set_local_ip(const char* value);
  void set_local_ip(const char* value, size_t size);
  ::std::string* mutable_local_ip();
  ::std::string* release_local_ip();
  void set_allocated_local_ip(::std::string* local_ip);

  // optional bytes node_id = 4;
  bool has_node_id() const;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 4;
  const ::std::string& node_id() const;
  void set_node_id(const ::std::string& value);
  #if LANG_CXX11
  void set_node_id(::std::string&& value);
  #endif
  void set_node_id(const char* value);
  void set_node_id(const void* value, size_t size);
  ::std::string* mutable_node_id();
  ::std::string* release_node_id();
  void set_allocated_node_id(::std::string* node_id);

  // optional bytes uid = 15;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 15;
  const ::std::string& uid() const;
  void set_uid(const ::std::string& value);
  #if LANG_CXX11
  void set_uid(::std::string&& value);
  #endif
  void set_uid(const char* value);
  void set_uid(const void* value, size_t size);
  ::std::string* mutable_uid();
  ::std::string* release_uid();
  void set_allocated_uid(::std::string* uid);

  // optional bytes node_tag = 16;
  bool has_node_tag() const;
  void clear_node_tag();
  static const int kNodeTagFieldNumber = 16;
  const ::std::string& node_tag() const;
  void set_node_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_node_tag(::std::string&& value);
  #endif
  void set_node_tag(const char* value);
  void set_node_tag(const void* value, size_t size);
  ::std::string* mutable_node_tag();
  ::std::string* release_node_tag();
  void set_allocated_node_tag(::std::string* node_tag);

  // optional int32 local_port = 2;
  bool has_local_port() const;
  void clear_local_port();
  static const int kLocalPortFieldNumber = 2;
  ::google::protobuf::int32 local_port() const;
  void set_local_port(::google::protobuf::int32 value);

  // optional int32 nat_type = 3;
  bool has_nat_type() const;
  void clear_nat_type();
  static const int kNatTypeFieldNumber = 3;
  ::google::protobuf::int32 nat_type() const;
  void set_nat_type(::google::protobuf::int32 value);

  // optional int32 get_init_msg = 5;
  bool has_get_init_msg() const;
  void clear_get_init_msg();
  static const int kGetInitMsgFieldNumber = 5;
  ::google::protobuf::int32 get_init_msg() const;
  void set_get_init_msg(::google::protobuf::int32 value);

  // optional uint32 min_svr_port = 6;
  bool has_min_svr_port() const;
  void clear_min_svr_port();
  static const int kMinSvrPortFieldNumber = 6;
  ::google::protobuf::uint32 min_svr_port() const;
  void set_min_svr_port(::google::protobuf::uint32 value);

  // optional uint32 max_svr_port = 7;
  bool has_max_svr_port() const;
  void clear_max_svr_port();
  static const int kMaxSvrPortFieldNumber = 7;
  ::google::protobuf::uint32 max_svr_port() const;
  void set_max_svr_port(::google::protobuf::uint32 value);

  // optional uint32 min_route_port = 8;
  bool has_min_route_port() const;
  void clear_min_route_port();
  static const int kMinRoutePortFieldNumber = 8;
  ::google::protobuf::uint32 min_route_port() const;
  void set_min_route_port(::google::protobuf::uint32 value);

  // optional uint32 max_route_port = 9;
  bool has_max_route_port() const;
  void clear_max_route_port();
  static const int kMaxRoutePortFieldNumber = 9;
  ::google::protobuf::uint32 max_route_port() const;
  void set_max_route_port(::google::protobuf::uint32 value);

  // optional int32 public_port = 10;
  bool has_public_port() const;
  void clear_public_port();
  static const int kPublicPortFieldNumber = 10;
  ::google::protobuf::int32 public_port() const;
  void set_public_port(::google::protobuf::int32 value);

  // optional uint32 node_weight = 11;
  bool has_node_weight() const;
  void clear_node_weight();
  static const int kNodeWeightFieldNumber = 11;
  ::google::protobuf::uint32 node_weight() const;
  void set_node_weight(::google::protobuf::uint32 value);

  // optional uint32 min_udp_port = 12;
  bool has_min_udp_port() const;
  void clear_min_udp_port();
  static const int kMinUdpPortFieldNumber = 12;
  ::google::protobuf::uint32 min_udp_port() const;
  void set_min_udp_port(::google::protobuf::uint32 value);

  // optional uint32 max_udp_port = 13;
  bool has_max_udp_port() const;
  void clear_max_udp_port();
  static const int kMaxUdpPortFieldNumber = 13;
  ::google::protobuf::uint32 max_udp_port() const;
  void set_max_udp_port(::google::protobuf::uint32 value);

  // optional uint32 version = 14;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 14;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:tenon.dht.protobuf.BootstrapRequest)
 private:
  void set_has_local_ip();
  void clear_has_local_ip();
  void set_has_local_port();
  void clear_has_local_port();
  void set_has_nat_type();
  void clear_has_nat_type();
  void set_has_node_id();
  void clear_has_node_id();
  void set_has_get_init_msg();
  void clear_has_get_init_msg();
  void set_has_min_svr_port();
  void clear_has_min_svr_port();
  void set_has_max_svr_port();
  void clear_has_max_svr_port();
  void set_has_min_route_port();
  void clear_has_min_route_port();
  void set_has_max_route_port();
  void clear_has_max_route_port();
  void set_has_public_port();
  void clear_has_public_port();
  void set_has_node_weight();
  void clear_has_node_weight();
  void set_has_min_udp_port();
  void clear_has_min_udp_port();
  void set_has_max_udp_port();
  void clear_has_max_udp_port();
  void set_has_version();
  void clear_has_version();
  void set_has_uid();
  void clear_has_uid();
  void set_has_node_tag();
  void clear_has_node_tag();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr local_ip_;
  ::google::protobuf::internal::ArenaStringPtr node_id_;
  ::google::protobuf::internal::ArenaStringPtr uid_;
  ::google::protobuf::internal::ArenaStringPtr node_tag_;
  ::google::protobuf::int32 local_port_;
  ::google::protobuf::int32 nat_type_;
  ::google::protobuf::int32 get_init_msg_;
  ::google::protobuf::uint32 min_svr_port_;
  ::google::protobuf::uint32 max_svr_port_;
  ::google::protobuf::uint32 min_route_port_;
  ::google::protobuf::uint32 max_route_port_;
  ::google::protobuf::int32 public_port_;
  ::google::protobuf::uint32 node_weight_;
  ::google::protobuf::uint32 min_udp_port_;
  ::google::protobuf::uint32 max_udp_port_;
  ::google::protobuf::uint32 version_;
  friend struct ::protobuf_dht_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RelayVpnNodeInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tenon.dht.protobuf.RelayVpnNodeInfo) */ {
 public:
  RelayVpnNodeInfo();
  virtual ~RelayVpnNodeInfo();

  RelayVpnNodeInfo(const RelayVpnNodeInfo& from);

  inline RelayVpnNodeInfo& operator=(const RelayVpnNodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RelayVpnNodeInfo(RelayVpnNodeInfo&& from) noexcept
    : RelayVpnNodeInfo() {
    *this = ::std::move(from);
  }

  inline RelayVpnNodeInfo& operator=(RelayVpnNodeInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RelayVpnNodeInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RelayVpnNodeInfo* internal_default_instance() {
    return reinterpret_cast<const RelayVpnNodeInfo*>(
               &_RelayVpnNodeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RelayVpnNodeInfo* other);
  friend void swap(RelayVpnNodeInfo& a, RelayVpnNodeInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RelayVpnNodeInfo* New() const final {
    return CreateMaybeMessage<RelayVpnNodeInfo>(NULL);
  }

  RelayVpnNodeInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RelayVpnNodeInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RelayVpnNodeInfo& from);
  void MergeFrom(const RelayVpnNodeInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelayVpnNodeInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes ip = 1;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 1;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const void* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // optional bytes dhkey = 2;
  bool has_dhkey() const;
  void clear_dhkey();
  static const int kDhkeyFieldNumber = 2;
  const ::std::string& dhkey() const;
  void set_dhkey(const ::std::string& value);
  #if LANG_CXX11
  void set_dhkey(::std::string&& value);
  #endif
  void set_dhkey(const char* value);
  void set_dhkey(const void* value, size_t size);
  ::std::string* mutable_dhkey();
  ::std::string* release_dhkey();
  void set_allocated_dhkey(::std::string* dhkey);

  // optional bytes pubkey = 3;
  bool has_pubkey() const;
  void clear_pubkey();
  static const int kPubkeyFieldNumber = 3;
  const ::std::string& pubkey() const;
  void set_pubkey(const ::std::string& value);
  #if LANG_CXX11
  void set_pubkey(::std::string&& value);
  #endif
  void set_pubkey(const char* value);
  void set_pubkey(const void* value, size_t size);
  ::std::string* mutable_pubkey();
  ::std::string* release_pubkey();
  void set_allocated_pubkey(::std::string* pubkey);

  // optional bytes country = 4;
  bool has_country() const;
  void clear_country();
  static const int kCountryFieldNumber = 4;
  const ::std::string& country() const;
  void set_country(const ::std::string& value);
  #if LANG_CXX11
  void set_country(::std::string&& value);
  #endif
  void set_country(const char* value);
  void set_country(const void* value, size_t size);
  ::std::string* mutable_country();
  ::std::string* release_country();
  void set_allocated_country(::std::string* country);

  // optional bytes node_tag = 12;
  bool has_node_tag() const;
  void clear_node_tag();
  static const int kNodeTagFieldNumber = 12;
  const ::std::string& node_tag() const;
  void set_node_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_node_tag(::std::string&& value);
  #endif
  void set_node_tag(const char* value);
  void set_node_tag(const void* value, size_t size);
  ::std::string* mutable_node_tag();
  ::std::string* release_node_tag();
  void set_allocated_node_tag(::std::string* node_tag);

  // optional uint32 min_svr_port = 5;
  bool has_min_svr_port() const;
  void clear_min_svr_port();
  static const int kMinSvrPortFieldNumber = 5;
  ::google::protobuf::uint32 min_svr_port() const;
  void set_min_svr_port(::google::protobuf::uint32 value);

  // optional uint32 max_svr_port = 6;
  bool has_max_svr_port() const;
  void clear_max_svr_port();
  static const int kMaxSvrPortFieldNumber = 6;
  ::google::protobuf::uint32 max_svr_port() const;
  void set_max_svr_port(::google::protobuf::uint32 value);

  // optional uint32 min_route_port = 7;
  bool has_min_route_port() const;
  void clear_min_route_port();
  static const int kMinRoutePortFieldNumber = 7;
  ::google::protobuf::uint32 min_route_port() const;
  void set_min_route_port(::google::protobuf::uint32 value);

  // optional uint32 max_route_port = 8;
  bool has_max_route_port() const;
  void clear_max_route_port();
  static const int kMaxRoutePortFieldNumber = 8;
  ::google::protobuf::uint32 max_route_port() const;
  void set_max_route_port(::google::protobuf::uint32 value);

  // optional uint32 node_weight = 9;
  bool has_node_weight() const;
  void clear_node_weight();
  static const int kNodeWeightFieldNumber = 9;
  ::google::protobuf::uint32 node_weight() const;
  void set_node_weight(::google::protobuf::uint32 value);

  // optional uint32 min_udp_port = 10;
  bool has_min_udp_port() const;
  void clear_min_udp_port();
  static const int kMinUdpPortFieldNumber = 10;
  ::google::protobuf::uint32 min_udp_port() const;
  void set_min_udp_port(::google::protobuf::uint32 value);

  // optional uint32 max_udp_port = 11;
  bool has_max_udp_port() const;
  void clear_max_udp_port();
  static const int kMaxUdpPortFieldNumber = 11;
  ::google::protobuf::uint32 max_udp_port() const;
  void set_max_udp_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:tenon.dht.protobuf.RelayVpnNodeInfo)
 private:
  void set_has_ip();
  void clear_has_ip();
  void set_has_dhkey();
  void clear_has_dhkey();
  void set_has_pubkey();
  void clear_has_pubkey();
  void set_has_country();
  void clear_has_country();
  void set_has_min_svr_port();
  void clear_has_min_svr_port();
  void set_has_max_svr_port();
  void clear_has_max_svr_port();
  void set_has_min_route_port();
  void clear_has_min_route_port();
  void set_has_max_route_port();
  void clear_has_max_route_port();
  void set_has_node_weight();
  void clear_has_node_weight();
  void set_has_min_udp_port();
  void clear_has_min_udp_port();
  void set_has_max_udp_port();
  void clear_has_max_udp_port();
  void set_has_node_tag();
  void clear_has_node_tag();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::internal::ArenaStringPtr dhkey_;
  ::google::protobuf::internal::ArenaStringPtr pubkey_;
  ::google::protobuf::internal::ArenaStringPtr country_;
  ::google::protobuf::internal::ArenaStringPtr node_tag_;
  ::google::protobuf::uint32 min_svr_port_;
  ::google::protobuf::uint32 max_svr_port_;
  ::google::protobuf::uint32 min_route_port_;
  ::google::protobuf::uint32 max_route_port_;
  ::google::protobuf::uint32 node_weight_;
  ::google::protobuf::uint32 min_udp_port_;
  ::google::protobuf::uint32 max_udp_port_;
  friend struct ::protobuf_dht_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VpnNodeInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tenon.dht.protobuf.VpnNodeInfo) */ {
 public:
  VpnNodeInfo();
  virtual ~VpnNodeInfo();

  VpnNodeInfo(const VpnNodeInfo& from);

  inline VpnNodeInfo& operator=(const VpnNodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VpnNodeInfo(VpnNodeInfo&& from) noexcept
    : VpnNodeInfo() {
    *this = ::std::move(from);
  }

  inline VpnNodeInfo& operator=(VpnNodeInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VpnNodeInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VpnNodeInfo* internal_default_instance() {
    return reinterpret_cast<const VpnNodeInfo*>(
               &_VpnNodeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(VpnNodeInfo* other);
  friend void swap(VpnNodeInfo& a, VpnNodeInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VpnNodeInfo* New() const final {
    return CreateMaybeMessage<VpnNodeInfo>(NULL);
  }

  VpnNodeInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VpnNodeInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VpnNodeInfo& from);
  void MergeFrom(const VpnNodeInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VpnNodeInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tenon.dht.protobuf.RelayVpnNodeInfo relay_vpn_nodes = 12;
  int relay_vpn_nodes_size() const;
  void clear_relay_vpn_nodes();
  static const int kRelayVpnNodesFieldNumber = 12;
  ::tenon::dht::protobuf::RelayVpnNodeInfo* mutable_relay_vpn_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::tenon::dht::protobuf::RelayVpnNodeInfo >*
      mutable_relay_vpn_nodes();
  const ::tenon::dht::protobuf::RelayVpnNodeInfo& relay_vpn_nodes(int index) const;
  ::tenon::dht::protobuf::RelayVpnNodeInfo* add_relay_vpn_nodes();
  const ::google::protobuf::RepeatedPtrField< ::tenon::dht::protobuf::RelayVpnNodeInfo >&
      relay_vpn_nodes() const;

  // optional bytes ip = 1;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 1;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const void* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // optional bytes dhkey = 2;
  bool has_dhkey() const;
  void clear_dhkey();
  static const int kDhkeyFieldNumber = 2;
  const ::std::string& dhkey() const;
  void set_dhkey(const ::std::string& value);
  #if LANG_CXX11
  void set_dhkey(::std::string&& value);
  #endif
  void set_dhkey(const char* value);
  void set_dhkey(const void* value, size_t size);
  ::std::string* mutable_dhkey();
  ::std::string* release_dhkey();
  void set_allocated_dhkey(::std::string* dhkey);

  // optional bytes pubkey = 3;
  bool has_pubkey() const;
  void clear_pubkey();
  static const int kPubkeyFieldNumber = 3;
  const ::std::string& pubkey() const;
  void set_pubkey(const ::std::string& value);
  #if LANG_CXX11
  void set_pubkey(::std::string&& value);
  #endif
  void set_pubkey(const char* value);
  void set_pubkey(const void* value, size_t size);
  ::std::string* mutable_pubkey();
  ::std::string* release_pubkey();
  void set_allocated_pubkey(::std::string* pubkey);

  // optional bytes country = 4;
  bool has_country() const;
  void clear_country();
  static const int kCountryFieldNumber = 4;
  const ::std::string& country() const;
  void set_country(const ::std::string& value);
  #if LANG_CXX11
  void set_country(::std::string&& value);
  #endif
  void set_country(const char* value);
  void set_country(const void* value, size_t size);
  ::std::string* mutable_country();
  ::std::string* release_country();
  void set_allocated_country(::std::string* country);

  // optional bytes node_tag = 13;
  bool has_node_tag() const;
  void clear_node_tag();
  static const int kNodeTagFieldNumber = 13;
  const ::std::string& node_tag() const;
  void set_node_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_node_tag(::std::string&& value);
  #endif
  void set_node_tag(const char* value);
  void set_node_tag(const void* value, size_t size);
  ::std::string* mutable_node_tag();
  ::std::string* release_node_tag();
  void set_allocated_node_tag(::std::string* node_tag);

  // optional uint32 min_svr_port = 5;
  bool has_min_svr_port() const;
  void clear_min_svr_port();
  static const int kMinSvrPortFieldNumber = 5;
  ::google::protobuf::uint32 min_svr_port() const;
  void set_min_svr_port(::google::protobuf::uint32 value);

  // optional uint32 max_svr_port = 6;
  bool has_max_svr_port() const;
  void clear_max_svr_port();
  static const int kMaxSvrPortFieldNumber = 6;
  ::google::protobuf::uint32 max_svr_port() const;
  void set_max_svr_port(::google::protobuf::uint32 value);

  // optional uint32 min_route_port = 7;
  bool has_min_route_port() const;
  void clear_min_route_port();
  static const int kMinRoutePortFieldNumber = 7;
  ::google::protobuf::uint32 min_route_port() const;
  void set_min_route_port(::google::protobuf::uint32 value);

  // optional uint32 max_route_port = 8;
  bool has_max_route_port() const;
  void clear_max_route_port();
  static const int kMaxRoutePortFieldNumber = 8;
  ::google::protobuf::uint32 max_route_port() const;
  void set_max_route_port(::google::protobuf::uint32 value);

  // optional uint32 node_weight = 9;
  bool has_node_weight() const;
  void clear_node_weight();
  static const int kNodeWeightFieldNumber = 9;
  ::google::protobuf::uint32 node_weight() const;
  void set_node_weight(::google::protobuf::uint32 value);

  // optional uint32 min_udp_port = 10;
  bool has_min_udp_port() const;
  void clear_min_udp_port();
  static const int kMinUdpPortFieldNumber = 10;
  ::google::protobuf::uint32 min_udp_port() const;
  void set_min_udp_port(::google::protobuf::uint32 value);

  // optional uint32 max_udp_port = 11;
  bool has_max_udp_port() const;
  void clear_max_udp_port();
  static const int kMaxUdpPortFieldNumber = 11;
  ::google::protobuf::uint32 max_udp_port() const;
  void set_max_udp_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:tenon.dht.protobuf.VpnNodeInfo)
 private:
  void set_has_ip();
  void clear_has_ip();
  void set_has_dhkey();
  void clear_has_dhkey();
  void set_has_pubkey();
  void clear_has_pubkey();
  void set_has_country();
  void clear_has_country();
  void set_has_min_svr_port();
  void clear_has_min_svr_port();
  void set_has_max_svr_port();
  void clear_has_max_svr_port();
  void set_has_min_route_port();
  void clear_has_min_route_port();
  void set_has_max_route_port();
  void clear_has_max_route_port();
  void set_has_node_weight();
  void clear_has_node_weight();
  void set_has_min_udp_port();
  void clear_has_min_udp_port();
  void set_has_max_udp_port();
  void clear_has_max_udp_port();
  void set_has_node_tag();
  void clear_has_node_tag();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::tenon::dht::protobuf::RelayVpnNodeInfo > relay_vpn_nodes_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::internal::ArenaStringPtr dhkey_;
  ::google::protobuf::internal::ArenaStringPtr pubkey_;
  ::google::protobuf::internal::ArenaStringPtr country_;
  ::google::protobuf::internal::ArenaStringPtr node_tag_;
  ::google::protobuf::uint32 min_svr_port_;
  ::google::protobuf::uint32 max_svr_port_;
  ::google::protobuf::uint32 min_route_port_;
  ::google::protobuf::uint32 max_route_port_;
  ::google::protobuf::uint32 node_weight_;
  ::google::protobuf::uint32 min_udp_port_;
  ::google::protobuf::uint32 max_udp_port_;
  friend struct ::protobuf_dht_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InitMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tenon.dht.protobuf.InitMessage) */ {
 public:
  InitMessage();
  virtual ~InitMessage();

  InitMessage(const InitMessage& from);

  inline InitMessage& operator=(const InitMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InitMessage(InitMessage&& from) noexcept
    : InitMessage() {
    *this = ::std::move(from);
  }

  inline InitMessage& operator=(InitMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InitMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InitMessage* internal_default_instance() {
    return reinterpret_cast<const InitMessage*>(
               &_InitMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(InitMessage* other);
  friend void swap(InitMessage& a, InitMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InitMessage* New() const final {
    return CreateMaybeMessage<InitMessage>(NULL);
  }

  InitMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InitMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InitMessage& from);
  void MergeFrom(const InitMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tenon.dht.protobuf.VpnNodeInfo route_nodes = 2;
  int route_nodes_size() const;
  void clear_route_nodes();
  static const int kRouteNodesFieldNumber = 2;
  ::tenon::dht::protobuf::VpnNodeInfo* mutable_route_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::tenon::dht::protobuf::VpnNodeInfo >*
      mutable_route_nodes();
  const ::tenon::dht::protobuf::VpnNodeInfo& route_nodes(int index) const;
  ::tenon::dht::protobuf::VpnNodeInfo* add_route_nodes();
  const ::google::protobuf::RepeatedPtrField< ::tenon::dht::protobuf::VpnNodeInfo >&
      route_nodes() const;

  // repeated .tenon.dht.protobuf.VpnNodeInfo vpn_nodes = 3;
  int vpn_nodes_size() const;
  void clear_vpn_nodes();
  static const int kVpnNodesFieldNumber = 3;
  ::tenon::dht::protobuf::VpnNodeInfo* mutable_vpn_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::tenon::dht::protobuf::VpnNodeInfo >*
      mutable_vpn_nodes();
  const ::tenon::dht::protobuf::VpnNodeInfo& vpn_nodes(int index) const;
  ::tenon::dht::protobuf::VpnNodeInfo* add_vpn_nodes();
  const ::google::protobuf::RepeatedPtrField< ::tenon::dht::protobuf::VpnNodeInfo >&
      vpn_nodes() const;

  // repeated .tenon.dht.protobuf.VpnNodeInfo vip_route_nodes = 9;
  int vip_route_nodes_size() const;
  void clear_vip_route_nodes();
  static const int kVipRouteNodesFieldNumber = 9;
  ::tenon::dht::protobuf::VpnNodeInfo* mutable_vip_route_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::tenon::dht::protobuf::VpnNodeInfo >*
      mutable_vip_route_nodes();
  const ::tenon::dht::protobuf::VpnNodeInfo& vip_route_nodes(int index) const;
  ::tenon::dht::protobuf::VpnNodeInfo* add_vip_route_nodes();
  const ::google::protobuf::RepeatedPtrField< ::tenon::dht::protobuf::VpnNodeInfo >&
      vip_route_nodes() const;

  // repeated .tenon.dht.protobuf.VpnNodeInfo vip_vpn_nodes = 10;
  int vip_vpn_nodes_size() const;
  void clear_vip_vpn_nodes();
  static const int kVipVpnNodesFieldNumber = 10;
  ::tenon::dht::protobuf::VpnNodeInfo* mutable_vip_vpn_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::tenon::dht::protobuf::VpnNodeInfo >*
      mutable_vip_vpn_nodes();
  const ::tenon::dht::protobuf::VpnNodeInfo& vip_vpn_nodes(int index) const;
  ::tenon::dht::protobuf::VpnNodeInfo* add_vip_vpn_nodes();
  const ::google::protobuf::RepeatedPtrField< ::tenon::dht::protobuf::VpnNodeInfo >&
      vip_vpn_nodes() const;

  // optional bytes version_info = 1;
  bool has_version_info() const;
  void clear_version_info();
  static const int kVersionInfoFieldNumber = 1;
  const ::std::string& version_info() const;
  void set_version_info(const ::std::string& value);
  #if LANG_CXX11
  void set_version_info(::std::string&& value);
  #endif
  void set_version_info(const char* value);
  void set_version_info(const void* value, size_t size);
  ::std::string* mutable_version_info();
  ::std::string* release_version_info();
  void set_allocated_version_info(::std::string* version_info);

  // optional bytes vpn_node_count = 5;
  bool has_vpn_node_count() const;
  void clear_vpn_node_count();
  static const int kVpnNodeCountFieldNumber = 5;
  const ::std::string& vpn_node_count() const;
  void set_vpn_node_count(const ::std::string& value);
  #if LANG_CXX11
  void set_vpn_node_count(::std::string&& value);
  #endif
  void set_vpn_node_count(const char* value);
  void set_vpn_node_count(const void* value, size_t size);
  ::std::string* mutable_vpn_node_count();
  ::std::string* release_vpn_node_count();
  void set_allocated_vpn_node_count(::std::string* vpn_node_count);

  // optional bytes vpn_count_svr = 6;
  bool has_vpn_count_svr() const;
  void clear_vpn_count_svr();
  static const int kVpnCountSvrFieldNumber = 6;
  const ::std::string& vpn_count_svr() const;
  void set_vpn_count_svr(const ::std::string& value);
  #if LANG_CXX11
  void set_vpn_count_svr(::std::string&& value);
  #endif
  void set_vpn_count_svr(const char* value);
  void set_vpn_count_svr(const void* value, size_t size);
  ::std::string* mutable_vpn_count_svr();
  ::std::string* release_vpn_count_svr();
  void set_allocated_vpn_count_svr(::std::string* vpn_count_svr);

  // optional bytes init_blocks = 7;
  bool has_init_blocks() const;
  void clear_init_blocks();
  static const int kInitBlocksFieldNumber = 7;
  const ::std::string& init_blocks() const;
  void set_init_blocks(const ::std::string& value);
  #if LANG_CXX11
  void set_init_blocks(::std::string&& value);
  #endif
  void set_init_blocks(const char* value);
  void set_init_blocks(const void* value, size_t size);
  ::std::string* mutable_init_blocks();
  ::std::string* release_init_blocks();
  void set_allocated_init_blocks(::std::string* init_blocks);

  // optional bytes bft_nodes = 8;
  bool has_bft_nodes() const;
  void clear_bft_nodes();
  static const int kBftNodesFieldNumber = 8;
  const ::std::string& bft_nodes() const;
  void set_bft_nodes(const ::std::string& value);
  #if LANG_CXX11
  void set_bft_nodes(::std::string&& value);
  #endif
  void set_bft_nodes(const char* value);
  void set_bft_nodes(const void* value, size_t size);
  ::std::string* mutable_bft_nodes();
  ::std::string* release_bft_nodes();
  void set_allocated_bft_nodes(::std::string* bft_nodes);

  // optional bool use_conf_nodes = 4;
  bool has_use_conf_nodes() const;
  void clear_use_conf_nodes();
  static const int kUseConfNodesFieldNumber = 4;
  bool use_conf_nodes() const;
  void set_use_conf_nodes(bool value);

  // @@protoc_insertion_point(class_scope:tenon.dht.protobuf.InitMessage)
 private:
  void set_has_version_info();
  void clear_has_version_info();
  void set_has_use_conf_nodes();
  void clear_has_use_conf_nodes();
  void set_has_vpn_node_count();
  void clear_has_vpn_node_count();
  void set_has_vpn_count_svr();
  void clear_has_vpn_count_svr();
  void set_has_init_blocks();
  void clear_has_init_blocks();
  void set_has_bft_nodes();
  void clear_has_bft_nodes();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::tenon::dht::protobuf::VpnNodeInfo > route_nodes_;
  ::google::protobuf::RepeatedPtrField< ::tenon::dht::protobuf::VpnNodeInfo > vpn_nodes_;
  ::google::protobuf::RepeatedPtrField< ::tenon::dht::protobuf::VpnNodeInfo > vip_route_nodes_;
  ::google::protobuf::RepeatedPtrField< ::tenon::dht::protobuf::VpnNodeInfo > vip_vpn_nodes_;
  ::google::protobuf::internal::ArenaStringPtr version_info_;
  ::google::protobuf::internal::ArenaStringPtr vpn_node_count_;
  ::google::protobuf::internal::ArenaStringPtr vpn_count_svr_;
  ::google::protobuf::internal::ArenaStringPtr init_blocks_;
  ::google::protobuf::internal::ArenaStringPtr bft_nodes_;
  bool use_conf_nodes_;
  friend struct ::protobuf_dht_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BootstrapResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tenon.dht.protobuf.BootstrapResponse) */ {
 public:
  BootstrapResponse();
  virtual ~BootstrapResponse();

  BootstrapResponse(const BootstrapResponse& from);

  inline BootstrapResponse& operator=(const BootstrapResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BootstrapResponse(BootstrapResponse&& from) noexcept
    : BootstrapResponse() {
    *this = ::std::move(from);
  }

  inline BootstrapResponse& operator=(BootstrapResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BootstrapResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BootstrapResponse* internal_default_instance() {
    return reinterpret_cast<const BootstrapResponse*>(
               &_BootstrapResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(BootstrapResponse* other);
  friend void swap(BootstrapResponse& a, BootstrapResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BootstrapResponse* New() const final {
    return CreateMaybeMessage<BootstrapResponse>(NULL);
  }

  BootstrapResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BootstrapResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BootstrapResponse& from);
  void MergeFrom(const BootstrapResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BootstrapResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes node_id = 1;
  bool has_node_id() const;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  const ::std::string& node_id() const;
  void set_node_id(const ::std::string& value);
  #if LANG_CXX11
  void set_node_id(::std::string&& value);
  #endif
  void set_node_id(const char* value);
  void set_node_id(const void* value, size_t size);
  ::std::string* mutable_node_id();
  ::std::string* release_node_id();
  void set_allocated_node_id(::std::string* node_id);

  // optional string local_ip = 3;
  bool has_local_ip() const;
  void clear_local_ip();
  static const int kLocalIpFieldNumber = 3;
  const ::std::string& local_ip() const;
  void set_local_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_local_ip(::std::string&& value);
  #endif
  void set_local_ip(const char* value);
  void set_local_ip(const char* value, size_t size);
  ::std::string* mutable_local_ip();
  ::std::string* release_local_ip();
  void set_allocated_local_ip(::std::string* local_ip);

  // optional string public_ip = 5;
  bool has_public_ip() const;
  void clear_public_ip();
  static const int kPublicIpFieldNumber = 5;
  const ::std::string& public_ip() const;
  void set_public_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_public_ip(::std::string&& value);
  #endif
  void set_public_ip(const char* value);
  void set_public_ip(const char* value, size_t size);
  ::std::string* mutable_public_ip();
  ::std::string* release_public_ip();
  void set_allocated_public_ip(::std::string* public_ip);

  // optional bytes node_tag = 17;
  bool has_node_tag() const;
  void clear_node_tag();
  static const int kNodeTagFieldNumber = 17;
  const ::std::string& node_tag() const;
  void set_node_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_node_tag(::std::string&& value);
  #endif
  void set_node_tag(const char* value);
  void set_node_tag(const void* value, size_t size);
  ::std::string* mutable_node_tag();
  ::std::string* release_node_tag();
  void set_allocated_node_tag(::std::string* node_tag);

  // optional .tenon.dht.protobuf.InitMessage init_message = 8;
  bool has_init_message() const;
  void clear_init_message();
  static const int kInitMessageFieldNumber = 8;
  private:
  const ::tenon::dht::protobuf::InitMessage& _internal_init_message() const;
  public:
  const ::tenon::dht::protobuf::InitMessage& init_message() const;
  ::tenon::dht::protobuf::InitMessage* release_init_message();
  ::tenon::dht::protobuf::InitMessage* mutable_init_message();
  void set_allocated_init_message(::tenon::dht::protobuf::InitMessage* init_message);

  // optional int32 nat_type = 2;
  bool has_nat_type() const;
  void clear_nat_type();
  static const int kNatTypeFieldNumber = 2;
  ::google::protobuf::int32 nat_type() const;
  void set_nat_type(::google::protobuf::int32 value);

  // optional int32 local_port = 4;
  bool has_local_port() const;
  void clear_local_port();
  static const int kLocalPortFieldNumber = 4;
  ::google::protobuf::int32 local_port() const;
  void set_local_port(::google::protobuf::int32 value);

  // optional int32 public_port = 6;
  bool has_public_port() const;
  void clear_public_port();
  static const int kPublicPortFieldNumber = 6;
  ::google::protobuf::int32 public_port() const;
  void set_public_port(::google::protobuf::int32 value);

  // optional int32 country_code = 7;
  bool has_country_code() const;
  void clear_country_code();
  static const int kCountryCodeFieldNumber = 7;
  ::google::protobuf::int32 country_code() const;
  void set_country_code(::google::protobuf::int32 value);

  // optional uint32 min_svr_port = 9;
  bool has_min_svr_port() const;
  void clear_min_svr_port();
  static const int kMinSvrPortFieldNumber = 9;
  ::google::protobuf::uint32 min_svr_port() const;
  void set_min_svr_port(::google::protobuf::uint32 value);

  // optional uint32 max_svr_port = 10;
  bool has_max_svr_port() const;
  void clear_max_svr_port();
  static const int kMaxSvrPortFieldNumber = 10;
  ::google::protobuf::uint32 max_svr_port() const;
  void set_max_svr_port(::google::protobuf::uint32 value);

  // optional uint32 min_route_port = 11;
  bool has_min_route_port() const;
  void clear_min_route_port();
  static const int kMinRoutePortFieldNumber = 11;
  ::google::protobuf::uint32 min_route_port() const;
  void set_min_route_port(::google::protobuf::uint32 value);

  // optional uint32 max_route_port = 12;
  bool has_max_route_port() const;
  void clear_max_route_port();
  static const int kMaxRoutePortFieldNumber = 12;
  ::google::protobuf::uint32 max_route_port() const;
  void set_max_route_port(::google::protobuf::uint32 value);

  // optional int32 peer_public_port = 13;
  bool has_peer_public_port() const;
  void clear_peer_public_port();
  static const int kPeerPublicPortFieldNumber = 13;
  ::google::protobuf::int32 peer_public_port() const;
  void set_peer_public_port(::google::protobuf::int32 value);

  // optional uint32 node_weight = 14;
  bool has_node_weight() const;
  void clear_node_weight();
  static const int kNodeWeightFieldNumber = 14;
  ::google::protobuf::uint32 node_weight() const;
  void set_node_weight(::google::protobuf::uint32 value);

  // optional uint32 min_udp_port = 15;
  bool has_min_udp_port() const;
  void clear_min_udp_port();
  static const int kMinUdpPortFieldNumber = 15;
  ::google::protobuf::uint32 min_udp_port() const;
  void set_min_udp_port(::google::protobuf::uint32 value);

  // optional uint32 max_udp_port = 16;
  bool has_max_udp_port() const;
  void clear_max_udp_port();
  static const int kMaxUdpPortFieldNumber = 16;
  ::google::protobuf::uint32 max_udp_port() const;
  void set_max_udp_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:tenon.dht.protobuf.BootstrapResponse)
 private:
  void set_has_node_id();
  void clear_has_node_id();
  void set_has_nat_type();
  void clear_has_nat_type();
  void set_has_local_ip();
  void clear_has_local_ip();
  void set_has_local_port();
  void clear_has_local_port();
  void set_has_public_ip();
  void clear_has_public_ip();
  void set_has_public_port();
  void clear_has_public_port();
  void set_has_country_code();
  void clear_has_country_code();
  void set_has_init_message();
  void clear_has_init_message();
  void set_has_min_svr_port();
  void clear_has_min_svr_port();
  void set_has_max_svr_port();
  void clear_has_max_svr_port();
  void set_has_min_route_port();
  void clear_has_min_route_port();
  void set_has_max_route_port();
  void clear_has_max_route_port();
  void set_has_peer_public_port();
  void clear_has_peer_public_port();
  void set_has_node_weight();
  void clear_has_node_weight();
  void set_has_min_udp_port();
  void clear_has_min_udp_port();
  void set_has_max_udp_port();
  void clear_has_max_udp_port();
  void set_has_node_tag();
  void clear_has_node_tag();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr node_id_;
  ::google::protobuf::internal::ArenaStringPtr local_ip_;
  ::google::protobuf::internal::ArenaStringPtr public_ip_;
  ::google::protobuf::internal::ArenaStringPtr node_tag_;
  ::tenon::dht::protobuf::InitMessage* init_message_;
  ::google::protobuf::int32 nat_type_;
  ::google::protobuf::int32 local_port_;
  ::google::protobuf::int32 public_port_;
  ::google::protobuf::int32 country_code_;
  ::google::protobuf::uint32 min_svr_port_;
  ::google::protobuf::uint32 max_svr_port_;
  ::google::protobuf::uint32 min_route_port_;
  ::google::protobuf::uint32 max_route_port_;
  ::google::protobuf::int32 peer_public_port_;
  ::google::protobuf::uint32 node_weight_;
  ::google::protobuf::uint32 min_udp_port_;
  ::google::protobuf::uint32 max_udp_port_;
  friend struct ::protobuf_dht_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RefreshNeighborsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tenon.dht.protobuf.RefreshNeighborsRequest) */ {
 public:
  RefreshNeighborsRequest();
  virtual ~RefreshNeighborsRequest();

  RefreshNeighborsRequest(const RefreshNeighborsRequest& from);

  inline RefreshNeighborsRequest& operator=(const RefreshNeighborsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RefreshNeighborsRequest(RefreshNeighborsRequest&& from) noexcept
    : RefreshNeighborsRequest() {
    *this = ::std::move(from);
  }

  inline RefreshNeighborsRequest& operator=(RefreshNeighborsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RefreshNeighborsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RefreshNeighborsRequest* internal_default_instance() {
    return reinterpret_cast<const RefreshNeighborsRequest*>(
               &_RefreshNeighborsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(RefreshNeighborsRequest* other);
  friend void swap(RefreshNeighborsRequest& a, RefreshNeighborsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RefreshNeighborsRequest* New() const final {
    return CreateMaybeMessage<RefreshNeighborsRequest>(NULL);
  }

  RefreshNeighborsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RefreshNeighborsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RefreshNeighborsRequest& from);
  void MergeFrom(const RefreshNeighborsRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefreshNeighborsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 bloomfilter1 = 3;
  int bloomfilter1_size() const;
  void clear_bloomfilter1();
  static const int kBloomfilter1FieldNumber = 3;
  ::google::protobuf::uint64 bloomfilter1(int index) const;
  void set_bloomfilter1(int index, ::google::protobuf::uint64 value);
  void add_bloomfilter1(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      bloomfilter1() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_bloomfilter1();

  // repeated uint64 bloomfilter = 4;
  int bloomfilter_size() const;
  void clear_bloomfilter();
  static const int kBloomfilterFieldNumber = 4;
  ::google::protobuf::uint64 bloomfilter(int index) const;
  void set_bloomfilter(int index, ::google::protobuf::uint64 value);
  void add_bloomfilter(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      bloomfilter() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_bloomfilter();

  // optional bytes des_dht_key = 2;
  bool has_des_dht_key() const;
  void clear_des_dht_key();
  static const int kDesDhtKeyFieldNumber = 2;
  const ::std::string& des_dht_key() const;
  void set_des_dht_key(const ::std::string& value);
  #if LANG_CXX11
  void set_des_dht_key(::std::string&& value);
  #endif
  void set_des_dht_key(const char* value);
  void set_des_dht_key(const void* value, size_t size);
  ::std::string* mutable_des_dht_key();
  ::std::string* release_des_dht_key();
  void set_allocated_des_dht_key(::std::string* des_dht_key);

  // optional uint32 count = 1;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 1;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:tenon.dht.protobuf.RefreshNeighborsRequest)
 private:
  void set_has_count();
  void clear_has_count();
  void set_has_des_dht_key();
  void clear_has_des_dht_key();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > bloomfilter1_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > bloomfilter_;
  ::google::protobuf::internal::ArenaStringPtr des_dht_key_;
  ::google::protobuf::uint32 count_;
  friend struct ::protobuf_dht_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NodeInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tenon.dht.protobuf.NodeInfo) */ {
 public:
  NodeInfo();
  virtual ~NodeInfo();

  NodeInfo(const NodeInfo& from);

  inline NodeInfo& operator=(const NodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeInfo(NodeInfo&& from) noexcept
    : NodeInfo() {
    *this = ::std::move(from);
  }

  inline NodeInfo& operator=(NodeInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeInfo* internal_default_instance() {
    return reinterpret_cast<const NodeInfo*>(
               &_NodeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(NodeInfo* other);
  friend void swap(NodeInfo& a, NodeInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeInfo* New() const final {
    return CreateMaybeMessage<NodeInfo>(NULL);
  }

  NodeInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NodeInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NodeInfo& from);
  void MergeFrom(const NodeInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes public_ip = 1;
  bool has_public_ip() const;
  void clear_public_ip();
  static const int kPublicIpFieldNumber = 1;
  const ::std::string& public_ip() const;
  void set_public_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_public_ip(::std::string&& value);
  #endif
  void set_public_ip(const char* value);
  void set_public_ip(const void* value, size_t size);
  ::std::string* mutable_public_ip();
  ::std::string* release_public_ip();
  void set_allocated_public_ip(::std::string* public_ip);

  // optional bytes local_ip = 3;
  bool has_local_ip() const;
  void clear_local_ip();
  static const int kLocalIpFieldNumber = 3;
  const ::std::string& local_ip() const;
  void set_local_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_local_ip(::std::string&& value);
  #endif
  void set_local_ip(const char* value);
  void set_local_ip(const void* value, size_t size);
  ::std::string* mutable_local_ip();
  ::std::string* release_local_ip();
  void set_allocated_local_ip(::std::string* local_ip);

  // optional bytes public_key = 5;
  bool has_public_key() const;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 5;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_public_key(::std::string&& value);
  #endif
  void set_public_key(const char* value);
  void set_public_key(const void* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // optional bytes dht_key = 7;
  bool has_dht_key() const;
  void clear_dht_key();
  static const int kDhtKeyFieldNumber = 7;
  const ::std::string& dht_key() const;
  void set_dht_key(const ::std::string& value);
  #if LANG_CXX11
  void set_dht_key(::std::string&& value);
  #endif
  void set_dht_key(const char* value);
  void set_dht_key(const void* value, size_t size);
  ::std::string* mutable_dht_key();
  ::std::string* release_dht_key();
  void set_allocated_dht_key(::std::string* dht_key);

  // optional bytes node_tag = 15;
  bool has_node_tag() const;
  void clear_node_tag();
  static const int kNodeTagFieldNumber = 15;
  const ::std::string& node_tag() const;
  void set_node_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_node_tag(::std::string&& value);
  #endif
  void set_node_tag(const char* value);
  void set_node_tag(const void* value, size_t size);
  ::std::string* mutable_node_tag();
  ::std::string* release_node_tag();
  void set_allocated_node_tag(::std::string* node_tag);

  // optional int32 public_port = 2;
  bool has_public_port() const;
  void clear_public_port();
  static const int kPublicPortFieldNumber = 2;
  ::google::protobuf::int32 public_port() const;
  void set_public_port(::google::protobuf::int32 value);

  // optional int32 local_port = 4;
  bool has_local_port() const;
  void clear_local_port();
  static const int kLocalPortFieldNumber = 4;
  ::google::protobuf::int32 local_port() const;
  void set_local_port(::google::protobuf::int32 value);

  // optional int32 nat_type = 6;
  bool has_nat_type() const;
  void clear_nat_type();
  static const int kNatTypeFieldNumber = 6;
  ::google::protobuf::int32 nat_type() const;
  void set_nat_type(::google::protobuf::int32 value);

  // optional uint32 min_svr_port = 8;
  bool has_min_svr_port() const;
  void clear_min_svr_port();
  static const int kMinSvrPortFieldNumber = 8;
  ::google::protobuf::uint32 min_svr_port() const;
  void set_min_svr_port(::google::protobuf::uint32 value);

  // optional uint32 max_svr_port = 9;
  bool has_max_svr_port() const;
  void clear_max_svr_port();
  static const int kMaxSvrPortFieldNumber = 9;
  ::google::protobuf::uint32 max_svr_port() const;
  void set_max_svr_port(::google::protobuf::uint32 value);

  // optional uint32 min_route_port = 10;
  bool has_min_route_port() const;
  void clear_min_route_port();
  static const int kMinRoutePortFieldNumber = 10;
  ::google::protobuf::uint32 min_route_port() const;
  void set_min_route_port(::google::protobuf::uint32 value);

  // optional uint32 max_route_port = 11;
  bool has_max_route_port() const;
  void clear_max_route_port();
  static const int kMaxRoutePortFieldNumber = 11;
  ::google::protobuf::uint32 max_route_port() const;
  void set_max_route_port(::google::protobuf::uint32 value);

  // optional uint32 node_weight = 12;
  bool has_node_weight() const;
  void clear_node_weight();
  static const int kNodeWeightFieldNumber = 12;
  ::google::protobuf::uint32 node_weight() const;
  void set_node_weight(::google::protobuf::uint32 value);

  // optional uint32 min_udp_port = 13;
  bool has_min_udp_port() const;
  void clear_min_udp_port();
  static const int kMinUdpPortFieldNumber = 13;
  ::google::protobuf::uint32 min_udp_port() const;
  void set_min_udp_port(::google::protobuf::uint32 value);

  // optional uint32 max_udp_port = 14;
  bool has_max_udp_port() const;
  void clear_max_udp_port();
  static const int kMaxUdpPortFieldNumber = 14;
  ::google::protobuf::uint32 max_udp_port() const;
  void set_max_udp_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:tenon.dht.protobuf.NodeInfo)
 private:
  void set_has_public_ip();
  void clear_has_public_ip();
  void set_has_public_port();
  void clear_has_public_port();
  void set_has_local_ip();
  void clear_has_local_ip();
  void set_has_local_port();
  void clear_has_local_port();
  void set_has_public_key();
  void clear_has_public_key();
  void set_has_nat_type();
  void clear_has_nat_type();
  void set_has_dht_key();
  void clear_has_dht_key();
  void set_has_min_svr_port();
  void clear_has_min_svr_port();
  void set_has_max_svr_port();
  void clear_has_max_svr_port();
  void set_has_min_route_port();
  void clear_has_min_route_port();
  void set_has_max_route_port();
  void clear_has_max_route_port();
  void set_has_node_weight();
  void clear_has_node_weight();
  void set_has_min_udp_port();
  void clear_has_min_udp_port();
  void set_has_max_udp_port();
  void clear_has_max_udp_port();
  void set_has_node_tag();
  void clear_has_node_tag();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr public_ip_;
  ::google::protobuf::internal::ArenaStringPtr local_ip_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  ::google::protobuf::internal::ArenaStringPtr dht_key_;
  ::google::protobuf::internal::ArenaStringPtr node_tag_;
  ::google::protobuf::int32 public_port_;
  ::google::protobuf::int32 local_port_;
  ::google::protobuf::int32 nat_type_;
  ::google::protobuf::uint32 min_svr_port_;
  ::google::protobuf::uint32 max_svr_port_;
  ::google::protobuf::uint32 min_route_port_;
  ::google::protobuf::uint32 max_route_port_;
  ::google::protobuf::uint32 node_weight_;
  ::google::protobuf::uint32 min_udp_port_;
  ::google::protobuf::uint32 max_udp_port_;
  friend struct ::protobuf_dht_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RefreshNeighborsResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tenon.dht.protobuf.RefreshNeighborsResponse) */ {
 public:
  RefreshNeighborsResponse();
  virtual ~RefreshNeighborsResponse();

  RefreshNeighborsResponse(const RefreshNeighborsResponse& from);

  inline RefreshNeighborsResponse& operator=(const RefreshNeighborsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RefreshNeighborsResponse(RefreshNeighborsResponse&& from) noexcept
    : RefreshNeighborsResponse() {
    *this = ::std::move(from);
  }

  inline RefreshNeighborsResponse& operator=(RefreshNeighborsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RefreshNeighborsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RefreshNeighborsResponse* internal_default_instance() {
    return reinterpret_cast<const RefreshNeighborsResponse*>(
               &_RefreshNeighborsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(RefreshNeighborsResponse* other);
  friend void swap(RefreshNeighborsResponse& a, RefreshNeighborsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RefreshNeighborsResponse* New() const final {
    return CreateMaybeMessage<RefreshNeighborsResponse>(NULL);
  }

  RefreshNeighborsResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RefreshNeighborsResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RefreshNeighborsResponse& from);
  void MergeFrom(const RefreshNeighborsResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefreshNeighborsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tenon.dht.protobuf.NodeInfo nodes = 1;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 1;
  ::tenon::dht::protobuf::NodeInfo* mutable_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::tenon::dht::protobuf::NodeInfo >*
      mutable_nodes();
  const ::tenon::dht::protobuf::NodeInfo& nodes(int index) const;
  ::tenon::dht::protobuf::NodeInfo* add_nodes();
  const ::google::protobuf::RepeatedPtrField< ::tenon::dht::protobuf::NodeInfo >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:tenon.dht.protobuf.RefreshNeighborsResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::tenon::dht::protobuf::NodeInfo > nodes_;
  friend struct ::protobuf_dht_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HeartbeatRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tenon.dht.protobuf.HeartbeatRequest) */ {
 public:
  HeartbeatRequest();
  virtual ~HeartbeatRequest();

  HeartbeatRequest(const HeartbeatRequest& from);

  inline HeartbeatRequest& operator=(const HeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeartbeatRequest(HeartbeatRequest&& from) noexcept
    : HeartbeatRequest() {
    *this = ::std::move(from);
  }

  inline HeartbeatRequest& operator=(HeartbeatRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const HeartbeatRequest*>(
               &_HeartbeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(HeartbeatRequest* other);
  friend void swap(HeartbeatRequest& a, HeartbeatRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeartbeatRequest* New() const final {
    return CreateMaybeMessage<HeartbeatRequest>(NULL);
  }

  HeartbeatRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HeartbeatRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HeartbeatRequest& from);
  void MergeFrom(const HeartbeatRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 dht_key_hash = 1;
  bool has_dht_key_hash() const;
  void clear_dht_key_hash();
  static const int kDhtKeyHashFieldNumber = 1;
  ::google::protobuf::uint64 dht_key_hash() const;
  void set_dht_key_hash(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:tenon.dht.protobuf.HeartbeatRequest)
 private:
  void set_has_dht_key_hash();
  void clear_has_dht_key_hash();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 dht_key_hash_;
  friend struct ::protobuf_dht_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HeartbeatResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tenon.dht.protobuf.HeartbeatResponse) */ {
 public:
  HeartbeatResponse();
  virtual ~HeartbeatResponse();

  HeartbeatResponse(const HeartbeatResponse& from);

  inline HeartbeatResponse& operator=(const HeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeartbeatResponse(HeartbeatResponse&& from) noexcept
    : HeartbeatResponse() {
    *this = ::std::move(from);
  }

  inline HeartbeatResponse& operator=(HeartbeatResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeartbeatResponse* internal_default_instance() {
    return reinterpret_cast<const HeartbeatResponse*>(
               &_HeartbeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(HeartbeatResponse* other);
  friend void swap(HeartbeatResponse& a, HeartbeatResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeartbeatResponse* New() const final {
    return CreateMaybeMessage<HeartbeatResponse>(NULL);
  }

  HeartbeatResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HeartbeatResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HeartbeatResponse& from);
  void MergeFrom(const HeartbeatResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 dht_key_hash = 1;
  bool has_dht_key_hash() const;
  void clear_dht_key_hash();
  static const int kDhtKeyHashFieldNumber = 1;
  ::google::protobuf::uint64 dht_key_hash() const;
  void set_dht_key_hash(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:tenon.dht.protobuf.HeartbeatResponse)
 private:
  void set_has_dht_key_hash();
  void clear_has_dht_key_hash();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 dht_key_hash_;
  friend struct ::protobuf_dht_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConnectReqeust : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tenon.dht.protobuf.ConnectReqeust) */ {
 public:
  ConnectReqeust();
  virtual ~ConnectReqeust();

  ConnectReqeust(const ConnectReqeust& from);

  inline ConnectReqeust& operator=(const ConnectReqeust& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConnectReqeust(ConnectReqeust&& from) noexcept
    : ConnectReqeust() {
    *this = ::std::move(from);
  }

  inline ConnectReqeust& operator=(ConnectReqeust&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectReqeust& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectReqeust* internal_default_instance() {
    return reinterpret_cast<const ConnectReqeust*>(
               &_ConnectReqeust_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ConnectReqeust* other);
  friend void swap(ConnectReqeust& a, ConnectReqeust& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConnectReqeust* New() const final {
    return CreateMaybeMessage<ConnectReqeust>(NULL);
  }

  ConnectReqeust* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConnectReqeust>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConnectReqeust& from);
  void MergeFrom(const ConnectReqeust& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectReqeust* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes local_ip = 1;
  bool has_local_ip() const;
  void clear_local_ip();
  static const int kLocalIpFieldNumber = 1;
  const ::std::string& local_ip() const;
  void set_local_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_local_ip(::std::string&& value);
  #endif
  void set_local_ip(const char* value);
  void set_local_ip(const void* value, size_t size);
  ::std::string* mutable_local_ip();
  ::std::string* release_local_ip();
  void set_allocated_local_ip(::std::string* local_ip);

  // optional bytes public_ip = 3;
  bool has_public_ip() const;
  void clear_public_ip();
  static const int kPublicIpFieldNumber = 3;
  const ::std::string& public_ip() const;
  void set_public_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_public_ip(::std::string&& value);
  #endif
  void set_public_ip(const char* value);
  void set_public_ip(const void* value, size_t size);
  ::std::string* mutable_public_ip();
  ::std::string* release_public_ip();
  void set_allocated_public_ip(::std::string* public_ip);

  // optional bytes id = 6;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 6;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const void* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional bytes dht_key = 7;
  bool has_dht_key() const;
  void clear_dht_key();
  static const int kDhtKeyFieldNumber = 7;
  const ::std::string& dht_key() const;
  void set_dht_key(const ::std::string& value);
  #if LANG_CXX11
  void set_dht_key(::std::string&& value);
  #endif
  void set_dht_key(const char* value);
  void set_dht_key(const void* value, size_t size);
  ::std::string* mutable_dht_key();
  ::std::string* release_dht_key();
  void set_allocated_dht_key(::std::string* dht_key);

  // optional bytes node_tag = 16;
  bool has_node_tag() const;
  void clear_node_tag();
  static const int kNodeTagFieldNumber = 16;
  const ::std::string& node_tag() const;
  void set_node_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_node_tag(::std::string&& value);
  #endif
  void set_node_tag(const char* value);
  void set_node_tag(const void* value, size_t size);
  ::std::string* mutable_node_tag();
  ::std::string* release_node_tag();
  void set_allocated_node_tag(::std::string* node_tag);

  // optional int32 local_port = 2;
  bool has_local_port() const;
  void clear_local_port();
  static const int kLocalPortFieldNumber = 2;
  ::google::protobuf::int32 local_port() const;
  void set_local_port(::google::protobuf::int32 value);

  // optional int32 public_port = 4;
  bool has_public_port() const;
  void clear_public_port();
  static const int kPublicPortFieldNumber = 4;
  ::google::protobuf::int32 public_port() const;
  void set_public_port(::google::protobuf::int32 value);

  // optional int32 nat_type = 5;
  bool has_nat_type() const;
  void clear_nat_type();
  static const int kNatTypeFieldNumber = 5;
  ::google::protobuf::int32 nat_type() const;
  void set_nat_type(::google::protobuf::int32 value);

  // optional bool direct = 8;
  bool has_direct() const;
  void clear_direct();
  static const int kDirectFieldNumber = 8;
  bool direct() const;
  void set_direct(bool value);

  // optional uint32 min_svr_port = 9;
  bool has_min_svr_port() const;
  void clear_min_svr_port();
  static const int kMinSvrPortFieldNumber = 9;
  ::google::protobuf::uint32 min_svr_port() const;
  void set_min_svr_port(::google::protobuf::uint32 value);

  // optional uint32 max_svr_port = 10;
  bool has_max_svr_port() const;
  void clear_max_svr_port();
  static const int kMaxSvrPortFieldNumber = 10;
  ::google::protobuf::uint32 max_svr_port() const;
  void set_max_svr_port(::google::protobuf::uint32 value);

  // optional uint32 min_route_port = 11;
  bool has_min_route_port() const;
  void clear_min_route_port();
  static const int kMinRoutePortFieldNumber = 11;
  ::google::protobuf::uint32 min_route_port() const;
  void set_min_route_port(::google::protobuf::uint32 value);

  // optional uint32 max_route_port = 12;
  bool has_max_route_port() const;
  void clear_max_route_port();
  static const int kMaxRoutePortFieldNumber = 12;
  ::google::protobuf::uint32 max_route_port() const;
  void set_max_route_port(::google::protobuf::uint32 value);

  // optional uint32 node_weight = 13;
  bool has_node_weight() const;
  void clear_node_weight();
  static const int kNodeWeightFieldNumber = 13;
  ::google::protobuf::uint32 node_weight() const;
  void set_node_weight(::google::protobuf::uint32 value);

  // optional uint32 min_udp_port = 14;
  bool has_min_udp_port() const;
  void clear_min_udp_port();
  static const int kMinUdpPortFieldNumber = 14;
  ::google::protobuf::uint32 min_udp_port() const;
  void set_min_udp_port(::google::protobuf::uint32 value);

  // optional uint32 max_udp_port = 15;
  bool has_max_udp_port() const;
  void clear_max_udp_port();
  static const int kMaxUdpPortFieldNumber = 15;
  ::google::protobuf::uint32 max_udp_port() const;
  void set_max_udp_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:tenon.dht.protobuf.ConnectReqeust)
 private:
  void set_has_local_ip();
  void clear_has_local_ip();
  void set_has_local_port();
  void clear_has_local_port();
  void set_has_public_ip();
  void clear_has_public_ip();
  void set_has_public_port();
  void clear_has_public_port();
  void set_has_nat_type();
  void clear_has_nat_type();
  void set_has_id();
  void clear_has_id();
  void set_has_dht_key();
  void clear_has_dht_key();
  void set_has_direct();
  void clear_has_direct();
  void set_has_min_svr_port();
  void clear_has_min_svr_port();
  void set_has_max_svr_port();
  void clear_has_max_svr_port();
  void set_has_min_route_port();
  void clear_has_min_route_port();
  void set_has_max_route_port();
  void clear_has_max_route_port();
  void set_has_node_weight();
  void clear_has_node_weight();
  void set_has_min_udp_port();
  void clear_has_min_udp_port();
  void set_has_max_udp_port();
  void clear_has_max_udp_port();
  void set_has_node_tag();
  void clear_has_node_tag();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr local_ip_;
  ::google::protobuf::internal::ArenaStringPtr public_ip_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr dht_key_;
  ::google::protobuf::internal::ArenaStringPtr node_tag_;
  ::google::protobuf::int32 local_port_;
  ::google::protobuf::int32 public_port_;
  ::google::protobuf::int32 nat_type_;
  bool direct_;
  ::google::protobuf::uint32 min_svr_port_;
  ::google::protobuf::uint32 max_svr_port_;
  ::google::protobuf::uint32 min_route_port_;
  ::google::protobuf::uint32 max_route_port_;
  ::google::protobuf::uint32 node_weight_;
  ::google::protobuf::uint32 min_udp_port_;
  ::google::protobuf::uint32 max_udp_port_;
  friend struct ::protobuf_dht_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DhtMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tenon.dht.protobuf.DhtMessage) */ {
 public:
  DhtMessage();
  virtual ~DhtMessage();

  DhtMessage(const DhtMessage& from);

  inline DhtMessage& operator=(const DhtMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DhtMessage(DhtMessage&& from) noexcept
    : DhtMessage() {
    *this = ::std::move(from);
  }

  inline DhtMessage& operator=(DhtMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DhtMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DhtMessage* internal_default_instance() {
    return reinterpret_cast<const DhtMessage*>(
               &_DhtMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(DhtMessage* other);
  friend void swap(DhtMessage& a, DhtMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DhtMessage* New() const final {
    return CreateMaybeMessage<DhtMessage>(NULL);
  }

  DhtMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DhtMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DhtMessage& from);
  void MergeFrom(const DhtMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DhtMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 networks = 8;
  int networks_size() const;
  void clear_networks();
  static const int kNetworksFieldNumber = 8;
  ::google::protobuf::uint32 networks(int index) const;
  void set_networks(int index, ::google::protobuf::uint32 value);
  void add_networks(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      networks() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_networks();

  // optional bytes enc_data = 9;
  bool has_enc_data() const;
  void clear_enc_data();
  static const int kEncDataFieldNumber = 9;
  const ::std::string& enc_data() const;
  void set_enc_data(const ::std::string& value);
  #if LANG_CXX11
  void set_enc_data(::std::string&& value);
  #endif
  void set_enc_data(const char* value);
  void set_enc_data(const void* value, size_t size);
  ::std::string* mutable_enc_data();
  ::std::string* release_enc_data();
  void set_allocated_enc_data(::std::string* enc_data);

  // optional bytes sign_ch = 10;
  bool has_sign_ch() const;
  void clear_sign_ch();
  static const int kSignChFieldNumber = 10;
  const ::std::string& sign_ch() const;
  void set_sign_ch(const ::std::string& value);
  #if LANG_CXX11
  void set_sign_ch(::std::string&& value);
  #endif
  void set_sign_ch(const char* value);
  void set_sign_ch(const void* value, size_t size);
  ::std::string* mutable_sign_ch();
  ::std::string* release_sign_ch();
  void set_allocated_sign_ch(::std::string* sign_ch);

  // optional bytes sign_re = 11;
  bool has_sign_re() const;
  void clear_sign_re();
  static const int kSignReFieldNumber = 11;
  const ::std::string& sign_re() const;
  void set_sign_re(const ::std::string& value);
  #if LANG_CXX11
  void set_sign_re(::std::string&& value);
  #endif
  void set_sign_re(const char* value);
  void set_sign_re(const void* value, size_t size);
  ::std::string* mutable_sign_re();
  ::std::string* release_sign_re();
  void set_allocated_sign_re(::std::string* sign_re);

  // optional .tenon.dht.protobuf.BootstrapRequest bootstrap_req = 1;
  bool has_bootstrap_req() const;
  void clear_bootstrap_req();
  static const int kBootstrapReqFieldNumber = 1;
  private:
  const ::tenon::dht::protobuf::BootstrapRequest& _internal_bootstrap_req() const;
  public:
  const ::tenon::dht::protobuf::BootstrapRequest& bootstrap_req() const;
  ::tenon::dht::protobuf::BootstrapRequest* release_bootstrap_req();
  ::tenon::dht::protobuf::BootstrapRequest* mutable_bootstrap_req();
  void set_allocated_bootstrap_req(::tenon::dht::protobuf::BootstrapRequest* bootstrap_req);

  // optional .tenon.dht.protobuf.BootstrapResponse bootstrap_res = 2;
  bool has_bootstrap_res() const;
  void clear_bootstrap_res();
  static const int kBootstrapResFieldNumber = 2;
  private:
  const ::tenon::dht::protobuf::BootstrapResponse& _internal_bootstrap_res() const;
  public:
  const ::tenon::dht::protobuf::BootstrapResponse& bootstrap_res() const;
  ::tenon::dht::protobuf::BootstrapResponse* release_bootstrap_res();
  ::tenon::dht::protobuf::BootstrapResponse* mutable_bootstrap_res();
  void set_allocated_bootstrap_res(::tenon::dht::protobuf::BootstrapResponse* bootstrap_res);

  // optional .tenon.dht.protobuf.RefreshNeighborsRequest refresh_neighbors_req = 3;
  bool has_refresh_neighbors_req() const;
  void clear_refresh_neighbors_req();
  static const int kRefreshNeighborsReqFieldNumber = 3;
  private:
  const ::tenon::dht::protobuf::RefreshNeighborsRequest& _internal_refresh_neighbors_req() const;
  public:
  const ::tenon::dht::protobuf::RefreshNeighborsRequest& refresh_neighbors_req() const;
  ::tenon::dht::protobuf::RefreshNeighborsRequest* release_refresh_neighbors_req();
  ::tenon::dht::protobuf::RefreshNeighborsRequest* mutable_refresh_neighbors_req();
  void set_allocated_refresh_neighbors_req(::tenon::dht::protobuf::RefreshNeighborsRequest* refresh_neighbors_req);

  // optional .tenon.dht.protobuf.RefreshNeighborsResponse refresh_neighbors_res = 4;
  bool has_refresh_neighbors_res() const;
  void clear_refresh_neighbors_res();
  static const int kRefreshNeighborsResFieldNumber = 4;
  private:
  const ::tenon::dht::protobuf::RefreshNeighborsResponse& _internal_refresh_neighbors_res() const;
  public:
  const ::tenon::dht::protobuf::RefreshNeighborsResponse& refresh_neighbors_res() const;
  ::tenon::dht::protobuf::RefreshNeighborsResponse* release_refresh_neighbors_res();
  ::tenon::dht::protobuf::RefreshNeighborsResponse* mutable_refresh_neighbors_res();
  void set_allocated_refresh_neighbors_res(::tenon::dht::protobuf::RefreshNeighborsResponse* refresh_neighbors_res);

  // optional .tenon.dht.protobuf.ConnectReqeust connect_req = 5;
  bool has_connect_req() const;
  void clear_connect_req();
  static const int kConnectReqFieldNumber = 5;
  private:
  const ::tenon::dht::protobuf::ConnectReqeust& _internal_connect_req() const;
  public:
  const ::tenon::dht::protobuf::ConnectReqeust& connect_req() const;
  ::tenon::dht::protobuf::ConnectReqeust* release_connect_req();
  ::tenon::dht::protobuf::ConnectReqeust* mutable_connect_req();
  void set_allocated_connect_req(::tenon::dht::protobuf::ConnectReqeust* connect_req);

  // optional .tenon.dht.protobuf.HeartbeatRequest heartbeat_req = 6;
  bool has_heartbeat_req() const;
  void clear_heartbeat_req();
  static const int kHeartbeatReqFieldNumber = 6;
  private:
  const ::tenon::dht::protobuf::HeartbeatRequest& _internal_heartbeat_req() const;
  public:
  const ::tenon::dht::protobuf::HeartbeatRequest& heartbeat_req() const;
  ::tenon::dht::protobuf::HeartbeatRequest* release_heartbeat_req();
  ::tenon::dht::protobuf::HeartbeatRequest* mutable_heartbeat_req();
  void set_allocated_heartbeat_req(::tenon::dht::protobuf::HeartbeatRequest* heartbeat_req);

  // optional .tenon.dht.protobuf.HeartbeatResponse heartbeat_res = 7;
  bool has_heartbeat_res() const;
  void clear_heartbeat_res();
  static const int kHeartbeatResFieldNumber = 7;
  private:
  const ::tenon::dht::protobuf::HeartbeatResponse& _internal_heartbeat_res() const;
  public:
  const ::tenon::dht::protobuf::HeartbeatResponse& heartbeat_res() const;
  ::tenon::dht::protobuf::HeartbeatResponse* release_heartbeat_res();
  ::tenon::dht::protobuf::HeartbeatResponse* mutable_heartbeat_res();
  void set_allocated_heartbeat_res(::tenon::dht::protobuf::HeartbeatResponse* heartbeat_res);

  // @@protoc_insertion_point(class_scope:tenon.dht.protobuf.DhtMessage)
 private:
  void set_has_bootstrap_req();
  void clear_has_bootstrap_req();
  void set_has_bootstrap_res();
  void clear_has_bootstrap_res();
  void set_has_refresh_neighbors_req();
  void clear_has_refresh_neighbors_req();
  void set_has_refresh_neighbors_res();
  void clear_has_refresh_neighbors_res();
  void set_has_connect_req();
  void clear_has_connect_req();
  void set_has_heartbeat_req();
  void clear_has_heartbeat_req();
  void set_has_heartbeat_res();
  void clear_has_heartbeat_res();
  void set_has_enc_data();
  void clear_has_enc_data();
  void set_has_sign_ch();
  void clear_has_sign_ch();
  void set_has_sign_re();
  void clear_has_sign_re();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > networks_;
  ::google::protobuf::internal::ArenaStringPtr enc_data_;
  ::google::protobuf::internal::ArenaStringPtr sign_ch_;
  ::google::protobuf::internal::ArenaStringPtr sign_re_;
  ::tenon::dht::protobuf::BootstrapRequest* bootstrap_req_;
  ::tenon::dht::protobuf::BootstrapResponse* bootstrap_res_;
  ::tenon::dht::protobuf::RefreshNeighborsRequest* refresh_neighbors_req_;
  ::tenon::dht::protobuf::RefreshNeighborsResponse* refresh_neighbors_res_;
  ::tenon::dht::protobuf::ConnectReqeust* connect_req_;
  ::tenon::dht::protobuf::HeartbeatRequest* heartbeat_req_;
  ::tenon::dht::protobuf::HeartbeatResponse* heartbeat_res_;
  friend struct ::protobuf_dht_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BootstrapRequest

// optional string local_ip = 1;
inline bool BootstrapRequest::has_local_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BootstrapRequest::set_has_local_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BootstrapRequest::clear_has_local_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BootstrapRequest::clear_local_ip() {
  local_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_local_ip();
}
inline const ::std::string& BootstrapRequest::local_ip() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapRequest.local_ip)
  return local_ip_.GetNoArena();
}
inline void BootstrapRequest::set_local_ip(const ::std::string& value) {
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.BootstrapRequest.local_ip)
}
#if LANG_CXX11
inline void BootstrapRequest::set_local_ip(::std::string&& value) {
  set_has_local_ip();
  local_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.BootstrapRequest.local_ip)
}
#endif
inline void BootstrapRequest::set_local_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.BootstrapRequest.local_ip)
}
inline void BootstrapRequest::set_local_ip(const char* value, size_t size) {
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.BootstrapRequest.local_ip)
}
inline ::std::string* BootstrapRequest::mutable_local_ip() {
  set_has_local_ip();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.BootstrapRequest.local_ip)
  return local_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BootstrapRequest::release_local_ip() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.BootstrapRequest.local_ip)
  if (!has_local_ip()) {
    return NULL;
  }
  clear_has_local_ip();
  return local_ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BootstrapRequest::set_allocated_local_ip(::std::string* local_ip) {
  if (local_ip != NULL) {
    set_has_local_ip();
  } else {
    clear_has_local_ip();
  }
  local_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_ip);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.BootstrapRequest.local_ip)
}

// optional int32 local_port = 2;
inline bool BootstrapRequest::has_local_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BootstrapRequest::set_has_local_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BootstrapRequest::clear_has_local_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BootstrapRequest::clear_local_port() {
  local_port_ = 0;
  clear_has_local_port();
}
inline ::google::protobuf::int32 BootstrapRequest::local_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapRequest.local_port)
  return local_port_;
}
inline void BootstrapRequest::set_local_port(::google::protobuf::int32 value) {
  set_has_local_port();
  local_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.BootstrapRequest.local_port)
}

// optional int32 nat_type = 3;
inline bool BootstrapRequest::has_nat_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BootstrapRequest::set_has_nat_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BootstrapRequest::clear_has_nat_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BootstrapRequest::clear_nat_type() {
  nat_type_ = 0;
  clear_has_nat_type();
}
inline ::google::protobuf::int32 BootstrapRequest::nat_type() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapRequest.nat_type)
  return nat_type_;
}
inline void BootstrapRequest::set_nat_type(::google::protobuf::int32 value) {
  set_has_nat_type();
  nat_type_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.BootstrapRequest.nat_type)
}

// optional bytes node_id = 4;
inline bool BootstrapRequest::has_node_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BootstrapRequest::set_has_node_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BootstrapRequest::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BootstrapRequest::clear_node_id() {
  node_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_node_id();
}
inline const ::std::string& BootstrapRequest::node_id() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapRequest.node_id)
  return node_id_.GetNoArena();
}
inline void BootstrapRequest::set_node_id(const ::std::string& value) {
  set_has_node_id();
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.BootstrapRequest.node_id)
}
#if LANG_CXX11
inline void BootstrapRequest::set_node_id(::std::string&& value) {
  set_has_node_id();
  node_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.BootstrapRequest.node_id)
}
#endif
inline void BootstrapRequest::set_node_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_node_id();
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.BootstrapRequest.node_id)
}
inline void BootstrapRequest::set_node_id(const void* value, size_t size) {
  set_has_node_id();
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.BootstrapRequest.node_id)
}
inline ::std::string* BootstrapRequest::mutable_node_id() {
  set_has_node_id();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.BootstrapRequest.node_id)
  return node_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BootstrapRequest::release_node_id() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.BootstrapRequest.node_id)
  if (!has_node_id()) {
    return NULL;
  }
  clear_has_node_id();
  return node_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BootstrapRequest::set_allocated_node_id(::std::string* node_id) {
  if (node_id != NULL) {
    set_has_node_id();
  } else {
    clear_has_node_id();
  }
  node_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node_id);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.BootstrapRequest.node_id)
}

// optional int32 get_init_msg = 5;
inline bool BootstrapRequest::has_get_init_msg() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BootstrapRequest::set_has_get_init_msg() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BootstrapRequest::clear_has_get_init_msg() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BootstrapRequest::clear_get_init_msg() {
  get_init_msg_ = 0;
  clear_has_get_init_msg();
}
inline ::google::protobuf::int32 BootstrapRequest::get_init_msg() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapRequest.get_init_msg)
  return get_init_msg_;
}
inline void BootstrapRequest::set_get_init_msg(::google::protobuf::int32 value) {
  set_has_get_init_msg();
  get_init_msg_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.BootstrapRequest.get_init_msg)
}

// optional uint32 min_svr_port = 6;
inline bool BootstrapRequest::has_min_svr_port() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BootstrapRequest::set_has_min_svr_port() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BootstrapRequest::clear_has_min_svr_port() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BootstrapRequest::clear_min_svr_port() {
  min_svr_port_ = 0u;
  clear_has_min_svr_port();
}
inline ::google::protobuf::uint32 BootstrapRequest::min_svr_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapRequest.min_svr_port)
  return min_svr_port_;
}
inline void BootstrapRequest::set_min_svr_port(::google::protobuf::uint32 value) {
  set_has_min_svr_port();
  min_svr_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.BootstrapRequest.min_svr_port)
}

// optional uint32 max_svr_port = 7;
inline bool BootstrapRequest::has_max_svr_port() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BootstrapRequest::set_has_max_svr_port() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BootstrapRequest::clear_has_max_svr_port() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BootstrapRequest::clear_max_svr_port() {
  max_svr_port_ = 0u;
  clear_has_max_svr_port();
}
inline ::google::protobuf::uint32 BootstrapRequest::max_svr_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapRequest.max_svr_port)
  return max_svr_port_;
}
inline void BootstrapRequest::set_max_svr_port(::google::protobuf::uint32 value) {
  set_has_max_svr_port();
  max_svr_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.BootstrapRequest.max_svr_port)
}

// optional uint32 min_route_port = 8;
inline bool BootstrapRequest::has_min_route_port() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BootstrapRequest::set_has_min_route_port() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BootstrapRequest::clear_has_min_route_port() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BootstrapRequest::clear_min_route_port() {
  min_route_port_ = 0u;
  clear_has_min_route_port();
}
inline ::google::protobuf::uint32 BootstrapRequest::min_route_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapRequest.min_route_port)
  return min_route_port_;
}
inline void BootstrapRequest::set_min_route_port(::google::protobuf::uint32 value) {
  set_has_min_route_port();
  min_route_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.BootstrapRequest.min_route_port)
}

// optional uint32 max_route_port = 9;
inline bool BootstrapRequest::has_max_route_port() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BootstrapRequest::set_has_max_route_port() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BootstrapRequest::clear_has_max_route_port() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BootstrapRequest::clear_max_route_port() {
  max_route_port_ = 0u;
  clear_has_max_route_port();
}
inline ::google::protobuf::uint32 BootstrapRequest::max_route_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapRequest.max_route_port)
  return max_route_port_;
}
inline void BootstrapRequest::set_max_route_port(::google::protobuf::uint32 value) {
  set_has_max_route_port();
  max_route_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.BootstrapRequest.max_route_port)
}

// optional int32 public_port = 10;
inline bool BootstrapRequest::has_public_port() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BootstrapRequest::set_has_public_port() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BootstrapRequest::clear_has_public_port() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BootstrapRequest::clear_public_port() {
  public_port_ = 0;
  clear_has_public_port();
}
inline ::google::protobuf::int32 BootstrapRequest::public_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapRequest.public_port)
  return public_port_;
}
inline void BootstrapRequest::set_public_port(::google::protobuf::int32 value) {
  set_has_public_port();
  public_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.BootstrapRequest.public_port)
}

// optional uint32 node_weight = 11;
inline bool BootstrapRequest::has_node_weight() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BootstrapRequest::set_has_node_weight() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BootstrapRequest::clear_has_node_weight() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BootstrapRequest::clear_node_weight() {
  node_weight_ = 0u;
  clear_has_node_weight();
}
inline ::google::protobuf::uint32 BootstrapRequest::node_weight() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapRequest.node_weight)
  return node_weight_;
}
inline void BootstrapRequest::set_node_weight(::google::protobuf::uint32 value) {
  set_has_node_weight();
  node_weight_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.BootstrapRequest.node_weight)
}

// optional uint32 min_udp_port = 12;
inline bool BootstrapRequest::has_min_udp_port() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BootstrapRequest::set_has_min_udp_port() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BootstrapRequest::clear_has_min_udp_port() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BootstrapRequest::clear_min_udp_port() {
  min_udp_port_ = 0u;
  clear_has_min_udp_port();
}
inline ::google::protobuf::uint32 BootstrapRequest::min_udp_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapRequest.min_udp_port)
  return min_udp_port_;
}
inline void BootstrapRequest::set_min_udp_port(::google::protobuf::uint32 value) {
  set_has_min_udp_port();
  min_udp_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.BootstrapRequest.min_udp_port)
}

// optional uint32 max_udp_port = 13;
inline bool BootstrapRequest::has_max_udp_port() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void BootstrapRequest::set_has_max_udp_port() {
  _has_bits_[0] |= 0x00004000u;
}
inline void BootstrapRequest::clear_has_max_udp_port() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void BootstrapRequest::clear_max_udp_port() {
  max_udp_port_ = 0u;
  clear_has_max_udp_port();
}
inline ::google::protobuf::uint32 BootstrapRequest::max_udp_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapRequest.max_udp_port)
  return max_udp_port_;
}
inline void BootstrapRequest::set_max_udp_port(::google::protobuf::uint32 value) {
  set_has_max_udp_port();
  max_udp_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.BootstrapRequest.max_udp_port)
}

// optional uint32 version = 14;
inline bool BootstrapRequest::has_version() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void BootstrapRequest::set_has_version() {
  _has_bits_[0] |= 0x00008000u;
}
inline void BootstrapRequest::clear_has_version() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void BootstrapRequest::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 BootstrapRequest::version() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapRequest.version)
  return version_;
}
inline void BootstrapRequest::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.BootstrapRequest.version)
}

// optional bytes uid = 15;
inline bool BootstrapRequest::has_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BootstrapRequest::set_has_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BootstrapRequest::clear_has_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BootstrapRequest::clear_uid() {
  uid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_uid();
}
inline const ::std::string& BootstrapRequest::uid() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapRequest.uid)
  return uid_.GetNoArena();
}
inline void BootstrapRequest::set_uid(const ::std::string& value) {
  set_has_uid();
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.BootstrapRequest.uid)
}
#if LANG_CXX11
inline void BootstrapRequest::set_uid(::std::string&& value) {
  set_has_uid();
  uid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.BootstrapRequest.uid)
}
#endif
inline void BootstrapRequest::set_uid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_uid();
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.BootstrapRequest.uid)
}
inline void BootstrapRequest::set_uid(const void* value, size_t size) {
  set_has_uid();
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.BootstrapRequest.uid)
}
inline ::std::string* BootstrapRequest::mutable_uid() {
  set_has_uid();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.BootstrapRequest.uid)
  return uid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BootstrapRequest::release_uid() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.BootstrapRequest.uid)
  if (!has_uid()) {
    return NULL;
  }
  clear_has_uid();
  return uid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BootstrapRequest::set_allocated_uid(::std::string* uid) {
  if (uid != NULL) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  uid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uid);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.BootstrapRequest.uid)
}

// optional bytes node_tag = 16;
inline bool BootstrapRequest::has_node_tag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BootstrapRequest::set_has_node_tag() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BootstrapRequest::clear_has_node_tag() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BootstrapRequest::clear_node_tag() {
  node_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_node_tag();
}
inline const ::std::string& BootstrapRequest::node_tag() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapRequest.node_tag)
  return node_tag_.GetNoArena();
}
inline void BootstrapRequest::set_node_tag(const ::std::string& value) {
  set_has_node_tag();
  node_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.BootstrapRequest.node_tag)
}
#if LANG_CXX11
inline void BootstrapRequest::set_node_tag(::std::string&& value) {
  set_has_node_tag();
  node_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.BootstrapRequest.node_tag)
}
#endif
inline void BootstrapRequest::set_node_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_node_tag();
  node_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.BootstrapRequest.node_tag)
}
inline void BootstrapRequest::set_node_tag(const void* value, size_t size) {
  set_has_node_tag();
  node_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.BootstrapRequest.node_tag)
}
inline ::std::string* BootstrapRequest::mutable_node_tag() {
  set_has_node_tag();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.BootstrapRequest.node_tag)
  return node_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BootstrapRequest::release_node_tag() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.BootstrapRequest.node_tag)
  if (!has_node_tag()) {
    return NULL;
  }
  clear_has_node_tag();
  return node_tag_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BootstrapRequest::set_allocated_node_tag(::std::string* node_tag) {
  if (node_tag != NULL) {
    set_has_node_tag();
  } else {
    clear_has_node_tag();
  }
  node_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node_tag);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.BootstrapRequest.node_tag)
}

// -------------------------------------------------------------------

// RelayVpnNodeInfo

// optional bytes ip = 1;
inline bool RelayVpnNodeInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RelayVpnNodeInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RelayVpnNodeInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RelayVpnNodeInfo::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
inline const ::std::string& RelayVpnNodeInfo::ip() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.RelayVpnNodeInfo.ip)
  return ip_.GetNoArena();
}
inline void RelayVpnNodeInfo::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.RelayVpnNodeInfo.ip)
}
#if LANG_CXX11
inline void RelayVpnNodeInfo::set_ip(::std::string&& value) {
  set_has_ip();
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.RelayVpnNodeInfo.ip)
}
#endif
inline void RelayVpnNodeInfo::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.RelayVpnNodeInfo.ip)
}
inline void RelayVpnNodeInfo::set_ip(const void* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.RelayVpnNodeInfo.ip)
}
inline ::std::string* RelayVpnNodeInfo::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.RelayVpnNodeInfo.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RelayVpnNodeInfo::release_ip() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.RelayVpnNodeInfo.ip)
  if (!has_ip()) {
    return NULL;
  }
  clear_has_ip();
  return ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RelayVpnNodeInfo::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.RelayVpnNodeInfo.ip)
}

// optional bytes dhkey = 2;
inline bool RelayVpnNodeInfo::has_dhkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RelayVpnNodeInfo::set_has_dhkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RelayVpnNodeInfo::clear_has_dhkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RelayVpnNodeInfo::clear_dhkey() {
  dhkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dhkey();
}
inline const ::std::string& RelayVpnNodeInfo::dhkey() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.RelayVpnNodeInfo.dhkey)
  return dhkey_.GetNoArena();
}
inline void RelayVpnNodeInfo::set_dhkey(const ::std::string& value) {
  set_has_dhkey();
  dhkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.RelayVpnNodeInfo.dhkey)
}
#if LANG_CXX11
inline void RelayVpnNodeInfo::set_dhkey(::std::string&& value) {
  set_has_dhkey();
  dhkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.RelayVpnNodeInfo.dhkey)
}
#endif
inline void RelayVpnNodeInfo::set_dhkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dhkey();
  dhkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.RelayVpnNodeInfo.dhkey)
}
inline void RelayVpnNodeInfo::set_dhkey(const void* value, size_t size) {
  set_has_dhkey();
  dhkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.RelayVpnNodeInfo.dhkey)
}
inline ::std::string* RelayVpnNodeInfo::mutable_dhkey() {
  set_has_dhkey();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.RelayVpnNodeInfo.dhkey)
  return dhkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RelayVpnNodeInfo::release_dhkey() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.RelayVpnNodeInfo.dhkey)
  if (!has_dhkey()) {
    return NULL;
  }
  clear_has_dhkey();
  return dhkey_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RelayVpnNodeInfo::set_allocated_dhkey(::std::string* dhkey) {
  if (dhkey != NULL) {
    set_has_dhkey();
  } else {
    clear_has_dhkey();
  }
  dhkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dhkey);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.RelayVpnNodeInfo.dhkey)
}

// optional bytes pubkey = 3;
inline bool RelayVpnNodeInfo::has_pubkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RelayVpnNodeInfo::set_has_pubkey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RelayVpnNodeInfo::clear_has_pubkey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RelayVpnNodeInfo::clear_pubkey() {
  pubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pubkey();
}
inline const ::std::string& RelayVpnNodeInfo::pubkey() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.RelayVpnNodeInfo.pubkey)
  return pubkey_.GetNoArena();
}
inline void RelayVpnNodeInfo::set_pubkey(const ::std::string& value) {
  set_has_pubkey();
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.RelayVpnNodeInfo.pubkey)
}
#if LANG_CXX11
inline void RelayVpnNodeInfo::set_pubkey(::std::string&& value) {
  set_has_pubkey();
  pubkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.RelayVpnNodeInfo.pubkey)
}
#endif
inline void RelayVpnNodeInfo::set_pubkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pubkey();
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.RelayVpnNodeInfo.pubkey)
}
inline void RelayVpnNodeInfo::set_pubkey(const void* value, size_t size) {
  set_has_pubkey();
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.RelayVpnNodeInfo.pubkey)
}
inline ::std::string* RelayVpnNodeInfo::mutable_pubkey() {
  set_has_pubkey();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.RelayVpnNodeInfo.pubkey)
  return pubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RelayVpnNodeInfo::release_pubkey() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.RelayVpnNodeInfo.pubkey)
  if (!has_pubkey()) {
    return NULL;
  }
  clear_has_pubkey();
  return pubkey_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RelayVpnNodeInfo::set_allocated_pubkey(::std::string* pubkey) {
  if (pubkey != NULL) {
    set_has_pubkey();
  } else {
    clear_has_pubkey();
  }
  pubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pubkey);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.RelayVpnNodeInfo.pubkey)
}

// optional bytes country = 4;
inline bool RelayVpnNodeInfo::has_country() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RelayVpnNodeInfo::set_has_country() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RelayVpnNodeInfo::clear_has_country() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RelayVpnNodeInfo::clear_country() {
  country_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_country();
}
inline const ::std::string& RelayVpnNodeInfo::country() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.RelayVpnNodeInfo.country)
  return country_.GetNoArena();
}
inline void RelayVpnNodeInfo::set_country(const ::std::string& value) {
  set_has_country();
  country_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.RelayVpnNodeInfo.country)
}
#if LANG_CXX11
inline void RelayVpnNodeInfo::set_country(::std::string&& value) {
  set_has_country();
  country_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.RelayVpnNodeInfo.country)
}
#endif
inline void RelayVpnNodeInfo::set_country(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_country();
  country_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.RelayVpnNodeInfo.country)
}
inline void RelayVpnNodeInfo::set_country(const void* value, size_t size) {
  set_has_country();
  country_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.RelayVpnNodeInfo.country)
}
inline ::std::string* RelayVpnNodeInfo::mutable_country() {
  set_has_country();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.RelayVpnNodeInfo.country)
  return country_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RelayVpnNodeInfo::release_country() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.RelayVpnNodeInfo.country)
  if (!has_country()) {
    return NULL;
  }
  clear_has_country();
  return country_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RelayVpnNodeInfo::set_allocated_country(::std::string* country) {
  if (country != NULL) {
    set_has_country();
  } else {
    clear_has_country();
  }
  country_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), country);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.RelayVpnNodeInfo.country)
}

// optional uint32 min_svr_port = 5;
inline bool RelayVpnNodeInfo::has_min_svr_port() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RelayVpnNodeInfo::set_has_min_svr_port() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RelayVpnNodeInfo::clear_has_min_svr_port() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RelayVpnNodeInfo::clear_min_svr_port() {
  min_svr_port_ = 0u;
  clear_has_min_svr_port();
}
inline ::google::protobuf::uint32 RelayVpnNodeInfo::min_svr_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.RelayVpnNodeInfo.min_svr_port)
  return min_svr_port_;
}
inline void RelayVpnNodeInfo::set_min_svr_port(::google::protobuf::uint32 value) {
  set_has_min_svr_port();
  min_svr_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.RelayVpnNodeInfo.min_svr_port)
}

// optional uint32 max_svr_port = 6;
inline bool RelayVpnNodeInfo::has_max_svr_port() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RelayVpnNodeInfo::set_has_max_svr_port() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RelayVpnNodeInfo::clear_has_max_svr_port() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RelayVpnNodeInfo::clear_max_svr_port() {
  max_svr_port_ = 0u;
  clear_has_max_svr_port();
}
inline ::google::protobuf::uint32 RelayVpnNodeInfo::max_svr_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.RelayVpnNodeInfo.max_svr_port)
  return max_svr_port_;
}
inline void RelayVpnNodeInfo::set_max_svr_port(::google::protobuf::uint32 value) {
  set_has_max_svr_port();
  max_svr_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.RelayVpnNodeInfo.max_svr_port)
}

// optional uint32 min_route_port = 7;
inline bool RelayVpnNodeInfo::has_min_route_port() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RelayVpnNodeInfo::set_has_min_route_port() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RelayVpnNodeInfo::clear_has_min_route_port() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RelayVpnNodeInfo::clear_min_route_port() {
  min_route_port_ = 0u;
  clear_has_min_route_port();
}
inline ::google::protobuf::uint32 RelayVpnNodeInfo::min_route_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.RelayVpnNodeInfo.min_route_port)
  return min_route_port_;
}
inline void RelayVpnNodeInfo::set_min_route_port(::google::protobuf::uint32 value) {
  set_has_min_route_port();
  min_route_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.RelayVpnNodeInfo.min_route_port)
}

// optional uint32 max_route_port = 8;
inline bool RelayVpnNodeInfo::has_max_route_port() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RelayVpnNodeInfo::set_has_max_route_port() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RelayVpnNodeInfo::clear_has_max_route_port() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RelayVpnNodeInfo::clear_max_route_port() {
  max_route_port_ = 0u;
  clear_has_max_route_port();
}
inline ::google::protobuf::uint32 RelayVpnNodeInfo::max_route_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.RelayVpnNodeInfo.max_route_port)
  return max_route_port_;
}
inline void RelayVpnNodeInfo::set_max_route_port(::google::protobuf::uint32 value) {
  set_has_max_route_port();
  max_route_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.RelayVpnNodeInfo.max_route_port)
}

// optional uint32 node_weight = 9;
inline bool RelayVpnNodeInfo::has_node_weight() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RelayVpnNodeInfo::set_has_node_weight() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RelayVpnNodeInfo::clear_has_node_weight() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RelayVpnNodeInfo::clear_node_weight() {
  node_weight_ = 0u;
  clear_has_node_weight();
}
inline ::google::protobuf::uint32 RelayVpnNodeInfo::node_weight() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.RelayVpnNodeInfo.node_weight)
  return node_weight_;
}
inline void RelayVpnNodeInfo::set_node_weight(::google::protobuf::uint32 value) {
  set_has_node_weight();
  node_weight_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.RelayVpnNodeInfo.node_weight)
}

// optional uint32 min_udp_port = 10;
inline bool RelayVpnNodeInfo::has_min_udp_port() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RelayVpnNodeInfo::set_has_min_udp_port() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RelayVpnNodeInfo::clear_has_min_udp_port() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RelayVpnNodeInfo::clear_min_udp_port() {
  min_udp_port_ = 0u;
  clear_has_min_udp_port();
}
inline ::google::protobuf::uint32 RelayVpnNodeInfo::min_udp_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.RelayVpnNodeInfo.min_udp_port)
  return min_udp_port_;
}
inline void RelayVpnNodeInfo::set_min_udp_port(::google::protobuf::uint32 value) {
  set_has_min_udp_port();
  min_udp_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.RelayVpnNodeInfo.min_udp_port)
}

// optional uint32 max_udp_port = 11;
inline bool RelayVpnNodeInfo::has_max_udp_port() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RelayVpnNodeInfo::set_has_max_udp_port() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RelayVpnNodeInfo::clear_has_max_udp_port() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RelayVpnNodeInfo::clear_max_udp_port() {
  max_udp_port_ = 0u;
  clear_has_max_udp_port();
}
inline ::google::protobuf::uint32 RelayVpnNodeInfo::max_udp_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.RelayVpnNodeInfo.max_udp_port)
  return max_udp_port_;
}
inline void RelayVpnNodeInfo::set_max_udp_port(::google::protobuf::uint32 value) {
  set_has_max_udp_port();
  max_udp_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.RelayVpnNodeInfo.max_udp_port)
}

// optional bytes node_tag = 12;
inline bool RelayVpnNodeInfo::has_node_tag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RelayVpnNodeInfo::set_has_node_tag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RelayVpnNodeInfo::clear_has_node_tag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RelayVpnNodeInfo::clear_node_tag() {
  node_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_node_tag();
}
inline const ::std::string& RelayVpnNodeInfo::node_tag() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.RelayVpnNodeInfo.node_tag)
  return node_tag_.GetNoArena();
}
inline void RelayVpnNodeInfo::set_node_tag(const ::std::string& value) {
  set_has_node_tag();
  node_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.RelayVpnNodeInfo.node_tag)
}
#if LANG_CXX11
inline void RelayVpnNodeInfo::set_node_tag(::std::string&& value) {
  set_has_node_tag();
  node_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.RelayVpnNodeInfo.node_tag)
}
#endif
inline void RelayVpnNodeInfo::set_node_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_node_tag();
  node_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.RelayVpnNodeInfo.node_tag)
}
inline void RelayVpnNodeInfo::set_node_tag(const void* value, size_t size) {
  set_has_node_tag();
  node_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.RelayVpnNodeInfo.node_tag)
}
inline ::std::string* RelayVpnNodeInfo::mutable_node_tag() {
  set_has_node_tag();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.RelayVpnNodeInfo.node_tag)
  return node_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RelayVpnNodeInfo::release_node_tag() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.RelayVpnNodeInfo.node_tag)
  if (!has_node_tag()) {
    return NULL;
  }
  clear_has_node_tag();
  return node_tag_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RelayVpnNodeInfo::set_allocated_node_tag(::std::string* node_tag) {
  if (node_tag != NULL) {
    set_has_node_tag();
  } else {
    clear_has_node_tag();
  }
  node_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node_tag);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.RelayVpnNodeInfo.node_tag)
}

// -------------------------------------------------------------------

// VpnNodeInfo

// optional bytes ip = 1;
inline bool VpnNodeInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VpnNodeInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VpnNodeInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VpnNodeInfo::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
inline const ::std::string& VpnNodeInfo::ip() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.VpnNodeInfo.ip)
  return ip_.GetNoArena();
}
inline void VpnNodeInfo::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.VpnNodeInfo.ip)
}
#if LANG_CXX11
inline void VpnNodeInfo::set_ip(::std::string&& value) {
  set_has_ip();
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.VpnNodeInfo.ip)
}
#endif
inline void VpnNodeInfo::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.VpnNodeInfo.ip)
}
inline void VpnNodeInfo::set_ip(const void* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.VpnNodeInfo.ip)
}
inline ::std::string* VpnNodeInfo::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.VpnNodeInfo.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VpnNodeInfo::release_ip() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.VpnNodeInfo.ip)
  if (!has_ip()) {
    return NULL;
  }
  clear_has_ip();
  return ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VpnNodeInfo::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.VpnNodeInfo.ip)
}

// optional bytes dhkey = 2;
inline bool VpnNodeInfo::has_dhkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VpnNodeInfo::set_has_dhkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VpnNodeInfo::clear_has_dhkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VpnNodeInfo::clear_dhkey() {
  dhkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dhkey();
}
inline const ::std::string& VpnNodeInfo::dhkey() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.VpnNodeInfo.dhkey)
  return dhkey_.GetNoArena();
}
inline void VpnNodeInfo::set_dhkey(const ::std::string& value) {
  set_has_dhkey();
  dhkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.VpnNodeInfo.dhkey)
}
#if LANG_CXX11
inline void VpnNodeInfo::set_dhkey(::std::string&& value) {
  set_has_dhkey();
  dhkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.VpnNodeInfo.dhkey)
}
#endif
inline void VpnNodeInfo::set_dhkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dhkey();
  dhkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.VpnNodeInfo.dhkey)
}
inline void VpnNodeInfo::set_dhkey(const void* value, size_t size) {
  set_has_dhkey();
  dhkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.VpnNodeInfo.dhkey)
}
inline ::std::string* VpnNodeInfo::mutable_dhkey() {
  set_has_dhkey();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.VpnNodeInfo.dhkey)
  return dhkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VpnNodeInfo::release_dhkey() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.VpnNodeInfo.dhkey)
  if (!has_dhkey()) {
    return NULL;
  }
  clear_has_dhkey();
  return dhkey_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VpnNodeInfo::set_allocated_dhkey(::std::string* dhkey) {
  if (dhkey != NULL) {
    set_has_dhkey();
  } else {
    clear_has_dhkey();
  }
  dhkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dhkey);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.VpnNodeInfo.dhkey)
}

// optional bytes pubkey = 3;
inline bool VpnNodeInfo::has_pubkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VpnNodeInfo::set_has_pubkey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VpnNodeInfo::clear_has_pubkey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VpnNodeInfo::clear_pubkey() {
  pubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pubkey();
}
inline const ::std::string& VpnNodeInfo::pubkey() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.VpnNodeInfo.pubkey)
  return pubkey_.GetNoArena();
}
inline void VpnNodeInfo::set_pubkey(const ::std::string& value) {
  set_has_pubkey();
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.VpnNodeInfo.pubkey)
}
#if LANG_CXX11
inline void VpnNodeInfo::set_pubkey(::std::string&& value) {
  set_has_pubkey();
  pubkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.VpnNodeInfo.pubkey)
}
#endif
inline void VpnNodeInfo::set_pubkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pubkey();
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.VpnNodeInfo.pubkey)
}
inline void VpnNodeInfo::set_pubkey(const void* value, size_t size) {
  set_has_pubkey();
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.VpnNodeInfo.pubkey)
}
inline ::std::string* VpnNodeInfo::mutable_pubkey() {
  set_has_pubkey();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.VpnNodeInfo.pubkey)
  return pubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VpnNodeInfo::release_pubkey() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.VpnNodeInfo.pubkey)
  if (!has_pubkey()) {
    return NULL;
  }
  clear_has_pubkey();
  return pubkey_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VpnNodeInfo::set_allocated_pubkey(::std::string* pubkey) {
  if (pubkey != NULL) {
    set_has_pubkey();
  } else {
    clear_has_pubkey();
  }
  pubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pubkey);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.VpnNodeInfo.pubkey)
}

// optional bytes country = 4;
inline bool VpnNodeInfo::has_country() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VpnNodeInfo::set_has_country() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VpnNodeInfo::clear_has_country() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VpnNodeInfo::clear_country() {
  country_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_country();
}
inline const ::std::string& VpnNodeInfo::country() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.VpnNodeInfo.country)
  return country_.GetNoArena();
}
inline void VpnNodeInfo::set_country(const ::std::string& value) {
  set_has_country();
  country_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.VpnNodeInfo.country)
}
#if LANG_CXX11
inline void VpnNodeInfo::set_country(::std::string&& value) {
  set_has_country();
  country_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.VpnNodeInfo.country)
}
#endif
inline void VpnNodeInfo::set_country(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_country();
  country_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.VpnNodeInfo.country)
}
inline void VpnNodeInfo::set_country(const void* value, size_t size) {
  set_has_country();
  country_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.VpnNodeInfo.country)
}
inline ::std::string* VpnNodeInfo::mutable_country() {
  set_has_country();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.VpnNodeInfo.country)
  return country_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VpnNodeInfo::release_country() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.VpnNodeInfo.country)
  if (!has_country()) {
    return NULL;
  }
  clear_has_country();
  return country_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VpnNodeInfo::set_allocated_country(::std::string* country) {
  if (country != NULL) {
    set_has_country();
  } else {
    clear_has_country();
  }
  country_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), country);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.VpnNodeInfo.country)
}

// optional uint32 min_svr_port = 5;
inline bool VpnNodeInfo::has_min_svr_port() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VpnNodeInfo::set_has_min_svr_port() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VpnNodeInfo::clear_has_min_svr_port() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VpnNodeInfo::clear_min_svr_port() {
  min_svr_port_ = 0u;
  clear_has_min_svr_port();
}
inline ::google::protobuf::uint32 VpnNodeInfo::min_svr_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.VpnNodeInfo.min_svr_port)
  return min_svr_port_;
}
inline void VpnNodeInfo::set_min_svr_port(::google::protobuf::uint32 value) {
  set_has_min_svr_port();
  min_svr_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.VpnNodeInfo.min_svr_port)
}

// optional uint32 max_svr_port = 6;
inline bool VpnNodeInfo::has_max_svr_port() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VpnNodeInfo::set_has_max_svr_port() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VpnNodeInfo::clear_has_max_svr_port() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VpnNodeInfo::clear_max_svr_port() {
  max_svr_port_ = 0u;
  clear_has_max_svr_port();
}
inline ::google::protobuf::uint32 VpnNodeInfo::max_svr_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.VpnNodeInfo.max_svr_port)
  return max_svr_port_;
}
inline void VpnNodeInfo::set_max_svr_port(::google::protobuf::uint32 value) {
  set_has_max_svr_port();
  max_svr_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.VpnNodeInfo.max_svr_port)
}

// optional uint32 min_route_port = 7;
inline bool VpnNodeInfo::has_min_route_port() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VpnNodeInfo::set_has_min_route_port() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VpnNodeInfo::clear_has_min_route_port() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VpnNodeInfo::clear_min_route_port() {
  min_route_port_ = 0u;
  clear_has_min_route_port();
}
inline ::google::protobuf::uint32 VpnNodeInfo::min_route_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.VpnNodeInfo.min_route_port)
  return min_route_port_;
}
inline void VpnNodeInfo::set_min_route_port(::google::protobuf::uint32 value) {
  set_has_min_route_port();
  min_route_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.VpnNodeInfo.min_route_port)
}

// optional uint32 max_route_port = 8;
inline bool VpnNodeInfo::has_max_route_port() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void VpnNodeInfo::set_has_max_route_port() {
  _has_bits_[0] |= 0x00000100u;
}
inline void VpnNodeInfo::clear_has_max_route_port() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void VpnNodeInfo::clear_max_route_port() {
  max_route_port_ = 0u;
  clear_has_max_route_port();
}
inline ::google::protobuf::uint32 VpnNodeInfo::max_route_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.VpnNodeInfo.max_route_port)
  return max_route_port_;
}
inline void VpnNodeInfo::set_max_route_port(::google::protobuf::uint32 value) {
  set_has_max_route_port();
  max_route_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.VpnNodeInfo.max_route_port)
}

// optional uint32 node_weight = 9;
inline bool VpnNodeInfo::has_node_weight() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void VpnNodeInfo::set_has_node_weight() {
  _has_bits_[0] |= 0x00000200u;
}
inline void VpnNodeInfo::clear_has_node_weight() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void VpnNodeInfo::clear_node_weight() {
  node_weight_ = 0u;
  clear_has_node_weight();
}
inline ::google::protobuf::uint32 VpnNodeInfo::node_weight() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.VpnNodeInfo.node_weight)
  return node_weight_;
}
inline void VpnNodeInfo::set_node_weight(::google::protobuf::uint32 value) {
  set_has_node_weight();
  node_weight_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.VpnNodeInfo.node_weight)
}

// optional uint32 min_udp_port = 10;
inline bool VpnNodeInfo::has_min_udp_port() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void VpnNodeInfo::set_has_min_udp_port() {
  _has_bits_[0] |= 0x00000400u;
}
inline void VpnNodeInfo::clear_has_min_udp_port() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void VpnNodeInfo::clear_min_udp_port() {
  min_udp_port_ = 0u;
  clear_has_min_udp_port();
}
inline ::google::protobuf::uint32 VpnNodeInfo::min_udp_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.VpnNodeInfo.min_udp_port)
  return min_udp_port_;
}
inline void VpnNodeInfo::set_min_udp_port(::google::protobuf::uint32 value) {
  set_has_min_udp_port();
  min_udp_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.VpnNodeInfo.min_udp_port)
}

// optional uint32 max_udp_port = 11;
inline bool VpnNodeInfo::has_max_udp_port() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void VpnNodeInfo::set_has_max_udp_port() {
  _has_bits_[0] |= 0x00000800u;
}
inline void VpnNodeInfo::clear_has_max_udp_port() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void VpnNodeInfo::clear_max_udp_port() {
  max_udp_port_ = 0u;
  clear_has_max_udp_port();
}
inline ::google::protobuf::uint32 VpnNodeInfo::max_udp_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.VpnNodeInfo.max_udp_port)
  return max_udp_port_;
}
inline void VpnNodeInfo::set_max_udp_port(::google::protobuf::uint32 value) {
  set_has_max_udp_port();
  max_udp_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.VpnNodeInfo.max_udp_port)
}

// repeated .tenon.dht.protobuf.RelayVpnNodeInfo relay_vpn_nodes = 12;
inline int VpnNodeInfo::relay_vpn_nodes_size() const {
  return relay_vpn_nodes_.size();
}
inline void VpnNodeInfo::clear_relay_vpn_nodes() {
  relay_vpn_nodes_.Clear();
}
inline ::tenon::dht::protobuf::RelayVpnNodeInfo* VpnNodeInfo::mutable_relay_vpn_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.VpnNodeInfo.relay_vpn_nodes)
  return relay_vpn_nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tenon::dht::protobuf::RelayVpnNodeInfo >*
VpnNodeInfo::mutable_relay_vpn_nodes() {
  // @@protoc_insertion_point(field_mutable_list:tenon.dht.protobuf.VpnNodeInfo.relay_vpn_nodes)
  return &relay_vpn_nodes_;
}
inline const ::tenon::dht::protobuf::RelayVpnNodeInfo& VpnNodeInfo::relay_vpn_nodes(int index) const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.VpnNodeInfo.relay_vpn_nodes)
  return relay_vpn_nodes_.Get(index);
}
inline ::tenon::dht::protobuf::RelayVpnNodeInfo* VpnNodeInfo::add_relay_vpn_nodes() {
  // @@protoc_insertion_point(field_add:tenon.dht.protobuf.VpnNodeInfo.relay_vpn_nodes)
  return relay_vpn_nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tenon::dht::protobuf::RelayVpnNodeInfo >&
VpnNodeInfo::relay_vpn_nodes() const {
  // @@protoc_insertion_point(field_list:tenon.dht.protobuf.VpnNodeInfo.relay_vpn_nodes)
  return relay_vpn_nodes_;
}

// optional bytes node_tag = 13;
inline bool VpnNodeInfo::has_node_tag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VpnNodeInfo::set_has_node_tag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VpnNodeInfo::clear_has_node_tag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VpnNodeInfo::clear_node_tag() {
  node_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_node_tag();
}
inline const ::std::string& VpnNodeInfo::node_tag() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.VpnNodeInfo.node_tag)
  return node_tag_.GetNoArena();
}
inline void VpnNodeInfo::set_node_tag(const ::std::string& value) {
  set_has_node_tag();
  node_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.VpnNodeInfo.node_tag)
}
#if LANG_CXX11
inline void VpnNodeInfo::set_node_tag(::std::string&& value) {
  set_has_node_tag();
  node_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.VpnNodeInfo.node_tag)
}
#endif
inline void VpnNodeInfo::set_node_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_node_tag();
  node_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.VpnNodeInfo.node_tag)
}
inline void VpnNodeInfo::set_node_tag(const void* value, size_t size) {
  set_has_node_tag();
  node_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.VpnNodeInfo.node_tag)
}
inline ::std::string* VpnNodeInfo::mutable_node_tag() {
  set_has_node_tag();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.VpnNodeInfo.node_tag)
  return node_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VpnNodeInfo::release_node_tag() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.VpnNodeInfo.node_tag)
  if (!has_node_tag()) {
    return NULL;
  }
  clear_has_node_tag();
  return node_tag_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VpnNodeInfo::set_allocated_node_tag(::std::string* node_tag) {
  if (node_tag != NULL) {
    set_has_node_tag();
  } else {
    clear_has_node_tag();
  }
  node_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node_tag);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.VpnNodeInfo.node_tag)
}

// -------------------------------------------------------------------

// InitMessage

// optional bytes version_info = 1;
inline bool InitMessage::has_version_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitMessage::set_has_version_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitMessage::clear_has_version_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitMessage::clear_version_info() {
  version_info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version_info();
}
inline const ::std::string& InitMessage::version_info() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.InitMessage.version_info)
  return version_info_.GetNoArena();
}
inline void InitMessage::set_version_info(const ::std::string& value) {
  set_has_version_info();
  version_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.InitMessage.version_info)
}
#if LANG_CXX11
inline void InitMessage::set_version_info(::std::string&& value) {
  set_has_version_info();
  version_info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.InitMessage.version_info)
}
#endif
inline void InitMessage::set_version_info(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_version_info();
  version_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.InitMessage.version_info)
}
inline void InitMessage::set_version_info(const void* value, size_t size) {
  set_has_version_info();
  version_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.InitMessage.version_info)
}
inline ::std::string* InitMessage::mutable_version_info() {
  set_has_version_info();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.InitMessage.version_info)
  return version_info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitMessage::release_version_info() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.InitMessage.version_info)
  if (!has_version_info()) {
    return NULL;
  }
  clear_has_version_info();
  return version_info_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitMessage::set_allocated_version_info(::std::string* version_info) {
  if (version_info != NULL) {
    set_has_version_info();
  } else {
    clear_has_version_info();
  }
  version_info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version_info);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.InitMessage.version_info)
}

// repeated .tenon.dht.protobuf.VpnNodeInfo route_nodes = 2;
inline int InitMessage::route_nodes_size() const {
  return route_nodes_.size();
}
inline void InitMessage::clear_route_nodes() {
  route_nodes_.Clear();
}
inline ::tenon::dht::protobuf::VpnNodeInfo* InitMessage::mutable_route_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.InitMessage.route_nodes)
  return route_nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tenon::dht::protobuf::VpnNodeInfo >*
InitMessage::mutable_route_nodes() {
  // @@protoc_insertion_point(field_mutable_list:tenon.dht.protobuf.InitMessage.route_nodes)
  return &route_nodes_;
}
inline const ::tenon::dht::protobuf::VpnNodeInfo& InitMessage::route_nodes(int index) const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.InitMessage.route_nodes)
  return route_nodes_.Get(index);
}
inline ::tenon::dht::protobuf::VpnNodeInfo* InitMessage::add_route_nodes() {
  // @@protoc_insertion_point(field_add:tenon.dht.protobuf.InitMessage.route_nodes)
  return route_nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tenon::dht::protobuf::VpnNodeInfo >&
InitMessage::route_nodes() const {
  // @@protoc_insertion_point(field_list:tenon.dht.protobuf.InitMessage.route_nodes)
  return route_nodes_;
}

// repeated .tenon.dht.protobuf.VpnNodeInfo vpn_nodes = 3;
inline int InitMessage::vpn_nodes_size() const {
  return vpn_nodes_.size();
}
inline void InitMessage::clear_vpn_nodes() {
  vpn_nodes_.Clear();
}
inline ::tenon::dht::protobuf::VpnNodeInfo* InitMessage::mutable_vpn_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.InitMessage.vpn_nodes)
  return vpn_nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tenon::dht::protobuf::VpnNodeInfo >*
InitMessage::mutable_vpn_nodes() {
  // @@protoc_insertion_point(field_mutable_list:tenon.dht.protobuf.InitMessage.vpn_nodes)
  return &vpn_nodes_;
}
inline const ::tenon::dht::protobuf::VpnNodeInfo& InitMessage::vpn_nodes(int index) const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.InitMessage.vpn_nodes)
  return vpn_nodes_.Get(index);
}
inline ::tenon::dht::protobuf::VpnNodeInfo* InitMessage::add_vpn_nodes() {
  // @@protoc_insertion_point(field_add:tenon.dht.protobuf.InitMessage.vpn_nodes)
  return vpn_nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tenon::dht::protobuf::VpnNodeInfo >&
InitMessage::vpn_nodes() const {
  // @@protoc_insertion_point(field_list:tenon.dht.protobuf.InitMessage.vpn_nodes)
  return vpn_nodes_;
}

// optional bool use_conf_nodes = 4;
inline bool InitMessage::has_use_conf_nodes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InitMessage::set_has_use_conf_nodes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InitMessage::clear_has_use_conf_nodes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InitMessage::clear_use_conf_nodes() {
  use_conf_nodes_ = false;
  clear_has_use_conf_nodes();
}
inline bool InitMessage::use_conf_nodes() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.InitMessage.use_conf_nodes)
  return use_conf_nodes_;
}
inline void InitMessage::set_use_conf_nodes(bool value) {
  set_has_use_conf_nodes();
  use_conf_nodes_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.InitMessage.use_conf_nodes)
}

// optional bytes vpn_node_count = 5;
inline bool InitMessage::has_vpn_node_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InitMessage::set_has_vpn_node_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InitMessage::clear_has_vpn_node_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InitMessage::clear_vpn_node_count() {
  vpn_node_count_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_vpn_node_count();
}
inline const ::std::string& InitMessage::vpn_node_count() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.InitMessage.vpn_node_count)
  return vpn_node_count_.GetNoArena();
}
inline void InitMessage::set_vpn_node_count(const ::std::string& value) {
  set_has_vpn_node_count();
  vpn_node_count_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.InitMessage.vpn_node_count)
}
#if LANG_CXX11
inline void InitMessage::set_vpn_node_count(::std::string&& value) {
  set_has_vpn_node_count();
  vpn_node_count_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.InitMessage.vpn_node_count)
}
#endif
inline void InitMessage::set_vpn_node_count(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_vpn_node_count();
  vpn_node_count_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.InitMessage.vpn_node_count)
}
inline void InitMessage::set_vpn_node_count(const void* value, size_t size) {
  set_has_vpn_node_count();
  vpn_node_count_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.InitMessage.vpn_node_count)
}
inline ::std::string* InitMessage::mutable_vpn_node_count() {
  set_has_vpn_node_count();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.InitMessage.vpn_node_count)
  return vpn_node_count_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitMessage::release_vpn_node_count() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.InitMessage.vpn_node_count)
  if (!has_vpn_node_count()) {
    return NULL;
  }
  clear_has_vpn_node_count();
  return vpn_node_count_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitMessage::set_allocated_vpn_node_count(::std::string* vpn_node_count) {
  if (vpn_node_count != NULL) {
    set_has_vpn_node_count();
  } else {
    clear_has_vpn_node_count();
  }
  vpn_node_count_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vpn_node_count);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.InitMessage.vpn_node_count)
}

// optional bytes vpn_count_svr = 6;
inline bool InitMessage::has_vpn_count_svr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InitMessage::set_has_vpn_count_svr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InitMessage::clear_has_vpn_count_svr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InitMessage::clear_vpn_count_svr() {
  vpn_count_svr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_vpn_count_svr();
}
inline const ::std::string& InitMessage::vpn_count_svr() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.InitMessage.vpn_count_svr)
  return vpn_count_svr_.GetNoArena();
}
inline void InitMessage::set_vpn_count_svr(const ::std::string& value) {
  set_has_vpn_count_svr();
  vpn_count_svr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.InitMessage.vpn_count_svr)
}
#if LANG_CXX11
inline void InitMessage::set_vpn_count_svr(::std::string&& value) {
  set_has_vpn_count_svr();
  vpn_count_svr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.InitMessage.vpn_count_svr)
}
#endif
inline void InitMessage::set_vpn_count_svr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_vpn_count_svr();
  vpn_count_svr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.InitMessage.vpn_count_svr)
}
inline void InitMessage::set_vpn_count_svr(const void* value, size_t size) {
  set_has_vpn_count_svr();
  vpn_count_svr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.InitMessage.vpn_count_svr)
}
inline ::std::string* InitMessage::mutable_vpn_count_svr() {
  set_has_vpn_count_svr();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.InitMessage.vpn_count_svr)
  return vpn_count_svr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitMessage::release_vpn_count_svr() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.InitMessage.vpn_count_svr)
  if (!has_vpn_count_svr()) {
    return NULL;
  }
  clear_has_vpn_count_svr();
  return vpn_count_svr_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitMessage::set_allocated_vpn_count_svr(::std::string* vpn_count_svr) {
  if (vpn_count_svr != NULL) {
    set_has_vpn_count_svr();
  } else {
    clear_has_vpn_count_svr();
  }
  vpn_count_svr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vpn_count_svr);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.InitMessage.vpn_count_svr)
}

// optional bytes init_blocks = 7;
inline bool InitMessage::has_init_blocks() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InitMessage::set_has_init_blocks() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InitMessage::clear_has_init_blocks() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InitMessage::clear_init_blocks() {
  init_blocks_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_init_blocks();
}
inline const ::std::string& InitMessage::init_blocks() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.InitMessage.init_blocks)
  return init_blocks_.GetNoArena();
}
inline void InitMessage::set_init_blocks(const ::std::string& value) {
  set_has_init_blocks();
  init_blocks_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.InitMessage.init_blocks)
}
#if LANG_CXX11
inline void InitMessage::set_init_blocks(::std::string&& value) {
  set_has_init_blocks();
  init_blocks_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.InitMessage.init_blocks)
}
#endif
inline void InitMessage::set_init_blocks(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_init_blocks();
  init_blocks_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.InitMessage.init_blocks)
}
inline void InitMessage::set_init_blocks(const void* value, size_t size) {
  set_has_init_blocks();
  init_blocks_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.InitMessage.init_blocks)
}
inline ::std::string* InitMessage::mutable_init_blocks() {
  set_has_init_blocks();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.InitMessage.init_blocks)
  return init_blocks_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitMessage::release_init_blocks() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.InitMessage.init_blocks)
  if (!has_init_blocks()) {
    return NULL;
  }
  clear_has_init_blocks();
  return init_blocks_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitMessage::set_allocated_init_blocks(::std::string* init_blocks) {
  if (init_blocks != NULL) {
    set_has_init_blocks();
  } else {
    clear_has_init_blocks();
  }
  init_blocks_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), init_blocks);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.InitMessage.init_blocks)
}

// optional bytes bft_nodes = 8;
inline bool InitMessage::has_bft_nodes() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InitMessage::set_has_bft_nodes() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InitMessage::clear_has_bft_nodes() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InitMessage::clear_bft_nodes() {
  bft_nodes_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bft_nodes();
}
inline const ::std::string& InitMessage::bft_nodes() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.InitMessage.bft_nodes)
  return bft_nodes_.GetNoArena();
}
inline void InitMessage::set_bft_nodes(const ::std::string& value) {
  set_has_bft_nodes();
  bft_nodes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.InitMessage.bft_nodes)
}
#if LANG_CXX11
inline void InitMessage::set_bft_nodes(::std::string&& value) {
  set_has_bft_nodes();
  bft_nodes_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.InitMessage.bft_nodes)
}
#endif
inline void InitMessage::set_bft_nodes(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bft_nodes();
  bft_nodes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.InitMessage.bft_nodes)
}
inline void InitMessage::set_bft_nodes(const void* value, size_t size) {
  set_has_bft_nodes();
  bft_nodes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.InitMessage.bft_nodes)
}
inline ::std::string* InitMessage::mutable_bft_nodes() {
  set_has_bft_nodes();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.InitMessage.bft_nodes)
  return bft_nodes_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitMessage::release_bft_nodes() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.InitMessage.bft_nodes)
  if (!has_bft_nodes()) {
    return NULL;
  }
  clear_has_bft_nodes();
  return bft_nodes_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitMessage::set_allocated_bft_nodes(::std::string* bft_nodes) {
  if (bft_nodes != NULL) {
    set_has_bft_nodes();
  } else {
    clear_has_bft_nodes();
  }
  bft_nodes_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bft_nodes);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.InitMessage.bft_nodes)
}

// repeated .tenon.dht.protobuf.VpnNodeInfo vip_route_nodes = 9;
inline int InitMessage::vip_route_nodes_size() const {
  return vip_route_nodes_.size();
}
inline void InitMessage::clear_vip_route_nodes() {
  vip_route_nodes_.Clear();
}
inline ::tenon::dht::protobuf::VpnNodeInfo* InitMessage::mutable_vip_route_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.InitMessage.vip_route_nodes)
  return vip_route_nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tenon::dht::protobuf::VpnNodeInfo >*
InitMessage::mutable_vip_route_nodes() {
  // @@protoc_insertion_point(field_mutable_list:tenon.dht.protobuf.InitMessage.vip_route_nodes)
  return &vip_route_nodes_;
}
inline const ::tenon::dht::protobuf::VpnNodeInfo& InitMessage::vip_route_nodes(int index) const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.InitMessage.vip_route_nodes)
  return vip_route_nodes_.Get(index);
}
inline ::tenon::dht::protobuf::VpnNodeInfo* InitMessage::add_vip_route_nodes() {
  // @@protoc_insertion_point(field_add:tenon.dht.protobuf.InitMessage.vip_route_nodes)
  return vip_route_nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tenon::dht::protobuf::VpnNodeInfo >&
InitMessage::vip_route_nodes() const {
  // @@protoc_insertion_point(field_list:tenon.dht.protobuf.InitMessage.vip_route_nodes)
  return vip_route_nodes_;
}

// repeated .tenon.dht.protobuf.VpnNodeInfo vip_vpn_nodes = 10;
inline int InitMessage::vip_vpn_nodes_size() const {
  return vip_vpn_nodes_.size();
}
inline void InitMessage::clear_vip_vpn_nodes() {
  vip_vpn_nodes_.Clear();
}
inline ::tenon::dht::protobuf::VpnNodeInfo* InitMessage::mutable_vip_vpn_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.InitMessage.vip_vpn_nodes)
  return vip_vpn_nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tenon::dht::protobuf::VpnNodeInfo >*
InitMessage::mutable_vip_vpn_nodes() {
  // @@protoc_insertion_point(field_mutable_list:tenon.dht.protobuf.InitMessage.vip_vpn_nodes)
  return &vip_vpn_nodes_;
}
inline const ::tenon::dht::protobuf::VpnNodeInfo& InitMessage::vip_vpn_nodes(int index) const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.InitMessage.vip_vpn_nodes)
  return vip_vpn_nodes_.Get(index);
}
inline ::tenon::dht::protobuf::VpnNodeInfo* InitMessage::add_vip_vpn_nodes() {
  // @@protoc_insertion_point(field_add:tenon.dht.protobuf.InitMessage.vip_vpn_nodes)
  return vip_vpn_nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tenon::dht::protobuf::VpnNodeInfo >&
InitMessage::vip_vpn_nodes() const {
  // @@protoc_insertion_point(field_list:tenon.dht.protobuf.InitMessage.vip_vpn_nodes)
  return vip_vpn_nodes_;
}

// -------------------------------------------------------------------

// BootstrapResponse

// optional bytes node_id = 1;
inline bool BootstrapResponse::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BootstrapResponse::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BootstrapResponse::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BootstrapResponse::clear_node_id() {
  node_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_node_id();
}
inline const ::std::string& BootstrapResponse::node_id() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapResponse.node_id)
  return node_id_.GetNoArena();
}
inline void BootstrapResponse::set_node_id(const ::std::string& value) {
  set_has_node_id();
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.BootstrapResponse.node_id)
}
#if LANG_CXX11
inline void BootstrapResponse::set_node_id(::std::string&& value) {
  set_has_node_id();
  node_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.BootstrapResponse.node_id)
}
#endif
inline void BootstrapResponse::set_node_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_node_id();
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.BootstrapResponse.node_id)
}
inline void BootstrapResponse::set_node_id(const void* value, size_t size) {
  set_has_node_id();
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.BootstrapResponse.node_id)
}
inline ::std::string* BootstrapResponse::mutable_node_id() {
  set_has_node_id();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.BootstrapResponse.node_id)
  return node_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BootstrapResponse::release_node_id() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.BootstrapResponse.node_id)
  if (!has_node_id()) {
    return NULL;
  }
  clear_has_node_id();
  return node_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BootstrapResponse::set_allocated_node_id(::std::string* node_id) {
  if (node_id != NULL) {
    set_has_node_id();
  } else {
    clear_has_node_id();
  }
  node_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node_id);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.BootstrapResponse.node_id)
}

// optional int32 nat_type = 2;
inline bool BootstrapResponse::has_nat_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BootstrapResponse::set_has_nat_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BootstrapResponse::clear_has_nat_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BootstrapResponse::clear_nat_type() {
  nat_type_ = 0;
  clear_has_nat_type();
}
inline ::google::protobuf::int32 BootstrapResponse::nat_type() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapResponse.nat_type)
  return nat_type_;
}
inline void BootstrapResponse::set_nat_type(::google::protobuf::int32 value) {
  set_has_nat_type();
  nat_type_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.BootstrapResponse.nat_type)
}

// optional string local_ip = 3;
inline bool BootstrapResponse::has_local_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BootstrapResponse::set_has_local_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BootstrapResponse::clear_has_local_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BootstrapResponse::clear_local_ip() {
  local_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_local_ip();
}
inline const ::std::string& BootstrapResponse::local_ip() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapResponse.local_ip)
  return local_ip_.GetNoArena();
}
inline void BootstrapResponse::set_local_ip(const ::std::string& value) {
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.BootstrapResponse.local_ip)
}
#if LANG_CXX11
inline void BootstrapResponse::set_local_ip(::std::string&& value) {
  set_has_local_ip();
  local_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.BootstrapResponse.local_ip)
}
#endif
inline void BootstrapResponse::set_local_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.BootstrapResponse.local_ip)
}
inline void BootstrapResponse::set_local_ip(const char* value, size_t size) {
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.BootstrapResponse.local_ip)
}
inline ::std::string* BootstrapResponse::mutable_local_ip() {
  set_has_local_ip();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.BootstrapResponse.local_ip)
  return local_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BootstrapResponse::release_local_ip() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.BootstrapResponse.local_ip)
  if (!has_local_ip()) {
    return NULL;
  }
  clear_has_local_ip();
  return local_ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BootstrapResponse::set_allocated_local_ip(::std::string* local_ip) {
  if (local_ip != NULL) {
    set_has_local_ip();
  } else {
    clear_has_local_ip();
  }
  local_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_ip);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.BootstrapResponse.local_ip)
}

// optional int32 local_port = 4;
inline bool BootstrapResponse::has_local_port() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BootstrapResponse::set_has_local_port() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BootstrapResponse::clear_has_local_port() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BootstrapResponse::clear_local_port() {
  local_port_ = 0;
  clear_has_local_port();
}
inline ::google::protobuf::int32 BootstrapResponse::local_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapResponse.local_port)
  return local_port_;
}
inline void BootstrapResponse::set_local_port(::google::protobuf::int32 value) {
  set_has_local_port();
  local_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.BootstrapResponse.local_port)
}

// optional string public_ip = 5;
inline bool BootstrapResponse::has_public_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BootstrapResponse::set_has_public_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BootstrapResponse::clear_has_public_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BootstrapResponse::clear_public_ip() {
  public_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_public_ip();
}
inline const ::std::string& BootstrapResponse::public_ip() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapResponse.public_ip)
  return public_ip_.GetNoArena();
}
inline void BootstrapResponse::set_public_ip(const ::std::string& value) {
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.BootstrapResponse.public_ip)
}
#if LANG_CXX11
inline void BootstrapResponse::set_public_ip(::std::string&& value) {
  set_has_public_ip();
  public_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.BootstrapResponse.public_ip)
}
#endif
inline void BootstrapResponse::set_public_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.BootstrapResponse.public_ip)
}
inline void BootstrapResponse::set_public_ip(const char* value, size_t size) {
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.BootstrapResponse.public_ip)
}
inline ::std::string* BootstrapResponse::mutable_public_ip() {
  set_has_public_ip();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.BootstrapResponse.public_ip)
  return public_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BootstrapResponse::release_public_ip() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.BootstrapResponse.public_ip)
  if (!has_public_ip()) {
    return NULL;
  }
  clear_has_public_ip();
  return public_ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BootstrapResponse::set_allocated_public_ip(::std::string* public_ip) {
  if (public_ip != NULL) {
    set_has_public_ip();
  } else {
    clear_has_public_ip();
  }
  public_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_ip);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.BootstrapResponse.public_ip)
}

// optional int32 public_port = 6;
inline bool BootstrapResponse::has_public_port() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BootstrapResponse::set_has_public_port() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BootstrapResponse::clear_has_public_port() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BootstrapResponse::clear_public_port() {
  public_port_ = 0;
  clear_has_public_port();
}
inline ::google::protobuf::int32 BootstrapResponse::public_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapResponse.public_port)
  return public_port_;
}
inline void BootstrapResponse::set_public_port(::google::protobuf::int32 value) {
  set_has_public_port();
  public_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.BootstrapResponse.public_port)
}

// optional int32 country_code = 7;
inline bool BootstrapResponse::has_country_code() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BootstrapResponse::set_has_country_code() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BootstrapResponse::clear_has_country_code() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BootstrapResponse::clear_country_code() {
  country_code_ = 0;
  clear_has_country_code();
}
inline ::google::protobuf::int32 BootstrapResponse::country_code() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapResponse.country_code)
  return country_code_;
}
inline void BootstrapResponse::set_country_code(::google::protobuf::int32 value) {
  set_has_country_code();
  country_code_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.BootstrapResponse.country_code)
}

// optional .tenon.dht.protobuf.InitMessage init_message = 8;
inline bool BootstrapResponse::has_init_message() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BootstrapResponse::set_has_init_message() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BootstrapResponse::clear_has_init_message() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BootstrapResponse::clear_init_message() {
  if (init_message_ != NULL) init_message_->Clear();
  clear_has_init_message();
}
inline const ::tenon::dht::protobuf::InitMessage& BootstrapResponse::_internal_init_message() const {
  return *init_message_;
}
inline const ::tenon::dht::protobuf::InitMessage& BootstrapResponse::init_message() const {
  const ::tenon::dht::protobuf::InitMessage* p = init_message_;
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapResponse.init_message)
  return p != NULL ? *p : *reinterpret_cast<const ::tenon::dht::protobuf::InitMessage*>(
      &::tenon::dht::protobuf::_InitMessage_default_instance_);
}
inline ::tenon::dht::protobuf::InitMessage* BootstrapResponse::release_init_message() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.BootstrapResponse.init_message)
  clear_has_init_message();
  ::tenon::dht::protobuf::InitMessage* temp = init_message_;
  init_message_ = NULL;
  return temp;
}
inline ::tenon::dht::protobuf::InitMessage* BootstrapResponse::mutable_init_message() {
  set_has_init_message();
  if (init_message_ == NULL) {
    auto* p = CreateMaybeMessage<::tenon::dht::protobuf::InitMessage>(GetArenaNoVirtual());
    init_message_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.BootstrapResponse.init_message)
  return init_message_;
}
inline void BootstrapResponse::set_allocated_init_message(::tenon::dht::protobuf::InitMessage* init_message) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete init_message_;
  }
  if (init_message) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      init_message = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, init_message, submessage_arena);
    }
    set_has_init_message();
  } else {
    clear_has_init_message();
  }
  init_message_ = init_message;
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.BootstrapResponse.init_message)
}

// optional uint32 min_svr_port = 9;
inline bool BootstrapResponse::has_min_svr_port() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BootstrapResponse::set_has_min_svr_port() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BootstrapResponse::clear_has_min_svr_port() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BootstrapResponse::clear_min_svr_port() {
  min_svr_port_ = 0u;
  clear_has_min_svr_port();
}
inline ::google::protobuf::uint32 BootstrapResponse::min_svr_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapResponse.min_svr_port)
  return min_svr_port_;
}
inline void BootstrapResponse::set_min_svr_port(::google::protobuf::uint32 value) {
  set_has_min_svr_port();
  min_svr_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.BootstrapResponse.min_svr_port)
}

// optional uint32 max_svr_port = 10;
inline bool BootstrapResponse::has_max_svr_port() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BootstrapResponse::set_has_max_svr_port() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BootstrapResponse::clear_has_max_svr_port() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BootstrapResponse::clear_max_svr_port() {
  max_svr_port_ = 0u;
  clear_has_max_svr_port();
}
inline ::google::protobuf::uint32 BootstrapResponse::max_svr_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapResponse.max_svr_port)
  return max_svr_port_;
}
inline void BootstrapResponse::set_max_svr_port(::google::protobuf::uint32 value) {
  set_has_max_svr_port();
  max_svr_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.BootstrapResponse.max_svr_port)
}

// optional uint32 min_route_port = 11;
inline bool BootstrapResponse::has_min_route_port() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BootstrapResponse::set_has_min_route_port() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BootstrapResponse::clear_has_min_route_port() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BootstrapResponse::clear_min_route_port() {
  min_route_port_ = 0u;
  clear_has_min_route_port();
}
inline ::google::protobuf::uint32 BootstrapResponse::min_route_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapResponse.min_route_port)
  return min_route_port_;
}
inline void BootstrapResponse::set_min_route_port(::google::protobuf::uint32 value) {
  set_has_min_route_port();
  min_route_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.BootstrapResponse.min_route_port)
}

// optional uint32 max_route_port = 12;
inline bool BootstrapResponse::has_max_route_port() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BootstrapResponse::set_has_max_route_port() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BootstrapResponse::clear_has_max_route_port() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BootstrapResponse::clear_max_route_port() {
  max_route_port_ = 0u;
  clear_has_max_route_port();
}
inline ::google::protobuf::uint32 BootstrapResponse::max_route_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapResponse.max_route_port)
  return max_route_port_;
}
inline void BootstrapResponse::set_max_route_port(::google::protobuf::uint32 value) {
  set_has_max_route_port();
  max_route_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.BootstrapResponse.max_route_port)
}

// optional int32 peer_public_port = 13;
inline bool BootstrapResponse::has_peer_public_port() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BootstrapResponse::set_has_peer_public_port() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BootstrapResponse::clear_has_peer_public_port() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BootstrapResponse::clear_peer_public_port() {
  peer_public_port_ = 0;
  clear_has_peer_public_port();
}
inline ::google::protobuf::int32 BootstrapResponse::peer_public_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapResponse.peer_public_port)
  return peer_public_port_;
}
inline void BootstrapResponse::set_peer_public_port(::google::protobuf::int32 value) {
  set_has_peer_public_port();
  peer_public_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.BootstrapResponse.peer_public_port)
}

// optional uint32 node_weight = 14;
inline bool BootstrapResponse::has_node_weight() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void BootstrapResponse::set_has_node_weight() {
  _has_bits_[0] |= 0x00004000u;
}
inline void BootstrapResponse::clear_has_node_weight() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void BootstrapResponse::clear_node_weight() {
  node_weight_ = 0u;
  clear_has_node_weight();
}
inline ::google::protobuf::uint32 BootstrapResponse::node_weight() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapResponse.node_weight)
  return node_weight_;
}
inline void BootstrapResponse::set_node_weight(::google::protobuf::uint32 value) {
  set_has_node_weight();
  node_weight_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.BootstrapResponse.node_weight)
}

// optional uint32 min_udp_port = 15;
inline bool BootstrapResponse::has_min_udp_port() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void BootstrapResponse::set_has_min_udp_port() {
  _has_bits_[0] |= 0x00008000u;
}
inline void BootstrapResponse::clear_has_min_udp_port() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void BootstrapResponse::clear_min_udp_port() {
  min_udp_port_ = 0u;
  clear_has_min_udp_port();
}
inline ::google::protobuf::uint32 BootstrapResponse::min_udp_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapResponse.min_udp_port)
  return min_udp_port_;
}
inline void BootstrapResponse::set_min_udp_port(::google::protobuf::uint32 value) {
  set_has_min_udp_port();
  min_udp_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.BootstrapResponse.min_udp_port)
}

// optional uint32 max_udp_port = 16;
inline bool BootstrapResponse::has_max_udp_port() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void BootstrapResponse::set_has_max_udp_port() {
  _has_bits_[0] |= 0x00010000u;
}
inline void BootstrapResponse::clear_has_max_udp_port() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void BootstrapResponse::clear_max_udp_port() {
  max_udp_port_ = 0u;
  clear_has_max_udp_port();
}
inline ::google::protobuf::uint32 BootstrapResponse::max_udp_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapResponse.max_udp_port)
  return max_udp_port_;
}
inline void BootstrapResponse::set_max_udp_port(::google::protobuf::uint32 value) {
  set_has_max_udp_port();
  max_udp_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.BootstrapResponse.max_udp_port)
}

// optional bytes node_tag = 17;
inline bool BootstrapResponse::has_node_tag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BootstrapResponse::set_has_node_tag() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BootstrapResponse::clear_has_node_tag() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BootstrapResponse::clear_node_tag() {
  node_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_node_tag();
}
inline const ::std::string& BootstrapResponse::node_tag() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.BootstrapResponse.node_tag)
  return node_tag_.GetNoArena();
}
inline void BootstrapResponse::set_node_tag(const ::std::string& value) {
  set_has_node_tag();
  node_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.BootstrapResponse.node_tag)
}
#if LANG_CXX11
inline void BootstrapResponse::set_node_tag(::std::string&& value) {
  set_has_node_tag();
  node_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.BootstrapResponse.node_tag)
}
#endif
inline void BootstrapResponse::set_node_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_node_tag();
  node_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.BootstrapResponse.node_tag)
}
inline void BootstrapResponse::set_node_tag(const void* value, size_t size) {
  set_has_node_tag();
  node_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.BootstrapResponse.node_tag)
}
inline ::std::string* BootstrapResponse::mutable_node_tag() {
  set_has_node_tag();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.BootstrapResponse.node_tag)
  return node_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BootstrapResponse::release_node_tag() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.BootstrapResponse.node_tag)
  if (!has_node_tag()) {
    return NULL;
  }
  clear_has_node_tag();
  return node_tag_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BootstrapResponse::set_allocated_node_tag(::std::string* node_tag) {
  if (node_tag != NULL) {
    set_has_node_tag();
  } else {
    clear_has_node_tag();
  }
  node_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node_tag);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.BootstrapResponse.node_tag)
}

// -------------------------------------------------------------------

// RefreshNeighborsRequest

// optional uint32 count = 1;
inline bool RefreshNeighborsRequest::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RefreshNeighborsRequest::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RefreshNeighborsRequest::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RefreshNeighborsRequest::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 RefreshNeighborsRequest::count() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.RefreshNeighborsRequest.count)
  return count_;
}
inline void RefreshNeighborsRequest::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.RefreshNeighborsRequest.count)
}

// optional bytes des_dht_key = 2;
inline bool RefreshNeighborsRequest::has_des_dht_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RefreshNeighborsRequest::set_has_des_dht_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RefreshNeighborsRequest::clear_has_des_dht_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RefreshNeighborsRequest::clear_des_dht_key() {
  des_dht_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_des_dht_key();
}
inline const ::std::string& RefreshNeighborsRequest::des_dht_key() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.RefreshNeighborsRequest.des_dht_key)
  return des_dht_key_.GetNoArena();
}
inline void RefreshNeighborsRequest::set_des_dht_key(const ::std::string& value) {
  set_has_des_dht_key();
  des_dht_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.RefreshNeighborsRequest.des_dht_key)
}
#if LANG_CXX11
inline void RefreshNeighborsRequest::set_des_dht_key(::std::string&& value) {
  set_has_des_dht_key();
  des_dht_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.RefreshNeighborsRequest.des_dht_key)
}
#endif
inline void RefreshNeighborsRequest::set_des_dht_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_des_dht_key();
  des_dht_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.RefreshNeighborsRequest.des_dht_key)
}
inline void RefreshNeighborsRequest::set_des_dht_key(const void* value, size_t size) {
  set_has_des_dht_key();
  des_dht_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.RefreshNeighborsRequest.des_dht_key)
}
inline ::std::string* RefreshNeighborsRequest::mutable_des_dht_key() {
  set_has_des_dht_key();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.RefreshNeighborsRequest.des_dht_key)
  return des_dht_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RefreshNeighborsRequest::release_des_dht_key() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.RefreshNeighborsRequest.des_dht_key)
  if (!has_des_dht_key()) {
    return NULL;
  }
  clear_has_des_dht_key();
  return des_dht_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RefreshNeighborsRequest::set_allocated_des_dht_key(::std::string* des_dht_key) {
  if (des_dht_key != NULL) {
    set_has_des_dht_key();
  } else {
    clear_has_des_dht_key();
  }
  des_dht_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), des_dht_key);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.RefreshNeighborsRequest.des_dht_key)
}

// repeated uint64 bloomfilter1 = 3;
inline int RefreshNeighborsRequest::bloomfilter1_size() const {
  return bloomfilter1_.size();
}
inline void RefreshNeighborsRequest::clear_bloomfilter1() {
  bloomfilter1_.Clear();
}
inline ::google::protobuf::uint64 RefreshNeighborsRequest::bloomfilter1(int index) const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.RefreshNeighborsRequest.bloomfilter1)
  return bloomfilter1_.Get(index);
}
inline void RefreshNeighborsRequest::set_bloomfilter1(int index, ::google::protobuf::uint64 value) {
  bloomfilter1_.Set(index, value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.RefreshNeighborsRequest.bloomfilter1)
}
inline void RefreshNeighborsRequest::add_bloomfilter1(::google::protobuf::uint64 value) {
  bloomfilter1_.Add(value);
  // @@protoc_insertion_point(field_add:tenon.dht.protobuf.RefreshNeighborsRequest.bloomfilter1)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
RefreshNeighborsRequest::bloomfilter1() const {
  // @@protoc_insertion_point(field_list:tenon.dht.protobuf.RefreshNeighborsRequest.bloomfilter1)
  return bloomfilter1_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
RefreshNeighborsRequest::mutable_bloomfilter1() {
  // @@protoc_insertion_point(field_mutable_list:tenon.dht.protobuf.RefreshNeighborsRequest.bloomfilter1)
  return &bloomfilter1_;
}

// repeated uint64 bloomfilter = 4;
inline int RefreshNeighborsRequest::bloomfilter_size() const {
  return bloomfilter_.size();
}
inline void RefreshNeighborsRequest::clear_bloomfilter() {
  bloomfilter_.Clear();
}
inline ::google::protobuf::uint64 RefreshNeighborsRequest::bloomfilter(int index) const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.RefreshNeighborsRequest.bloomfilter)
  return bloomfilter_.Get(index);
}
inline void RefreshNeighborsRequest::set_bloomfilter(int index, ::google::protobuf::uint64 value) {
  bloomfilter_.Set(index, value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.RefreshNeighborsRequest.bloomfilter)
}
inline void RefreshNeighborsRequest::add_bloomfilter(::google::protobuf::uint64 value) {
  bloomfilter_.Add(value);
  // @@protoc_insertion_point(field_add:tenon.dht.protobuf.RefreshNeighborsRequest.bloomfilter)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
RefreshNeighborsRequest::bloomfilter() const {
  // @@protoc_insertion_point(field_list:tenon.dht.protobuf.RefreshNeighborsRequest.bloomfilter)
  return bloomfilter_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
RefreshNeighborsRequest::mutable_bloomfilter() {
  // @@protoc_insertion_point(field_mutable_list:tenon.dht.protobuf.RefreshNeighborsRequest.bloomfilter)
  return &bloomfilter_;
}

// -------------------------------------------------------------------

// NodeInfo

// optional bytes public_ip = 1;
inline bool NodeInfo::has_public_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeInfo::set_has_public_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeInfo::clear_has_public_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeInfo::clear_public_ip() {
  public_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_public_ip();
}
inline const ::std::string& NodeInfo::public_ip() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.NodeInfo.public_ip)
  return public_ip_.GetNoArena();
}
inline void NodeInfo::set_public_ip(const ::std::string& value) {
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.NodeInfo.public_ip)
}
#if LANG_CXX11
inline void NodeInfo::set_public_ip(::std::string&& value) {
  set_has_public_ip();
  public_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.NodeInfo.public_ip)
}
#endif
inline void NodeInfo::set_public_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.NodeInfo.public_ip)
}
inline void NodeInfo::set_public_ip(const void* value, size_t size) {
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.NodeInfo.public_ip)
}
inline ::std::string* NodeInfo::mutable_public_ip() {
  set_has_public_ip();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.NodeInfo.public_ip)
  return public_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeInfo::release_public_ip() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.NodeInfo.public_ip)
  if (!has_public_ip()) {
    return NULL;
  }
  clear_has_public_ip();
  return public_ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeInfo::set_allocated_public_ip(::std::string* public_ip) {
  if (public_ip != NULL) {
    set_has_public_ip();
  } else {
    clear_has_public_ip();
  }
  public_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_ip);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.NodeInfo.public_ip)
}

// optional int32 public_port = 2;
inline bool NodeInfo::has_public_port() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NodeInfo::set_has_public_port() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NodeInfo::clear_has_public_port() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NodeInfo::clear_public_port() {
  public_port_ = 0;
  clear_has_public_port();
}
inline ::google::protobuf::int32 NodeInfo::public_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.NodeInfo.public_port)
  return public_port_;
}
inline void NodeInfo::set_public_port(::google::protobuf::int32 value) {
  set_has_public_port();
  public_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.NodeInfo.public_port)
}

// optional bytes local_ip = 3;
inline bool NodeInfo::has_local_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeInfo::set_has_local_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeInfo::clear_has_local_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeInfo::clear_local_ip() {
  local_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_local_ip();
}
inline const ::std::string& NodeInfo::local_ip() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.NodeInfo.local_ip)
  return local_ip_.GetNoArena();
}
inline void NodeInfo::set_local_ip(const ::std::string& value) {
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.NodeInfo.local_ip)
}
#if LANG_CXX11
inline void NodeInfo::set_local_ip(::std::string&& value) {
  set_has_local_ip();
  local_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.NodeInfo.local_ip)
}
#endif
inline void NodeInfo::set_local_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.NodeInfo.local_ip)
}
inline void NodeInfo::set_local_ip(const void* value, size_t size) {
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.NodeInfo.local_ip)
}
inline ::std::string* NodeInfo::mutable_local_ip() {
  set_has_local_ip();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.NodeInfo.local_ip)
  return local_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeInfo::release_local_ip() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.NodeInfo.local_ip)
  if (!has_local_ip()) {
    return NULL;
  }
  clear_has_local_ip();
  return local_ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeInfo::set_allocated_local_ip(::std::string* local_ip) {
  if (local_ip != NULL) {
    set_has_local_ip();
  } else {
    clear_has_local_ip();
  }
  local_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_ip);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.NodeInfo.local_ip)
}

// optional int32 local_port = 4;
inline bool NodeInfo::has_local_port() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NodeInfo::set_has_local_port() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NodeInfo::clear_has_local_port() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NodeInfo::clear_local_port() {
  local_port_ = 0;
  clear_has_local_port();
}
inline ::google::protobuf::int32 NodeInfo::local_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.NodeInfo.local_port)
  return local_port_;
}
inline void NodeInfo::set_local_port(::google::protobuf::int32 value) {
  set_has_local_port();
  local_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.NodeInfo.local_port)
}

// optional bytes public_key = 5;
inline bool NodeInfo::has_public_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NodeInfo::set_has_public_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NodeInfo::clear_has_public_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NodeInfo::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_public_key();
}
inline const ::std::string& NodeInfo::public_key() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.NodeInfo.public_key)
  return public_key_.GetNoArena();
}
inline void NodeInfo::set_public_key(const ::std::string& value) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.NodeInfo.public_key)
}
#if LANG_CXX11
inline void NodeInfo::set_public_key(::std::string&& value) {
  set_has_public_key();
  public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.NodeInfo.public_key)
}
#endif
inline void NodeInfo::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.NodeInfo.public_key)
}
inline void NodeInfo::set_public_key(const void* value, size_t size) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.NodeInfo.public_key)
}
inline ::std::string* NodeInfo::mutable_public_key() {
  set_has_public_key();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.NodeInfo.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeInfo::release_public_key() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.NodeInfo.public_key)
  if (!has_public_key()) {
    return NULL;
  }
  clear_has_public_key();
  return public_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeInfo::set_allocated_public_key(::std::string* public_key) {
  if (public_key != NULL) {
    set_has_public_key();
  } else {
    clear_has_public_key();
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.NodeInfo.public_key)
}

// optional int32 nat_type = 6;
inline bool NodeInfo::has_nat_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NodeInfo::set_has_nat_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NodeInfo::clear_has_nat_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NodeInfo::clear_nat_type() {
  nat_type_ = 0;
  clear_has_nat_type();
}
inline ::google::protobuf::int32 NodeInfo::nat_type() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.NodeInfo.nat_type)
  return nat_type_;
}
inline void NodeInfo::set_nat_type(::google::protobuf::int32 value) {
  set_has_nat_type();
  nat_type_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.NodeInfo.nat_type)
}

// optional bytes dht_key = 7;
inline bool NodeInfo::has_dht_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NodeInfo::set_has_dht_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NodeInfo::clear_has_dht_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NodeInfo::clear_dht_key() {
  dht_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dht_key();
}
inline const ::std::string& NodeInfo::dht_key() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.NodeInfo.dht_key)
  return dht_key_.GetNoArena();
}
inline void NodeInfo::set_dht_key(const ::std::string& value) {
  set_has_dht_key();
  dht_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.NodeInfo.dht_key)
}
#if LANG_CXX11
inline void NodeInfo::set_dht_key(::std::string&& value) {
  set_has_dht_key();
  dht_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.NodeInfo.dht_key)
}
#endif
inline void NodeInfo::set_dht_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dht_key();
  dht_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.NodeInfo.dht_key)
}
inline void NodeInfo::set_dht_key(const void* value, size_t size) {
  set_has_dht_key();
  dht_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.NodeInfo.dht_key)
}
inline ::std::string* NodeInfo::mutable_dht_key() {
  set_has_dht_key();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.NodeInfo.dht_key)
  return dht_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeInfo::release_dht_key() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.NodeInfo.dht_key)
  if (!has_dht_key()) {
    return NULL;
  }
  clear_has_dht_key();
  return dht_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeInfo::set_allocated_dht_key(::std::string* dht_key) {
  if (dht_key != NULL) {
    set_has_dht_key();
  } else {
    clear_has_dht_key();
  }
  dht_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dht_key);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.NodeInfo.dht_key)
}

// optional uint32 min_svr_port = 8;
inline bool NodeInfo::has_min_svr_port() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NodeInfo::set_has_min_svr_port() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NodeInfo::clear_has_min_svr_port() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NodeInfo::clear_min_svr_port() {
  min_svr_port_ = 0u;
  clear_has_min_svr_port();
}
inline ::google::protobuf::uint32 NodeInfo::min_svr_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.NodeInfo.min_svr_port)
  return min_svr_port_;
}
inline void NodeInfo::set_min_svr_port(::google::protobuf::uint32 value) {
  set_has_min_svr_port();
  min_svr_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.NodeInfo.min_svr_port)
}

// optional uint32 max_svr_port = 9;
inline bool NodeInfo::has_max_svr_port() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void NodeInfo::set_has_max_svr_port() {
  _has_bits_[0] |= 0x00000200u;
}
inline void NodeInfo::clear_has_max_svr_port() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void NodeInfo::clear_max_svr_port() {
  max_svr_port_ = 0u;
  clear_has_max_svr_port();
}
inline ::google::protobuf::uint32 NodeInfo::max_svr_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.NodeInfo.max_svr_port)
  return max_svr_port_;
}
inline void NodeInfo::set_max_svr_port(::google::protobuf::uint32 value) {
  set_has_max_svr_port();
  max_svr_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.NodeInfo.max_svr_port)
}

// optional uint32 min_route_port = 10;
inline bool NodeInfo::has_min_route_port() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void NodeInfo::set_has_min_route_port() {
  _has_bits_[0] |= 0x00000400u;
}
inline void NodeInfo::clear_has_min_route_port() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void NodeInfo::clear_min_route_port() {
  min_route_port_ = 0u;
  clear_has_min_route_port();
}
inline ::google::protobuf::uint32 NodeInfo::min_route_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.NodeInfo.min_route_port)
  return min_route_port_;
}
inline void NodeInfo::set_min_route_port(::google::protobuf::uint32 value) {
  set_has_min_route_port();
  min_route_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.NodeInfo.min_route_port)
}

// optional uint32 max_route_port = 11;
inline bool NodeInfo::has_max_route_port() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void NodeInfo::set_has_max_route_port() {
  _has_bits_[0] |= 0x00000800u;
}
inline void NodeInfo::clear_has_max_route_port() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void NodeInfo::clear_max_route_port() {
  max_route_port_ = 0u;
  clear_has_max_route_port();
}
inline ::google::protobuf::uint32 NodeInfo::max_route_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.NodeInfo.max_route_port)
  return max_route_port_;
}
inline void NodeInfo::set_max_route_port(::google::protobuf::uint32 value) {
  set_has_max_route_port();
  max_route_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.NodeInfo.max_route_port)
}

// optional uint32 node_weight = 12;
inline bool NodeInfo::has_node_weight() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void NodeInfo::set_has_node_weight() {
  _has_bits_[0] |= 0x00001000u;
}
inline void NodeInfo::clear_has_node_weight() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void NodeInfo::clear_node_weight() {
  node_weight_ = 0u;
  clear_has_node_weight();
}
inline ::google::protobuf::uint32 NodeInfo::node_weight() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.NodeInfo.node_weight)
  return node_weight_;
}
inline void NodeInfo::set_node_weight(::google::protobuf::uint32 value) {
  set_has_node_weight();
  node_weight_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.NodeInfo.node_weight)
}

// optional uint32 min_udp_port = 13;
inline bool NodeInfo::has_min_udp_port() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void NodeInfo::set_has_min_udp_port() {
  _has_bits_[0] |= 0x00002000u;
}
inline void NodeInfo::clear_has_min_udp_port() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void NodeInfo::clear_min_udp_port() {
  min_udp_port_ = 0u;
  clear_has_min_udp_port();
}
inline ::google::protobuf::uint32 NodeInfo::min_udp_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.NodeInfo.min_udp_port)
  return min_udp_port_;
}
inline void NodeInfo::set_min_udp_port(::google::protobuf::uint32 value) {
  set_has_min_udp_port();
  min_udp_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.NodeInfo.min_udp_port)
}

// optional uint32 max_udp_port = 14;
inline bool NodeInfo::has_max_udp_port() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void NodeInfo::set_has_max_udp_port() {
  _has_bits_[0] |= 0x00004000u;
}
inline void NodeInfo::clear_has_max_udp_port() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void NodeInfo::clear_max_udp_port() {
  max_udp_port_ = 0u;
  clear_has_max_udp_port();
}
inline ::google::protobuf::uint32 NodeInfo::max_udp_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.NodeInfo.max_udp_port)
  return max_udp_port_;
}
inline void NodeInfo::set_max_udp_port(::google::protobuf::uint32 value) {
  set_has_max_udp_port();
  max_udp_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.NodeInfo.max_udp_port)
}

// optional bytes node_tag = 15;
inline bool NodeInfo::has_node_tag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NodeInfo::set_has_node_tag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NodeInfo::clear_has_node_tag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NodeInfo::clear_node_tag() {
  node_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_node_tag();
}
inline const ::std::string& NodeInfo::node_tag() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.NodeInfo.node_tag)
  return node_tag_.GetNoArena();
}
inline void NodeInfo::set_node_tag(const ::std::string& value) {
  set_has_node_tag();
  node_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.NodeInfo.node_tag)
}
#if LANG_CXX11
inline void NodeInfo::set_node_tag(::std::string&& value) {
  set_has_node_tag();
  node_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.NodeInfo.node_tag)
}
#endif
inline void NodeInfo::set_node_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_node_tag();
  node_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.NodeInfo.node_tag)
}
inline void NodeInfo::set_node_tag(const void* value, size_t size) {
  set_has_node_tag();
  node_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.NodeInfo.node_tag)
}
inline ::std::string* NodeInfo::mutable_node_tag() {
  set_has_node_tag();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.NodeInfo.node_tag)
  return node_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeInfo::release_node_tag() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.NodeInfo.node_tag)
  if (!has_node_tag()) {
    return NULL;
  }
  clear_has_node_tag();
  return node_tag_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeInfo::set_allocated_node_tag(::std::string* node_tag) {
  if (node_tag != NULL) {
    set_has_node_tag();
  } else {
    clear_has_node_tag();
  }
  node_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node_tag);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.NodeInfo.node_tag)
}

// -------------------------------------------------------------------

// RefreshNeighborsResponse

// repeated .tenon.dht.protobuf.NodeInfo nodes = 1;
inline int RefreshNeighborsResponse::nodes_size() const {
  return nodes_.size();
}
inline void RefreshNeighborsResponse::clear_nodes() {
  nodes_.Clear();
}
inline ::tenon::dht::protobuf::NodeInfo* RefreshNeighborsResponse::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.RefreshNeighborsResponse.nodes)
  return nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tenon::dht::protobuf::NodeInfo >*
RefreshNeighborsResponse::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:tenon.dht.protobuf.RefreshNeighborsResponse.nodes)
  return &nodes_;
}
inline const ::tenon::dht::protobuf::NodeInfo& RefreshNeighborsResponse::nodes(int index) const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.RefreshNeighborsResponse.nodes)
  return nodes_.Get(index);
}
inline ::tenon::dht::protobuf::NodeInfo* RefreshNeighborsResponse::add_nodes() {
  // @@protoc_insertion_point(field_add:tenon.dht.protobuf.RefreshNeighborsResponse.nodes)
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tenon::dht::protobuf::NodeInfo >&
RefreshNeighborsResponse::nodes() const {
  // @@protoc_insertion_point(field_list:tenon.dht.protobuf.RefreshNeighborsResponse.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// HeartbeatRequest

// optional uint64 dht_key_hash = 1;
inline bool HeartbeatRequest::has_dht_key_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatRequest::set_has_dht_key_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartbeatRequest::clear_has_dht_key_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartbeatRequest::clear_dht_key_hash() {
  dht_key_hash_ = GOOGLE_ULONGLONG(0);
  clear_has_dht_key_hash();
}
inline ::google::protobuf::uint64 HeartbeatRequest::dht_key_hash() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.HeartbeatRequest.dht_key_hash)
  return dht_key_hash_;
}
inline void HeartbeatRequest::set_dht_key_hash(::google::protobuf::uint64 value) {
  set_has_dht_key_hash();
  dht_key_hash_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.HeartbeatRequest.dht_key_hash)
}

// -------------------------------------------------------------------

// HeartbeatResponse

// optional uint64 dht_key_hash = 1;
inline bool HeartbeatResponse::has_dht_key_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatResponse::set_has_dht_key_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartbeatResponse::clear_has_dht_key_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartbeatResponse::clear_dht_key_hash() {
  dht_key_hash_ = GOOGLE_ULONGLONG(0);
  clear_has_dht_key_hash();
}
inline ::google::protobuf::uint64 HeartbeatResponse::dht_key_hash() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.HeartbeatResponse.dht_key_hash)
  return dht_key_hash_;
}
inline void HeartbeatResponse::set_dht_key_hash(::google::protobuf::uint64 value) {
  set_has_dht_key_hash();
  dht_key_hash_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.HeartbeatResponse.dht_key_hash)
}

// -------------------------------------------------------------------

// ConnectReqeust

// optional bytes local_ip = 1;
inline bool ConnectReqeust::has_local_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectReqeust::set_has_local_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectReqeust::clear_has_local_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectReqeust::clear_local_ip() {
  local_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_local_ip();
}
inline const ::std::string& ConnectReqeust::local_ip() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.ConnectReqeust.local_ip)
  return local_ip_.GetNoArena();
}
inline void ConnectReqeust::set_local_ip(const ::std::string& value) {
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.ConnectReqeust.local_ip)
}
#if LANG_CXX11
inline void ConnectReqeust::set_local_ip(::std::string&& value) {
  set_has_local_ip();
  local_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.ConnectReqeust.local_ip)
}
#endif
inline void ConnectReqeust::set_local_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.ConnectReqeust.local_ip)
}
inline void ConnectReqeust::set_local_ip(const void* value, size_t size) {
  set_has_local_ip();
  local_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.ConnectReqeust.local_ip)
}
inline ::std::string* ConnectReqeust::mutable_local_ip() {
  set_has_local_ip();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.ConnectReqeust.local_ip)
  return local_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConnectReqeust::release_local_ip() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.ConnectReqeust.local_ip)
  if (!has_local_ip()) {
    return NULL;
  }
  clear_has_local_ip();
  return local_ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectReqeust::set_allocated_local_ip(::std::string* local_ip) {
  if (local_ip != NULL) {
    set_has_local_ip();
  } else {
    clear_has_local_ip();
  }
  local_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_ip);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.ConnectReqeust.local_ip)
}

// optional int32 local_port = 2;
inline bool ConnectReqeust::has_local_port() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ConnectReqeust::set_has_local_port() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ConnectReqeust::clear_has_local_port() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ConnectReqeust::clear_local_port() {
  local_port_ = 0;
  clear_has_local_port();
}
inline ::google::protobuf::int32 ConnectReqeust::local_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.ConnectReqeust.local_port)
  return local_port_;
}
inline void ConnectReqeust::set_local_port(::google::protobuf::int32 value) {
  set_has_local_port();
  local_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.ConnectReqeust.local_port)
}

// optional bytes public_ip = 3;
inline bool ConnectReqeust::has_public_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectReqeust::set_has_public_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectReqeust::clear_has_public_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectReqeust::clear_public_ip() {
  public_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_public_ip();
}
inline const ::std::string& ConnectReqeust::public_ip() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.ConnectReqeust.public_ip)
  return public_ip_.GetNoArena();
}
inline void ConnectReqeust::set_public_ip(const ::std::string& value) {
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.ConnectReqeust.public_ip)
}
#if LANG_CXX11
inline void ConnectReqeust::set_public_ip(::std::string&& value) {
  set_has_public_ip();
  public_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.ConnectReqeust.public_ip)
}
#endif
inline void ConnectReqeust::set_public_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.ConnectReqeust.public_ip)
}
inline void ConnectReqeust::set_public_ip(const void* value, size_t size) {
  set_has_public_ip();
  public_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.ConnectReqeust.public_ip)
}
inline ::std::string* ConnectReqeust::mutable_public_ip() {
  set_has_public_ip();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.ConnectReqeust.public_ip)
  return public_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConnectReqeust::release_public_ip() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.ConnectReqeust.public_ip)
  if (!has_public_ip()) {
    return NULL;
  }
  clear_has_public_ip();
  return public_ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectReqeust::set_allocated_public_ip(::std::string* public_ip) {
  if (public_ip != NULL) {
    set_has_public_ip();
  } else {
    clear_has_public_ip();
  }
  public_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_ip);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.ConnectReqeust.public_ip)
}

// optional int32 public_port = 4;
inline bool ConnectReqeust::has_public_port() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ConnectReqeust::set_has_public_port() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ConnectReqeust::clear_has_public_port() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ConnectReqeust::clear_public_port() {
  public_port_ = 0;
  clear_has_public_port();
}
inline ::google::protobuf::int32 ConnectReqeust::public_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.ConnectReqeust.public_port)
  return public_port_;
}
inline void ConnectReqeust::set_public_port(::google::protobuf::int32 value) {
  set_has_public_port();
  public_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.ConnectReqeust.public_port)
}

// optional int32 nat_type = 5;
inline bool ConnectReqeust::has_nat_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ConnectReqeust::set_has_nat_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ConnectReqeust::clear_has_nat_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ConnectReqeust::clear_nat_type() {
  nat_type_ = 0;
  clear_has_nat_type();
}
inline ::google::protobuf::int32 ConnectReqeust::nat_type() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.ConnectReqeust.nat_type)
  return nat_type_;
}
inline void ConnectReqeust::set_nat_type(::google::protobuf::int32 value) {
  set_has_nat_type();
  nat_type_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.ConnectReqeust.nat_type)
}

// optional bytes id = 6;
inline bool ConnectReqeust::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConnectReqeust::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConnectReqeust::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConnectReqeust::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& ConnectReqeust::id() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.ConnectReqeust.id)
  return id_.GetNoArena();
}
inline void ConnectReqeust::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.ConnectReqeust.id)
}
#if LANG_CXX11
inline void ConnectReqeust::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.ConnectReqeust.id)
}
#endif
inline void ConnectReqeust::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.ConnectReqeust.id)
}
inline void ConnectReqeust::set_id(const void* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.ConnectReqeust.id)
}
inline ::std::string* ConnectReqeust::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.ConnectReqeust.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConnectReqeust::release_id() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.ConnectReqeust.id)
  if (!has_id()) {
    return NULL;
  }
  clear_has_id();
  return id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectReqeust::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.ConnectReqeust.id)
}

// optional bytes dht_key = 7;
inline bool ConnectReqeust::has_dht_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConnectReqeust::set_has_dht_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConnectReqeust::clear_has_dht_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConnectReqeust::clear_dht_key() {
  dht_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dht_key();
}
inline const ::std::string& ConnectReqeust::dht_key() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.ConnectReqeust.dht_key)
  return dht_key_.GetNoArena();
}
inline void ConnectReqeust::set_dht_key(const ::std::string& value) {
  set_has_dht_key();
  dht_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.ConnectReqeust.dht_key)
}
#if LANG_CXX11
inline void ConnectReqeust::set_dht_key(::std::string&& value) {
  set_has_dht_key();
  dht_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.ConnectReqeust.dht_key)
}
#endif
inline void ConnectReqeust::set_dht_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dht_key();
  dht_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.ConnectReqeust.dht_key)
}
inline void ConnectReqeust::set_dht_key(const void* value, size_t size) {
  set_has_dht_key();
  dht_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.ConnectReqeust.dht_key)
}
inline ::std::string* ConnectReqeust::mutable_dht_key() {
  set_has_dht_key();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.ConnectReqeust.dht_key)
  return dht_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConnectReqeust::release_dht_key() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.ConnectReqeust.dht_key)
  if (!has_dht_key()) {
    return NULL;
  }
  clear_has_dht_key();
  return dht_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectReqeust::set_allocated_dht_key(::std::string* dht_key) {
  if (dht_key != NULL) {
    set_has_dht_key();
  } else {
    clear_has_dht_key();
  }
  dht_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dht_key);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.ConnectReqeust.dht_key)
}

// optional bool direct = 8;
inline bool ConnectReqeust::has_direct() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ConnectReqeust::set_has_direct() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ConnectReqeust::clear_has_direct() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ConnectReqeust::clear_direct() {
  direct_ = false;
  clear_has_direct();
}
inline bool ConnectReqeust::direct() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.ConnectReqeust.direct)
  return direct_;
}
inline void ConnectReqeust::set_direct(bool value) {
  set_has_direct();
  direct_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.ConnectReqeust.direct)
}

// optional uint32 min_svr_port = 9;
inline bool ConnectReqeust::has_min_svr_port() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ConnectReqeust::set_has_min_svr_port() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ConnectReqeust::clear_has_min_svr_port() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ConnectReqeust::clear_min_svr_port() {
  min_svr_port_ = 0u;
  clear_has_min_svr_port();
}
inline ::google::protobuf::uint32 ConnectReqeust::min_svr_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.ConnectReqeust.min_svr_port)
  return min_svr_port_;
}
inline void ConnectReqeust::set_min_svr_port(::google::protobuf::uint32 value) {
  set_has_min_svr_port();
  min_svr_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.ConnectReqeust.min_svr_port)
}

// optional uint32 max_svr_port = 10;
inline bool ConnectReqeust::has_max_svr_port() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ConnectReqeust::set_has_max_svr_port() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ConnectReqeust::clear_has_max_svr_port() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ConnectReqeust::clear_max_svr_port() {
  max_svr_port_ = 0u;
  clear_has_max_svr_port();
}
inline ::google::protobuf::uint32 ConnectReqeust::max_svr_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.ConnectReqeust.max_svr_port)
  return max_svr_port_;
}
inline void ConnectReqeust::set_max_svr_port(::google::protobuf::uint32 value) {
  set_has_max_svr_port();
  max_svr_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.ConnectReqeust.max_svr_port)
}

// optional uint32 min_route_port = 11;
inline bool ConnectReqeust::has_min_route_port() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ConnectReqeust::set_has_min_route_port() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ConnectReqeust::clear_has_min_route_port() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ConnectReqeust::clear_min_route_port() {
  min_route_port_ = 0u;
  clear_has_min_route_port();
}
inline ::google::protobuf::uint32 ConnectReqeust::min_route_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.ConnectReqeust.min_route_port)
  return min_route_port_;
}
inline void ConnectReqeust::set_min_route_port(::google::protobuf::uint32 value) {
  set_has_min_route_port();
  min_route_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.ConnectReqeust.min_route_port)
}

// optional uint32 max_route_port = 12;
inline bool ConnectReqeust::has_max_route_port() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ConnectReqeust::set_has_max_route_port() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ConnectReqeust::clear_has_max_route_port() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ConnectReqeust::clear_max_route_port() {
  max_route_port_ = 0u;
  clear_has_max_route_port();
}
inline ::google::protobuf::uint32 ConnectReqeust::max_route_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.ConnectReqeust.max_route_port)
  return max_route_port_;
}
inline void ConnectReqeust::set_max_route_port(::google::protobuf::uint32 value) {
  set_has_max_route_port();
  max_route_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.ConnectReqeust.max_route_port)
}

// optional uint32 node_weight = 13;
inline bool ConnectReqeust::has_node_weight() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ConnectReqeust::set_has_node_weight() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ConnectReqeust::clear_has_node_weight() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ConnectReqeust::clear_node_weight() {
  node_weight_ = 0u;
  clear_has_node_weight();
}
inline ::google::protobuf::uint32 ConnectReqeust::node_weight() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.ConnectReqeust.node_weight)
  return node_weight_;
}
inline void ConnectReqeust::set_node_weight(::google::protobuf::uint32 value) {
  set_has_node_weight();
  node_weight_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.ConnectReqeust.node_weight)
}

// optional uint32 min_udp_port = 14;
inline bool ConnectReqeust::has_min_udp_port() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ConnectReqeust::set_has_min_udp_port() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ConnectReqeust::clear_has_min_udp_port() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ConnectReqeust::clear_min_udp_port() {
  min_udp_port_ = 0u;
  clear_has_min_udp_port();
}
inline ::google::protobuf::uint32 ConnectReqeust::min_udp_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.ConnectReqeust.min_udp_port)
  return min_udp_port_;
}
inline void ConnectReqeust::set_min_udp_port(::google::protobuf::uint32 value) {
  set_has_min_udp_port();
  min_udp_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.ConnectReqeust.min_udp_port)
}

// optional uint32 max_udp_port = 15;
inline bool ConnectReqeust::has_max_udp_port() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ConnectReqeust::set_has_max_udp_port() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ConnectReqeust::clear_has_max_udp_port() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ConnectReqeust::clear_max_udp_port() {
  max_udp_port_ = 0u;
  clear_has_max_udp_port();
}
inline ::google::protobuf::uint32 ConnectReqeust::max_udp_port() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.ConnectReqeust.max_udp_port)
  return max_udp_port_;
}
inline void ConnectReqeust::set_max_udp_port(::google::protobuf::uint32 value) {
  set_has_max_udp_port();
  max_udp_port_ = value;
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.ConnectReqeust.max_udp_port)
}

// optional bytes node_tag = 16;
inline bool ConnectReqeust::has_node_tag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ConnectReqeust::set_has_node_tag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ConnectReqeust::clear_has_node_tag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ConnectReqeust::clear_node_tag() {
  node_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_node_tag();
}
inline const ::std::string& ConnectReqeust::node_tag() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.ConnectReqeust.node_tag)
  return node_tag_.GetNoArena();
}
inline void ConnectReqeust::set_node_tag(const ::std::string& value) {
  set_has_node_tag();
  node_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.ConnectReqeust.node_tag)
}
#if LANG_CXX11
inline void ConnectReqeust::set_node_tag(::std::string&& value) {
  set_has_node_tag();
  node_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.ConnectReqeust.node_tag)
}
#endif
inline void ConnectReqeust::set_node_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_node_tag();
  node_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.ConnectReqeust.node_tag)
}
inline void ConnectReqeust::set_node_tag(const void* value, size_t size) {
  set_has_node_tag();
  node_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.ConnectReqeust.node_tag)
}
inline ::std::string* ConnectReqeust::mutable_node_tag() {
  set_has_node_tag();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.ConnectReqeust.node_tag)
  return node_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConnectReqeust::release_node_tag() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.ConnectReqeust.node_tag)
  if (!has_node_tag()) {
    return NULL;
  }
  clear_has_node_tag();
  return node_tag_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectReqeust::set_allocated_node_tag(::std::string* node_tag) {
  if (node_tag != NULL) {
    set_has_node_tag();
  } else {
    clear_has_node_tag();
  }
  node_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node_tag);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.ConnectReqeust.node_tag)
}

// -------------------------------------------------------------------

// DhtMessage

// optional .tenon.dht.protobuf.BootstrapRequest bootstrap_req = 1;
inline bool DhtMessage::has_bootstrap_req() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DhtMessage::set_has_bootstrap_req() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DhtMessage::clear_has_bootstrap_req() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DhtMessage::clear_bootstrap_req() {
  if (bootstrap_req_ != NULL) bootstrap_req_->Clear();
  clear_has_bootstrap_req();
}
inline const ::tenon::dht::protobuf::BootstrapRequest& DhtMessage::_internal_bootstrap_req() const {
  return *bootstrap_req_;
}
inline const ::tenon::dht::protobuf::BootstrapRequest& DhtMessage::bootstrap_req() const {
  const ::tenon::dht::protobuf::BootstrapRequest* p = bootstrap_req_;
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.DhtMessage.bootstrap_req)
  return p != NULL ? *p : *reinterpret_cast<const ::tenon::dht::protobuf::BootstrapRequest*>(
      &::tenon::dht::protobuf::_BootstrapRequest_default_instance_);
}
inline ::tenon::dht::protobuf::BootstrapRequest* DhtMessage::release_bootstrap_req() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.DhtMessage.bootstrap_req)
  clear_has_bootstrap_req();
  ::tenon::dht::protobuf::BootstrapRequest* temp = bootstrap_req_;
  bootstrap_req_ = NULL;
  return temp;
}
inline ::tenon::dht::protobuf::BootstrapRequest* DhtMessage::mutable_bootstrap_req() {
  set_has_bootstrap_req();
  if (bootstrap_req_ == NULL) {
    auto* p = CreateMaybeMessage<::tenon::dht::protobuf::BootstrapRequest>(GetArenaNoVirtual());
    bootstrap_req_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.DhtMessage.bootstrap_req)
  return bootstrap_req_;
}
inline void DhtMessage::set_allocated_bootstrap_req(::tenon::dht::protobuf::BootstrapRequest* bootstrap_req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bootstrap_req_;
  }
  if (bootstrap_req) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bootstrap_req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bootstrap_req, submessage_arena);
    }
    set_has_bootstrap_req();
  } else {
    clear_has_bootstrap_req();
  }
  bootstrap_req_ = bootstrap_req;
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.DhtMessage.bootstrap_req)
}

// optional .tenon.dht.protobuf.BootstrapResponse bootstrap_res = 2;
inline bool DhtMessage::has_bootstrap_res() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DhtMessage::set_has_bootstrap_res() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DhtMessage::clear_has_bootstrap_res() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DhtMessage::clear_bootstrap_res() {
  if (bootstrap_res_ != NULL) bootstrap_res_->Clear();
  clear_has_bootstrap_res();
}
inline const ::tenon::dht::protobuf::BootstrapResponse& DhtMessage::_internal_bootstrap_res() const {
  return *bootstrap_res_;
}
inline const ::tenon::dht::protobuf::BootstrapResponse& DhtMessage::bootstrap_res() const {
  const ::tenon::dht::protobuf::BootstrapResponse* p = bootstrap_res_;
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.DhtMessage.bootstrap_res)
  return p != NULL ? *p : *reinterpret_cast<const ::tenon::dht::protobuf::BootstrapResponse*>(
      &::tenon::dht::protobuf::_BootstrapResponse_default_instance_);
}
inline ::tenon::dht::protobuf::BootstrapResponse* DhtMessage::release_bootstrap_res() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.DhtMessage.bootstrap_res)
  clear_has_bootstrap_res();
  ::tenon::dht::protobuf::BootstrapResponse* temp = bootstrap_res_;
  bootstrap_res_ = NULL;
  return temp;
}
inline ::tenon::dht::protobuf::BootstrapResponse* DhtMessage::mutable_bootstrap_res() {
  set_has_bootstrap_res();
  if (bootstrap_res_ == NULL) {
    auto* p = CreateMaybeMessage<::tenon::dht::protobuf::BootstrapResponse>(GetArenaNoVirtual());
    bootstrap_res_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.DhtMessage.bootstrap_res)
  return bootstrap_res_;
}
inline void DhtMessage::set_allocated_bootstrap_res(::tenon::dht::protobuf::BootstrapResponse* bootstrap_res) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bootstrap_res_;
  }
  if (bootstrap_res) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bootstrap_res = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bootstrap_res, submessage_arena);
    }
    set_has_bootstrap_res();
  } else {
    clear_has_bootstrap_res();
  }
  bootstrap_res_ = bootstrap_res;
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.DhtMessage.bootstrap_res)
}

// optional .tenon.dht.protobuf.RefreshNeighborsRequest refresh_neighbors_req = 3;
inline bool DhtMessage::has_refresh_neighbors_req() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DhtMessage::set_has_refresh_neighbors_req() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DhtMessage::clear_has_refresh_neighbors_req() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DhtMessage::clear_refresh_neighbors_req() {
  if (refresh_neighbors_req_ != NULL) refresh_neighbors_req_->Clear();
  clear_has_refresh_neighbors_req();
}
inline const ::tenon::dht::protobuf::RefreshNeighborsRequest& DhtMessage::_internal_refresh_neighbors_req() const {
  return *refresh_neighbors_req_;
}
inline const ::tenon::dht::protobuf::RefreshNeighborsRequest& DhtMessage::refresh_neighbors_req() const {
  const ::tenon::dht::protobuf::RefreshNeighborsRequest* p = refresh_neighbors_req_;
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.DhtMessage.refresh_neighbors_req)
  return p != NULL ? *p : *reinterpret_cast<const ::tenon::dht::protobuf::RefreshNeighborsRequest*>(
      &::tenon::dht::protobuf::_RefreshNeighborsRequest_default_instance_);
}
inline ::tenon::dht::protobuf::RefreshNeighborsRequest* DhtMessage::release_refresh_neighbors_req() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.DhtMessage.refresh_neighbors_req)
  clear_has_refresh_neighbors_req();
  ::tenon::dht::protobuf::RefreshNeighborsRequest* temp = refresh_neighbors_req_;
  refresh_neighbors_req_ = NULL;
  return temp;
}
inline ::tenon::dht::protobuf::RefreshNeighborsRequest* DhtMessage::mutable_refresh_neighbors_req() {
  set_has_refresh_neighbors_req();
  if (refresh_neighbors_req_ == NULL) {
    auto* p = CreateMaybeMessage<::tenon::dht::protobuf::RefreshNeighborsRequest>(GetArenaNoVirtual());
    refresh_neighbors_req_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.DhtMessage.refresh_neighbors_req)
  return refresh_neighbors_req_;
}
inline void DhtMessage::set_allocated_refresh_neighbors_req(::tenon::dht::protobuf::RefreshNeighborsRequest* refresh_neighbors_req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete refresh_neighbors_req_;
  }
  if (refresh_neighbors_req) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      refresh_neighbors_req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, refresh_neighbors_req, submessage_arena);
    }
    set_has_refresh_neighbors_req();
  } else {
    clear_has_refresh_neighbors_req();
  }
  refresh_neighbors_req_ = refresh_neighbors_req;
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.DhtMessage.refresh_neighbors_req)
}

// optional .tenon.dht.protobuf.RefreshNeighborsResponse refresh_neighbors_res = 4;
inline bool DhtMessage::has_refresh_neighbors_res() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DhtMessage::set_has_refresh_neighbors_res() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DhtMessage::clear_has_refresh_neighbors_res() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DhtMessage::clear_refresh_neighbors_res() {
  if (refresh_neighbors_res_ != NULL) refresh_neighbors_res_->Clear();
  clear_has_refresh_neighbors_res();
}
inline const ::tenon::dht::protobuf::RefreshNeighborsResponse& DhtMessage::_internal_refresh_neighbors_res() const {
  return *refresh_neighbors_res_;
}
inline const ::tenon::dht::protobuf::RefreshNeighborsResponse& DhtMessage::refresh_neighbors_res() const {
  const ::tenon::dht::protobuf::RefreshNeighborsResponse* p = refresh_neighbors_res_;
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.DhtMessage.refresh_neighbors_res)
  return p != NULL ? *p : *reinterpret_cast<const ::tenon::dht::protobuf::RefreshNeighborsResponse*>(
      &::tenon::dht::protobuf::_RefreshNeighborsResponse_default_instance_);
}
inline ::tenon::dht::protobuf::RefreshNeighborsResponse* DhtMessage::release_refresh_neighbors_res() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.DhtMessage.refresh_neighbors_res)
  clear_has_refresh_neighbors_res();
  ::tenon::dht::protobuf::RefreshNeighborsResponse* temp = refresh_neighbors_res_;
  refresh_neighbors_res_ = NULL;
  return temp;
}
inline ::tenon::dht::protobuf::RefreshNeighborsResponse* DhtMessage::mutable_refresh_neighbors_res() {
  set_has_refresh_neighbors_res();
  if (refresh_neighbors_res_ == NULL) {
    auto* p = CreateMaybeMessage<::tenon::dht::protobuf::RefreshNeighborsResponse>(GetArenaNoVirtual());
    refresh_neighbors_res_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.DhtMessage.refresh_neighbors_res)
  return refresh_neighbors_res_;
}
inline void DhtMessage::set_allocated_refresh_neighbors_res(::tenon::dht::protobuf::RefreshNeighborsResponse* refresh_neighbors_res) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete refresh_neighbors_res_;
  }
  if (refresh_neighbors_res) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      refresh_neighbors_res = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, refresh_neighbors_res, submessage_arena);
    }
    set_has_refresh_neighbors_res();
  } else {
    clear_has_refresh_neighbors_res();
  }
  refresh_neighbors_res_ = refresh_neighbors_res;
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.DhtMessage.refresh_neighbors_res)
}

// optional .tenon.dht.protobuf.ConnectReqeust connect_req = 5;
inline bool DhtMessage::has_connect_req() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DhtMessage::set_has_connect_req() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DhtMessage::clear_has_connect_req() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DhtMessage::clear_connect_req() {
  if (connect_req_ != NULL) connect_req_->Clear();
  clear_has_connect_req();
}
inline const ::tenon::dht::protobuf::ConnectReqeust& DhtMessage::_internal_connect_req() const {
  return *connect_req_;
}
inline const ::tenon::dht::protobuf::ConnectReqeust& DhtMessage::connect_req() const {
  const ::tenon::dht::protobuf::ConnectReqeust* p = connect_req_;
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.DhtMessage.connect_req)
  return p != NULL ? *p : *reinterpret_cast<const ::tenon::dht::protobuf::ConnectReqeust*>(
      &::tenon::dht::protobuf::_ConnectReqeust_default_instance_);
}
inline ::tenon::dht::protobuf::ConnectReqeust* DhtMessage::release_connect_req() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.DhtMessage.connect_req)
  clear_has_connect_req();
  ::tenon::dht::protobuf::ConnectReqeust* temp = connect_req_;
  connect_req_ = NULL;
  return temp;
}
inline ::tenon::dht::protobuf::ConnectReqeust* DhtMessage::mutable_connect_req() {
  set_has_connect_req();
  if (connect_req_ == NULL) {
    auto* p = CreateMaybeMessage<::tenon::dht::protobuf::ConnectReqeust>(GetArenaNoVirtual());
    connect_req_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.DhtMessage.connect_req)
  return connect_req_;
}
inline void DhtMessage::set_allocated_connect_req(::tenon::dht::protobuf::ConnectReqeust* connect_req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete connect_req_;
  }
  if (connect_req) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      connect_req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connect_req, submessage_arena);
    }
    set_has_connect_req();
  } else {
    clear_has_connect_req();
  }
  connect_req_ = connect_req;
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.DhtMessage.connect_req)
}

// optional .tenon.dht.protobuf.HeartbeatRequest heartbeat_req = 6;
inline bool DhtMessage::has_heartbeat_req() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DhtMessage::set_has_heartbeat_req() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DhtMessage::clear_has_heartbeat_req() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DhtMessage::clear_heartbeat_req() {
  if (heartbeat_req_ != NULL) heartbeat_req_->Clear();
  clear_has_heartbeat_req();
}
inline const ::tenon::dht::protobuf::HeartbeatRequest& DhtMessage::_internal_heartbeat_req() const {
  return *heartbeat_req_;
}
inline const ::tenon::dht::protobuf::HeartbeatRequest& DhtMessage::heartbeat_req() const {
  const ::tenon::dht::protobuf::HeartbeatRequest* p = heartbeat_req_;
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.DhtMessage.heartbeat_req)
  return p != NULL ? *p : *reinterpret_cast<const ::tenon::dht::protobuf::HeartbeatRequest*>(
      &::tenon::dht::protobuf::_HeartbeatRequest_default_instance_);
}
inline ::tenon::dht::protobuf::HeartbeatRequest* DhtMessage::release_heartbeat_req() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.DhtMessage.heartbeat_req)
  clear_has_heartbeat_req();
  ::tenon::dht::protobuf::HeartbeatRequest* temp = heartbeat_req_;
  heartbeat_req_ = NULL;
  return temp;
}
inline ::tenon::dht::protobuf::HeartbeatRequest* DhtMessage::mutable_heartbeat_req() {
  set_has_heartbeat_req();
  if (heartbeat_req_ == NULL) {
    auto* p = CreateMaybeMessage<::tenon::dht::protobuf::HeartbeatRequest>(GetArenaNoVirtual());
    heartbeat_req_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.DhtMessage.heartbeat_req)
  return heartbeat_req_;
}
inline void DhtMessage::set_allocated_heartbeat_req(::tenon::dht::protobuf::HeartbeatRequest* heartbeat_req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete heartbeat_req_;
  }
  if (heartbeat_req) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      heartbeat_req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, heartbeat_req, submessage_arena);
    }
    set_has_heartbeat_req();
  } else {
    clear_has_heartbeat_req();
  }
  heartbeat_req_ = heartbeat_req;
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.DhtMessage.heartbeat_req)
}

// optional .tenon.dht.protobuf.HeartbeatResponse heartbeat_res = 7;
inline bool DhtMessage::has_heartbeat_res() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DhtMessage::set_has_heartbeat_res() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DhtMessage::clear_has_heartbeat_res() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DhtMessage::clear_heartbeat_res() {
  if (heartbeat_res_ != NULL) heartbeat_res_->Clear();
  clear_has_heartbeat_res();
}
inline const ::tenon::dht::protobuf::HeartbeatResponse& DhtMessage::_internal_heartbeat_res() const {
  return *heartbeat_res_;
}
inline const ::tenon::dht::protobuf::HeartbeatResponse& DhtMessage::heartbeat_res() const {
  const ::tenon::dht::protobuf::HeartbeatResponse* p = heartbeat_res_;
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.DhtMessage.heartbeat_res)
  return p != NULL ? *p : *reinterpret_cast<const ::tenon::dht::protobuf::HeartbeatResponse*>(
      &::tenon::dht::protobuf::_HeartbeatResponse_default_instance_);
}
inline ::tenon::dht::protobuf::HeartbeatResponse* DhtMessage::release_heartbeat_res() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.DhtMessage.heartbeat_res)
  clear_has_heartbeat_res();
  ::tenon::dht::protobuf::HeartbeatResponse* temp = heartbeat_res_;
  heartbeat_res_ = NULL;
  return temp;
}
inline ::tenon::dht::protobuf::HeartbeatResponse* DhtMessage::mutable_heartbeat_res() {
  set_has_heartbeat_res();
  if (heartbeat_res_ == NULL) {
    auto* p = CreateMaybeMessage<::tenon::dht::protobuf::HeartbeatResponse>(GetArenaNoVirtual());
    heartbeat_res_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.DhtMessage.heartbeat_res)
  return heartbeat_res_;
}
inline void DhtMessage::set_allocated_heartbeat_res(::tenon::dht::protobuf::HeartbeatResponse* heartbeat_res) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete heartbeat_res_;
  }
  if (heartbeat_res) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      heartbeat_res = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, heartbeat_res, submessage_arena);
    }
    set_has_heartbeat_res();
  } else {
    clear_has_heartbeat_res();
  }
  heartbeat_res_ = heartbeat_res;
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.DhtMessage.heartbeat_res)
}

// repeated uint32 networks = 8;
inline int DhtMessage::networks_size() const {
  return networks_.size();
}
inline void DhtMessage::clear_networks() {
  networks_.Clear();
}
inline ::google::protobuf::uint32 DhtMessage::networks(int index) const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.DhtMessage.networks)
  return networks_.Get(index);
}
inline void DhtMessage::set_networks(int index, ::google::protobuf::uint32 value) {
  networks_.Set(index, value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.DhtMessage.networks)
}
inline void DhtMessage::add_networks(::google::protobuf::uint32 value) {
  networks_.Add(value);
  // @@protoc_insertion_point(field_add:tenon.dht.protobuf.DhtMessage.networks)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
DhtMessage::networks() const {
  // @@protoc_insertion_point(field_list:tenon.dht.protobuf.DhtMessage.networks)
  return networks_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
DhtMessage::mutable_networks() {
  // @@protoc_insertion_point(field_mutable_list:tenon.dht.protobuf.DhtMessage.networks)
  return &networks_;
}

// optional bytes enc_data = 9;
inline bool DhtMessage::has_enc_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DhtMessage::set_has_enc_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DhtMessage::clear_has_enc_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DhtMessage::clear_enc_data() {
  enc_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_enc_data();
}
inline const ::std::string& DhtMessage::enc_data() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.DhtMessage.enc_data)
  return enc_data_.GetNoArena();
}
inline void DhtMessage::set_enc_data(const ::std::string& value) {
  set_has_enc_data();
  enc_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.DhtMessage.enc_data)
}
#if LANG_CXX11
inline void DhtMessage::set_enc_data(::std::string&& value) {
  set_has_enc_data();
  enc_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.DhtMessage.enc_data)
}
#endif
inline void DhtMessage::set_enc_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_enc_data();
  enc_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.DhtMessage.enc_data)
}
inline void DhtMessage::set_enc_data(const void* value, size_t size) {
  set_has_enc_data();
  enc_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.DhtMessage.enc_data)
}
inline ::std::string* DhtMessage::mutable_enc_data() {
  set_has_enc_data();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.DhtMessage.enc_data)
  return enc_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DhtMessage::release_enc_data() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.DhtMessage.enc_data)
  if (!has_enc_data()) {
    return NULL;
  }
  clear_has_enc_data();
  return enc_data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DhtMessage::set_allocated_enc_data(::std::string* enc_data) {
  if (enc_data != NULL) {
    set_has_enc_data();
  } else {
    clear_has_enc_data();
  }
  enc_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), enc_data);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.DhtMessage.enc_data)
}

// optional bytes sign_ch = 10;
inline bool DhtMessage::has_sign_ch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DhtMessage::set_has_sign_ch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DhtMessage::clear_has_sign_ch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DhtMessage::clear_sign_ch() {
  sign_ch_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sign_ch();
}
inline const ::std::string& DhtMessage::sign_ch() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.DhtMessage.sign_ch)
  return sign_ch_.GetNoArena();
}
inline void DhtMessage::set_sign_ch(const ::std::string& value) {
  set_has_sign_ch();
  sign_ch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.DhtMessage.sign_ch)
}
#if LANG_CXX11
inline void DhtMessage::set_sign_ch(::std::string&& value) {
  set_has_sign_ch();
  sign_ch_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.DhtMessage.sign_ch)
}
#endif
inline void DhtMessage::set_sign_ch(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sign_ch();
  sign_ch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.DhtMessage.sign_ch)
}
inline void DhtMessage::set_sign_ch(const void* value, size_t size) {
  set_has_sign_ch();
  sign_ch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.DhtMessage.sign_ch)
}
inline ::std::string* DhtMessage::mutable_sign_ch() {
  set_has_sign_ch();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.DhtMessage.sign_ch)
  return sign_ch_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DhtMessage::release_sign_ch() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.DhtMessage.sign_ch)
  if (!has_sign_ch()) {
    return NULL;
  }
  clear_has_sign_ch();
  return sign_ch_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DhtMessage::set_allocated_sign_ch(::std::string* sign_ch) {
  if (sign_ch != NULL) {
    set_has_sign_ch();
  } else {
    clear_has_sign_ch();
  }
  sign_ch_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sign_ch);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.DhtMessage.sign_ch)
}

// optional bytes sign_re = 11;
inline bool DhtMessage::has_sign_re() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DhtMessage::set_has_sign_re() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DhtMessage::clear_has_sign_re() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DhtMessage::clear_sign_re() {
  sign_re_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sign_re();
}
inline const ::std::string& DhtMessage::sign_re() const {
  // @@protoc_insertion_point(field_get:tenon.dht.protobuf.DhtMessage.sign_re)
  return sign_re_.GetNoArena();
}
inline void DhtMessage::set_sign_re(const ::std::string& value) {
  set_has_sign_re();
  sign_re_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tenon.dht.protobuf.DhtMessage.sign_re)
}
#if LANG_CXX11
inline void DhtMessage::set_sign_re(::std::string&& value) {
  set_has_sign_re();
  sign_re_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tenon.dht.protobuf.DhtMessage.sign_re)
}
#endif
inline void DhtMessage::set_sign_re(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sign_re();
  sign_re_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tenon.dht.protobuf.DhtMessage.sign_re)
}
inline void DhtMessage::set_sign_re(const void* value, size_t size) {
  set_has_sign_re();
  sign_re_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tenon.dht.protobuf.DhtMessage.sign_re)
}
inline ::std::string* DhtMessage::mutable_sign_re() {
  set_has_sign_re();
  // @@protoc_insertion_point(field_mutable:tenon.dht.protobuf.DhtMessage.sign_re)
  return sign_re_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DhtMessage::release_sign_re() {
  // @@protoc_insertion_point(field_release:tenon.dht.protobuf.DhtMessage.sign_re)
  if (!has_sign_re()) {
    return NULL;
  }
  clear_has_sign_re();
  return sign_re_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DhtMessage::set_allocated_sign_re(::std::string* sign_re) {
  if (sign_re != NULL) {
    set_has_sign_re();
  } else {
    clear_has_sign_re();
  }
  sign_re_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sign_re);
  // @@protoc_insertion_point(field_set_allocated:tenon.dht.protobuf.DhtMessage.sign_re)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace dht
}  // namespace tenon

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_dht_2eproto
