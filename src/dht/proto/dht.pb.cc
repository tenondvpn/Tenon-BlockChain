// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dht.proto

#include "dht.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// This is a temporary google only hack
#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
#include "third_party/protobuf/version.h"
#endif
// @@protoc_insertion_point(includes)

namespace protobuf_dht_2eproto {
extern PROTOBUF_INTERNAL_EXPORT_protobuf_dht_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_BootstrapRequest;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_dht_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_ConnectReqeust;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_dht_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_HeartbeatRequest;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_dht_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_HeartbeatResponse;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_dht_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_NodeInfo;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_dht_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_RefreshNeighborsRequest;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_dht_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_RelayVpnNodeInfo;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_dht_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_BootstrapResponse;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_dht_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_InitMessage;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_dht_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_RefreshNeighborsResponse;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_dht_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_VpnNodeInfo;
}  // namespace protobuf_dht_2eproto
namespace tenon {
namespace dht {
namespace protobuf {
class BootstrapRequestDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<BootstrapRequest>
      _instance;
} _BootstrapRequest_default_instance_;
class RelayVpnNodeInfoDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<RelayVpnNodeInfo>
      _instance;
} _RelayVpnNodeInfo_default_instance_;
class VpnNodeInfoDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<VpnNodeInfo>
      _instance;
} _VpnNodeInfo_default_instance_;
class InitMessageDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<InitMessage>
      _instance;
} _InitMessage_default_instance_;
class BootstrapResponseDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<BootstrapResponse>
      _instance;
} _BootstrapResponse_default_instance_;
class RefreshNeighborsRequestDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<RefreshNeighborsRequest>
      _instance;
} _RefreshNeighborsRequest_default_instance_;
class NodeInfoDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<NodeInfo>
      _instance;
} _NodeInfo_default_instance_;
class RefreshNeighborsResponseDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<RefreshNeighborsResponse>
      _instance;
} _RefreshNeighborsResponse_default_instance_;
class HeartbeatRequestDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<HeartbeatRequest>
      _instance;
} _HeartbeatRequest_default_instance_;
class HeartbeatResponseDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<HeartbeatResponse>
      _instance;
} _HeartbeatResponse_default_instance_;
class ConnectReqeustDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ConnectReqeust>
      _instance;
} _ConnectReqeust_default_instance_;
class DhtMessageDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<DhtMessage>
      _instance;
} _DhtMessage_default_instance_;
}  // namespace protobuf
}  // namespace dht
}  // namespace tenon
namespace protobuf_dht_2eproto {
static void InitDefaultsBootstrapRequest() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::tenon::dht::protobuf::_BootstrapRequest_default_instance_;
    new (ptr) ::tenon::dht::protobuf::BootstrapRequest();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::tenon::dht::protobuf::BootstrapRequest::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_BootstrapRequest =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsBootstrapRequest}, {}};

static void InitDefaultsRelayVpnNodeInfo() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::tenon::dht::protobuf::_RelayVpnNodeInfo_default_instance_;
    new (ptr) ::tenon::dht::protobuf::RelayVpnNodeInfo();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::tenon::dht::protobuf::RelayVpnNodeInfo::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_RelayVpnNodeInfo =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsRelayVpnNodeInfo}, {}};

static void InitDefaultsVpnNodeInfo() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::tenon::dht::protobuf::_VpnNodeInfo_default_instance_;
    new (ptr) ::tenon::dht::protobuf::VpnNodeInfo();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::tenon::dht::protobuf::VpnNodeInfo::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_VpnNodeInfo =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsVpnNodeInfo}, {
      &protobuf_dht_2eproto::scc_info_RelayVpnNodeInfo.base,}};

static void InitDefaultsInitMessage() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::tenon::dht::protobuf::_InitMessage_default_instance_;
    new (ptr) ::tenon::dht::protobuf::InitMessage();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::tenon::dht::protobuf::InitMessage::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_InitMessage =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsInitMessage}, {
      &protobuf_dht_2eproto::scc_info_VpnNodeInfo.base,}};

static void InitDefaultsBootstrapResponse() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::tenon::dht::protobuf::_BootstrapResponse_default_instance_;
    new (ptr) ::tenon::dht::protobuf::BootstrapResponse();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::tenon::dht::protobuf::BootstrapResponse::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_BootstrapResponse =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsBootstrapResponse}, {
      &protobuf_dht_2eproto::scc_info_InitMessage.base,}};

static void InitDefaultsRefreshNeighborsRequest() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::tenon::dht::protobuf::_RefreshNeighborsRequest_default_instance_;
    new (ptr) ::tenon::dht::protobuf::RefreshNeighborsRequest();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::tenon::dht::protobuf::RefreshNeighborsRequest::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_RefreshNeighborsRequest =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsRefreshNeighborsRequest}, {}};

static void InitDefaultsNodeInfo() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::tenon::dht::protobuf::_NodeInfo_default_instance_;
    new (ptr) ::tenon::dht::protobuf::NodeInfo();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::tenon::dht::protobuf::NodeInfo::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_NodeInfo =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsNodeInfo}, {}};

static void InitDefaultsRefreshNeighborsResponse() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::tenon::dht::protobuf::_RefreshNeighborsResponse_default_instance_;
    new (ptr) ::tenon::dht::protobuf::RefreshNeighborsResponse();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::tenon::dht::protobuf::RefreshNeighborsResponse::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_RefreshNeighborsResponse =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsRefreshNeighborsResponse}, {
      &protobuf_dht_2eproto::scc_info_NodeInfo.base,}};

static void InitDefaultsHeartbeatRequest() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::tenon::dht::protobuf::_HeartbeatRequest_default_instance_;
    new (ptr) ::tenon::dht::protobuf::HeartbeatRequest();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::tenon::dht::protobuf::HeartbeatRequest::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_HeartbeatRequest =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsHeartbeatRequest}, {}};

static void InitDefaultsHeartbeatResponse() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::tenon::dht::protobuf::_HeartbeatResponse_default_instance_;
    new (ptr) ::tenon::dht::protobuf::HeartbeatResponse();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::tenon::dht::protobuf::HeartbeatResponse::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_HeartbeatResponse =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsHeartbeatResponse}, {}};

static void InitDefaultsConnectReqeust() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::tenon::dht::protobuf::_ConnectReqeust_default_instance_;
    new (ptr) ::tenon::dht::protobuf::ConnectReqeust();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::tenon::dht::protobuf::ConnectReqeust::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_ConnectReqeust =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsConnectReqeust}, {}};

static void InitDefaultsDhtMessage() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::tenon::dht::protobuf::_DhtMessage_default_instance_;
    new (ptr) ::tenon::dht::protobuf::DhtMessage();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::tenon::dht::protobuf::DhtMessage::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<7> scc_info_DhtMessage =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 7, InitDefaultsDhtMessage}, {
      &protobuf_dht_2eproto::scc_info_BootstrapRequest.base,
      &protobuf_dht_2eproto::scc_info_BootstrapResponse.base,
      &protobuf_dht_2eproto::scc_info_RefreshNeighborsRequest.base,
      &protobuf_dht_2eproto::scc_info_RefreshNeighborsResponse.base,
      &protobuf_dht_2eproto::scc_info_ConnectReqeust.base,
      &protobuf_dht_2eproto::scc_info_HeartbeatRequest.base,
      &protobuf_dht_2eproto::scc_info_HeartbeatResponse.base,}};

void InitDefaults() {
  ::google::protobuf::internal::InitSCC(&scc_info_BootstrapRequest.base);
  ::google::protobuf::internal::InitSCC(&scc_info_RelayVpnNodeInfo.base);
  ::google::protobuf::internal::InitSCC(&scc_info_VpnNodeInfo.base);
  ::google::protobuf::internal::InitSCC(&scc_info_InitMessage.base);
  ::google::protobuf::internal::InitSCC(&scc_info_BootstrapResponse.base);
  ::google::protobuf::internal::InitSCC(&scc_info_RefreshNeighborsRequest.base);
  ::google::protobuf::internal::InitSCC(&scc_info_NodeInfo.base);
  ::google::protobuf::internal::InitSCC(&scc_info_RefreshNeighborsResponse.base);
  ::google::protobuf::internal::InitSCC(&scc_info_HeartbeatRequest.base);
  ::google::protobuf::internal::InitSCC(&scc_info_HeartbeatResponse.base);
  ::google::protobuf::internal::InitSCC(&scc_info_ConnectReqeust.base);
  ::google::protobuf::internal::InitSCC(&scc_info_DhtMessage.base);
}

::google::protobuf::Metadata file_level_metadata[12];

const ::google::protobuf::uint32 TableStruct::offsets[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapRequest, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapRequest, local_ip_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapRequest, local_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapRequest, nat_type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapRequest, node_id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapRequest, get_init_msg_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapRequest, min_svr_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapRequest, max_svr_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapRequest, min_route_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapRequest, max_route_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapRequest, public_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapRequest, node_weight_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapRequest, min_udp_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapRequest, max_udp_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapRequest, version_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapRequest, uid_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapRequest, node_tag_),
  0,
  4,
  5,
  1,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  2,
  3,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::RelayVpnNodeInfo, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::RelayVpnNodeInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::RelayVpnNodeInfo, ip_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::RelayVpnNodeInfo, dhkey_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::RelayVpnNodeInfo, pubkey_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::RelayVpnNodeInfo, country_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::RelayVpnNodeInfo, min_svr_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::RelayVpnNodeInfo, max_svr_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::RelayVpnNodeInfo, min_route_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::RelayVpnNodeInfo, max_route_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::RelayVpnNodeInfo, node_weight_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::RelayVpnNodeInfo, min_udp_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::RelayVpnNodeInfo, max_udp_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::RelayVpnNodeInfo, node_tag_),
  0,
  1,
  2,
  3,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  4,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::VpnNodeInfo, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::VpnNodeInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::VpnNodeInfo, ip_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::VpnNodeInfo, dhkey_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::VpnNodeInfo, pubkey_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::VpnNodeInfo, country_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::VpnNodeInfo, min_svr_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::VpnNodeInfo, max_svr_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::VpnNodeInfo, min_route_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::VpnNodeInfo, max_route_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::VpnNodeInfo, node_weight_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::VpnNodeInfo, min_udp_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::VpnNodeInfo, max_udp_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::VpnNodeInfo, relay_vpn_nodes_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::VpnNodeInfo, node_tag_),
  0,
  1,
  2,
  3,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  ~0u,
  4,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::InitMessage, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::InitMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::InitMessage, version_info_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::InitMessage, route_nodes_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::InitMessage, vpn_nodes_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::InitMessage, use_conf_nodes_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::InitMessage, vpn_node_count_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::InitMessage, vpn_count_svr_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::InitMessage, init_blocks_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::InitMessage, bft_nodes_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::InitMessage, vip_route_nodes_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::InitMessage, vip_vpn_nodes_),
  0,
  ~0u,
  ~0u,
  5,
  1,
  2,
  3,
  4,
  ~0u,
  ~0u,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapResponse, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapResponse, node_id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapResponse, nat_type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapResponse, local_ip_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapResponse, local_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapResponse, public_ip_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapResponse, public_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapResponse, country_code_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapResponse, init_message_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapResponse, min_svr_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapResponse, max_svr_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapResponse, min_route_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapResponse, max_route_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapResponse, peer_public_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapResponse, node_weight_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapResponse, min_udp_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapResponse, max_udp_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::BootstrapResponse, node_tag_),
  0,
  5,
  1,
  6,
  2,
  7,
  8,
  4,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  3,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::RefreshNeighborsRequest, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::RefreshNeighborsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::RefreshNeighborsRequest, count_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::RefreshNeighborsRequest, des_dht_key_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::RefreshNeighborsRequest, bloomfilter1_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::RefreshNeighborsRequest, bloomfilter_),
  1,
  0,
  ~0u,
  ~0u,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::NodeInfo, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::NodeInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::NodeInfo, public_ip_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::NodeInfo, public_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::NodeInfo, local_ip_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::NodeInfo, local_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::NodeInfo, public_key_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::NodeInfo, nat_type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::NodeInfo, dht_key_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::NodeInfo, min_svr_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::NodeInfo, max_svr_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::NodeInfo, min_route_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::NodeInfo, max_route_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::NodeInfo, node_weight_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::NodeInfo, min_udp_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::NodeInfo, max_udp_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::NodeInfo, node_tag_),
  0,
  5,
  1,
  6,
  2,
  7,
  3,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  4,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::RefreshNeighborsResponse, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::RefreshNeighborsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::RefreshNeighborsResponse, nodes_),
  ~0u,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::HeartbeatRequest, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::HeartbeatRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::HeartbeatRequest, dht_key_hash_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::HeartbeatResponse, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::HeartbeatResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::HeartbeatResponse, dht_key_hash_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::ConnectReqeust, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::ConnectReqeust, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::ConnectReqeust, local_ip_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::ConnectReqeust, local_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::ConnectReqeust, public_ip_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::ConnectReqeust, public_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::ConnectReqeust, nat_type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::ConnectReqeust, id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::ConnectReqeust, dht_key_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::ConnectReqeust, direct_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::ConnectReqeust, min_svr_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::ConnectReqeust, max_svr_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::ConnectReqeust, min_route_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::ConnectReqeust, max_route_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::ConnectReqeust, node_weight_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::ConnectReqeust, min_udp_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::ConnectReqeust, max_udp_port_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::ConnectReqeust, node_tag_),
  0,
  5,
  1,
  6,
  7,
  2,
  3,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  4,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::DhtMessage, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::DhtMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::DhtMessage, bootstrap_req_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::DhtMessage, bootstrap_res_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::DhtMessage, refresh_neighbors_req_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::DhtMessage, refresh_neighbors_res_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::DhtMessage, connect_req_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::DhtMessage, heartbeat_req_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::DhtMessage, heartbeat_res_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tenon::dht::protobuf::DhtMessage, networks_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  ~0u,
};
static const ::google::protobuf::internal::MigrationSchema schemas[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 21, sizeof(::tenon::dht::protobuf::BootstrapRequest)},
  { 37, 54, sizeof(::tenon::dht::protobuf::RelayVpnNodeInfo)},
  { 66, 84, sizeof(::tenon::dht::protobuf::VpnNodeInfo)},
  { 97, 112, sizeof(::tenon::dht::protobuf::InitMessage)},
  { 122, 144, sizeof(::tenon::dht::protobuf::BootstrapResponse)},
  { 161, 170, sizeof(::tenon::dht::protobuf::RefreshNeighborsRequest)},
  { 174, 194, sizeof(::tenon::dht::protobuf::NodeInfo)},
  { 209, 215, sizeof(::tenon::dht::protobuf::RefreshNeighborsResponse)},
  { 216, 222, sizeof(::tenon::dht::protobuf::HeartbeatRequest)},
  { 223, 229, sizeof(::tenon::dht::protobuf::HeartbeatResponse)},
  { 230, 251, sizeof(::tenon::dht::protobuf::ConnectReqeust)},
  { 267, 280, sizeof(::tenon::dht::protobuf::DhtMessage)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::tenon::dht::protobuf::_BootstrapRequest_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::tenon::dht::protobuf::_RelayVpnNodeInfo_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::tenon::dht::protobuf::_VpnNodeInfo_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::tenon::dht::protobuf::_InitMessage_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::tenon::dht::protobuf::_BootstrapResponse_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::tenon::dht::protobuf::_RefreshNeighborsRequest_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::tenon::dht::protobuf::_NodeInfo_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::tenon::dht::protobuf::_RefreshNeighborsResponse_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::tenon::dht::protobuf::_HeartbeatRequest_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::tenon::dht::protobuf::_HeartbeatResponse_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::tenon::dht::protobuf::_ConnectReqeust_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::tenon::dht::protobuf::_DhtMessage_default_instance_),
};

void protobuf_AssignDescriptors() {
  AddDescriptors();
  AssignDescriptors(
      "dht.proto", schemas, file_default_instances, TableStruct::offsets,
      file_level_metadata, NULL, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static ::google::protobuf::internal::once_flag once;
  ::google::protobuf::internal::call_once(once, protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_PROTOBUF_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 12);
}

void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
      "\n\tdht.proto\022\022tenon.dht.protobuf\"\323\002\n\020Boot"
      "strapRequest\022\020\n\010local_ip\030\001 \001(\t\022\022\n\nlocal_"
      "port\030\002 \001(\005\022\020\n\010nat_type\030\003 \001(\005\022\017\n\007node_id\030"
      "\004 \001(\014\022\024\n\014get_init_msg\030\005 \001(\005\022\024\n\014min_svr_p"
      "ort\030\006 \001(\r\022\024\n\014max_svr_port\030\007 \001(\r\022\026\n\016min_r"
      "oute_port\030\010 \001(\r\022\026\n\016max_route_port\030\t \001(\r\022"
      "\023\n\013public_port\030\n \001(\005\022\023\n\013node_weight\030\013 \001("
      "\r\022\024\n\014min_udp_port\030\014 \001(\r\022\024\n\014max_udp_port\030"
      "\r \001(\r\022\017\n\007version\030\016 \001(\r\022\013\n\003uid\030\017 \001(\014\022\020\n\010n"
      "ode_tag\030\020 \001(\014\"\375\001\n\020RelayVpnNodeInfo\022\n\n\002ip"
      "\030\001 \001(\014\022\r\n\005dhkey\030\002 \001(\014\022\016\n\006pubkey\030\003 \001(\014\022\017\n"
      "\007country\030\004 \001(\014\022\024\n\014min_svr_port\030\005 \001(\r\022\024\n\014"
      "max_svr_port\030\006 \001(\r\022\026\n\016min_route_port\030\007 \001"
      "(\r\022\026\n\016max_route_port\030\010 \001(\r\022\023\n\013node_weigh"
      "t\030\t \001(\r\022\024\n\014min_udp_port\030\n \001(\r\022\024\n\014max_udp"
      "_port\030\013 \001(\r\022\020\n\010node_tag\030\014 \001(\014\"\267\002\n\013VpnNod"
      "eInfo\022\n\n\002ip\030\001 \001(\014\022\r\n\005dhkey\030\002 \001(\014\022\016\n\006pubk"
      "ey\030\003 \001(\014\022\017\n\007country\030\004 \001(\014\022\024\n\014min_svr_por"
      "t\030\005 \001(\r\022\024\n\014max_svr_port\030\006 \001(\r\022\026\n\016min_rou"
      "te_port\030\007 \001(\r\022\026\n\016max_route_port\030\010 \001(\r\022\023\n"
      "\013node_weight\030\t \001(\r\022\024\n\014min_udp_port\030\n \001(\r"
      "\022\024\n\014max_udp_port\030\013 \001(\r\022=\n\017relay_vpn_node"
      "s\030\014 \003(\0132$.tenon.dht.protobuf.RelayVpnNod"
      "eInfo\022\020\n\010node_tag\030\r \001(\014\"\356\002\n\013InitMessage\022"
      "\024\n\014version_info\030\001 \001(\014\0224\n\013route_nodes\030\002 \003"
      "(\0132\037.tenon.dht.protobuf.VpnNodeInfo\0222\n\tv"
      "pn_nodes\030\003 \003(\0132\037.tenon.dht.protobuf.VpnN"
      "odeInfo\022\026\n\016use_conf_nodes\030\004 \001(\010\022\026\n\016vpn_n"
      "ode_count\030\005 \001(\014\022\025\n\rvpn_count_svr\030\006 \001(\014\022\023"
      "\n\013init_blocks\030\007 \001(\014\022\021\n\tbft_nodes\030\010 \001(\014\0228"
      "\n\017vip_route_nodes\030\t \003(\0132\037.tenon.dht.prot"
      "obuf.VpnNodeInfo\0226\n\rvip_vpn_nodes\030\n \003(\0132"
      "\037.tenon.dht.protobuf.VpnNodeInfo\"\232\003\n\021Boo"
      "tstrapResponse\022\017\n\007node_id\030\001 \001(\014\022\020\n\010nat_t"
      "ype\030\002 \001(\005\022\020\n\010local_ip\030\003 \001(\t\022\022\n\nlocal_por"
      "t\030\004 \001(\005\022\021\n\tpublic_ip\030\005 \001(\t\022\023\n\013public_por"
      "t\030\006 \001(\005\022\024\n\014country_code\030\007 \001(\005\0225\n\014init_me"
      "ssage\030\010 \001(\0132\037.tenon.dht.protobuf.InitMes"
      "sage\022\024\n\014min_svr_port\030\t \001(\r\022\024\n\014max_svr_po"
      "rt\030\n \001(\r\022\026\n\016min_route_port\030\013 \001(\r\022\026\n\016max_"
      "route_port\030\014 \001(\r\022\030\n\020peer_public_port\030\r \001"
      "(\005\022\023\n\013node_weight\030\016 \001(\r\022\024\n\014min_udp_port\030"
      "\017 \001(\r\022\024\n\014max_udp_port\030\020 \001(\r\022\020\n\010node_tag\030"
      "\021 \001(\014\"h\n\027RefreshNeighborsRequest\022\r\n\005coun"
      "t\030\001 \001(\r\022\023\n\013des_dht_key\030\002 \001(\014\022\024\n\014bloomfil"
      "ter1\030\003 \003(\004\022\023\n\013bloomfilter\030\004 \003(\004\"\276\002\n\010Node"
      "Info\022\021\n\tpublic_ip\030\001 \001(\014\022\023\n\013public_port\030\002"
      " \001(\005\022\020\n\010local_ip\030\003 \001(\014\022\022\n\nlocal_port\030\004 \001"
      "(\005\022\022\n\npublic_key\030\005 \001(\014\022\020\n\010nat_type\030\006 \001(\005"
      "\022\017\n\007dht_key\030\007 \001(\014\022\024\n\014min_svr_port\030\010 \001(\r\022"
      "\024\n\014max_svr_port\030\t \001(\r\022\026\n\016min_route_port\030"
      "\n \001(\r\022\026\n\016max_route_port\030\013 \001(\r\022\023\n\013node_we"
      "ight\030\014 \001(\r\022\024\n\014min_udp_port\030\r \001(\r\022\024\n\014max_"
      "udp_port\030\016 \001(\r\022\020\n\010node_tag\030\017 \001(\014\"G\n\030Refr"
      "eshNeighborsResponse\022+\n\005nodes\030\001 \003(\0132\034.te"
      "non.dht.protobuf.NodeInfo\"(\n\020HeartbeatRe"
      "quest\022\024\n\014dht_key_hash\030\001 \001(\004\")\n\021Heartbeat"
      "Response\022\024\n\014dht_key_hash\030\001 \001(\004\"\314\002\n\016Conne"
      "ctReqeust\022\020\n\010local_ip\030\001 \001(\014\022\022\n\nlocal_por"
      "t\030\002 \001(\005\022\021\n\tpublic_ip\030\003 \001(\014\022\023\n\013public_por"
      "t\030\004 \001(\005\022\020\n\010nat_type\030\005 \001(\005\022\n\n\002id\030\006 \001(\014\022\017\n"
      "\007dht_key\030\007 \001(\014\022\016\n\006direct\030\010 \001(\010\022\024\n\014min_sv"
      "r_port\030\t \001(\r\022\024\n\014max_svr_port\030\n \001(\r\022\026\n\016mi"
      "n_route_port\030\013 \001(\r\022\026\n\016max_route_port\030\014 \001"
      "(\r\022\023\n\013node_weight\030\r \001(\r\022\024\n\014min_udp_port\030"
      "\016 \001(\r\022\024\n\014max_udp_port\030\017 \001(\r\022\020\n\010node_tag\030"
      "\020 \001(\014\"\346\003\n\nDhtMessage\022;\n\rbootstrap_req\030\001 "
      "\001(\0132$.tenon.dht.protobuf.BootstrapReques"
      "t\022<\n\rbootstrap_res\030\002 \001(\0132%.tenon.dht.pro"
      "tobuf.BootstrapResponse\022J\n\025refresh_neigh"
      "bors_req\030\003 \001(\0132+.tenon.dht.protobuf.Refr"
      "eshNeighborsRequest\022K\n\025refresh_neighbors"
      "_res\030\004 \001(\0132,.tenon.dht.protobuf.RefreshN"
      "eighborsResponse\0227\n\013connect_req\030\005 \001(\0132\"."
      "tenon.dht.protobuf.ConnectReqeust\022;\n\rhea"
      "rtbeat_req\030\006 \001(\0132$.tenon.dht.protobuf.He"
      "artbeatRequest\022<\n\rheartbeat_res\030\007 \001(\0132%."
      "tenon.dht.protobuf.HeartbeatResponse\022\020\n\010"
      "networks\030\010 \003(\r"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 3134);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "dht.proto", &protobuf_RegisterTypes);
}

void AddDescriptors() {
  static ::google::protobuf::internal::once_flag once;
  ::google::protobuf::internal::call_once(once, AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at dynamic initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;
}  // namespace protobuf_dht_2eproto
namespace tenon {
namespace dht {
namespace protobuf {

// ===================================================================

void BootstrapRequest::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BootstrapRequest::kLocalIpFieldNumber;
const int BootstrapRequest::kLocalPortFieldNumber;
const int BootstrapRequest::kNatTypeFieldNumber;
const int BootstrapRequest::kNodeIdFieldNumber;
const int BootstrapRequest::kGetInitMsgFieldNumber;
const int BootstrapRequest::kMinSvrPortFieldNumber;
const int BootstrapRequest::kMaxSvrPortFieldNumber;
const int BootstrapRequest::kMinRoutePortFieldNumber;
const int BootstrapRequest::kMaxRoutePortFieldNumber;
const int BootstrapRequest::kPublicPortFieldNumber;
const int BootstrapRequest::kNodeWeightFieldNumber;
const int BootstrapRequest::kMinUdpPortFieldNumber;
const int BootstrapRequest::kMaxUdpPortFieldNumber;
const int BootstrapRequest::kVersionFieldNumber;
const int BootstrapRequest::kUidFieldNumber;
const int BootstrapRequest::kNodeTagFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BootstrapRequest::BootstrapRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_dht_2eproto::scc_info_BootstrapRequest.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:tenon.dht.protobuf.BootstrapRequest)
}
BootstrapRequest::BootstrapRequest(const BootstrapRequest& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  local_ip_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_local_ip()) {
    local_ip_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.local_ip_);
  }
  node_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_node_id()) {
    node_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.node_id_);
  }
  uid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_uid()) {
    uid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.uid_);
  }
  node_tag_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_node_tag()) {
    node_tag_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.node_tag_);
  }
  ::memcpy(&local_port_, &from.local_port_,
    static_cast<size_t>(reinterpret_cast<char*>(&version_) -
    reinterpret_cast<char*>(&local_port_)) + sizeof(version_));
  // @@protoc_insertion_point(copy_constructor:tenon.dht.protobuf.BootstrapRequest)
}

void BootstrapRequest::SharedCtor() {
  local_ip_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  node_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  uid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  node_tag_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&local_port_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&version_) -
      reinterpret_cast<char*>(&local_port_)) + sizeof(version_));
}

BootstrapRequest::~BootstrapRequest() {
  // @@protoc_insertion_point(destructor:tenon.dht.protobuf.BootstrapRequest)
  SharedDtor();
}

void BootstrapRequest::SharedDtor() {
  local_ip_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  node_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  uid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  node_tag_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void BootstrapRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* BootstrapRequest::descriptor() {
  ::protobuf_dht_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_dht_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const BootstrapRequest& BootstrapRequest::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_dht_2eproto::scc_info_BootstrapRequest.base);
  return *internal_default_instance();
}


void BootstrapRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:tenon.dht.protobuf.BootstrapRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      local_ip_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      node_id_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      uid_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      node_tag_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 240u) {
    ::memset(&local_port_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&min_svr_port_) -
        reinterpret_cast<char*>(&local_port_)) + sizeof(min_svr_port_));
  }
  if (cached_has_bits & 65280u) {
    ::memset(&max_svr_port_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&version_) -
        reinterpret_cast<char*>(&max_svr_port_)) + sizeof(version_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool BootstrapRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tenon.dht.protobuf.BootstrapRequest)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string local_ip = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_local_ip()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->local_ip().data(), static_cast<int>(this->local_ip().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "tenon.dht.protobuf.BootstrapRequest.local_ip");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 local_port = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_local_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &local_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 nat_type = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          set_has_nat_type();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &nat_type_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes node_id = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_node_id()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 get_init_msg = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {
          set_has_get_init_msg();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &get_init_msg_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 min_svr_port = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u /* 48 & 0xFF */)) {
          set_has_min_svr_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &min_svr_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 max_svr_port = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(56u /* 56 & 0xFF */)) {
          set_has_max_svr_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_svr_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 min_route_port = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(64u /* 64 & 0xFF */)) {
          set_has_min_route_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &min_route_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 max_route_port = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(72u /* 72 & 0xFF */)) {
          set_has_max_route_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_route_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 public_port = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(80u /* 80 & 0xFF */)) {
          set_has_public_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &public_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 node_weight = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(88u /* 88 & 0xFF */)) {
          set_has_node_weight();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &node_weight_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 min_udp_port = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(96u /* 96 & 0xFF */)) {
          set_has_min_udp_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &min_udp_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 max_udp_port = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(104u /* 104 & 0xFF */)) {
          set_has_max_udp_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_udp_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 version = 14;
      case 14: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(112u /* 112 & 0xFF */)) {
          set_has_version();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes uid = 15;
      case 15: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(122u /* 122 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_uid()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes node_tag = 16;
      case 16: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(130u /* 130 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_node_tag()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tenon.dht.protobuf.BootstrapRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tenon.dht.protobuf.BootstrapRequest)
  return false;
#undef DO_
}

void BootstrapRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tenon.dht.protobuf.BootstrapRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string local_ip = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->local_ip().data(), static_cast<int>(this->local_ip().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "tenon.dht.protobuf.BootstrapRequest.local_ip");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->local_ip(), output);
  }

  // optional int32 local_port = 2;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->local_port(), output);
  }

  // optional int32 nat_type = 3;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->nat_type(), output);
  }

  // optional bytes node_id = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->node_id(), output);
  }

  // optional int32 get_init_msg = 5;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->get_init_msg(), output);
  }

  // optional uint32 min_svr_port = 6;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->min_svr_port(), output);
  }

  // optional uint32 max_svr_port = 7;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->max_svr_port(), output);
  }

  // optional uint32 min_route_port = 8;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->min_route_port(), output);
  }

  // optional uint32 max_route_port = 9;
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->max_route_port(), output);
  }

  // optional int32 public_port = 10;
  if (cached_has_bits & 0x00000800u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->public_port(), output);
  }

  // optional uint32 node_weight = 11;
  if (cached_has_bits & 0x00001000u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->node_weight(), output);
  }

  // optional uint32 min_udp_port = 12;
  if (cached_has_bits & 0x00002000u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->min_udp_port(), output);
  }

  // optional uint32 max_udp_port = 13;
  if (cached_has_bits & 0x00004000u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(13, this->max_udp_port(), output);
  }

  // optional uint32 version = 14;
  if (cached_has_bits & 0x00008000u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(14, this->version(), output);
  }

  // optional bytes uid = 15;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      15, this->uid(), output);
  }

  // optional bytes node_tag = 16;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      16, this->node_tag(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tenon.dht.protobuf.BootstrapRequest)
}

::google::protobuf::uint8* BootstrapRequest::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:tenon.dht.protobuf.BootstrapRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string local_ip = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->local_ip().data(), static_cast<int>(this->local_ip().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "tenon.dht.protobuf.BootstrapRequest.local_ip");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->local_ip(), target);
  }

  // optional int32 local_port = 2;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->local_port(), target);
  }

  // optional int32 nat_type = 3;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->nat_type(), target);
  }

  // optional bytes node_id = 4;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->node_id(), target);
  }

  // optional int32 get_init_msg = 5;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->get_init_msg(), target);
  }

  // optional uint32 min_svr_port = 6;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->min_svr_port(), target);
  }

  // optional uint32 max_svr_port = 7;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->max_svr_port(), target);
  }

  // optional uint32 min_route_port = 8;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->min_route_port(), target);
  }

  // optional uint32 max_route_port = 9;
  if (cached_has_bits & 0x00000400u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->max_route_port(), target);
  }

  // optional int32 public_port = 10;
  if (cached_has_bits & 0x00000800u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(10, this->public_port(), target);
  }

  // optional uint32 node_weight = 11;
  if (cached_has_bits & 0x00001000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(11, this->node_weight(), target);
  }

  // optional uint32 min_udp_port = 12;
  if (cached_has_bits & 0x00002000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(12, this->min_udp_port(), target);
  }

  // optional uint32 max_udp_port = 13;
  if (cached_has_bits & 0x00004000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(13, this->max_udp_port(), target);
  }

  // optional uint32 version = 14;
  if (cached_has_bits & 0x00008000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(14, this->version(), target);
  }

  // optional bytes uid = 15;
  if (cached_has_bits & 0x00000004u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        15, this->uid(), target);
  }

  // optional bytes node_tag = 16;
  if (cached_has_bits & 0x00000008u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        16, this->node_tag(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tenon.dht.protobuf.BootstrapRequest)
  return target;
}

size_t BootstrapRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tenon.dht.protobuf.BootstrapRequest)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 255u) {
    // optional string local_ip = 1;
    if (has_local_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->local_ip());
    }

    // optional bytes node_id = 4;
    if (has_node_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->node_id());
    }

    // optional bytes uid = 15;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->uid());
    }

    // optional bytes node_tag = 16;
    if (has_node_tag()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->node_tag());
    }

    // optional int32 local_port = 2;
    if (has_local_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->local_port());
    }

    // optional int32 nat_type = 3;
    if (has_nat_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->nat_type());
    }

    // optional int32 get_init_msg = 5;
    if (has_get_init_msg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->get_init_msg());
    }

    // optional uint32 min_svr_port = 6;
    if (has_min_svr_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->min_svr_port());
    }

  }
  if (_has_bits_[8 / 32] & 65280u) {
    // optional uint32 max_svr_port = 7;
    if (has_max_svr_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_svr_port());
    }

    // optional uint32 min_route_port = 8;
    if (has_min_route_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->min_route_port());
    }

    // optional uint32 max_route_port = 9;
    if (has_max_route_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_route_port());
    }

    // optional int32 public_port = 10;
    if (has_public_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->public_port());
    }

    // optional uint32 node_weight = 11;
    if (has_node_weight()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->node_weight());
    }

    // optional uint32 min_udp_port = 12;
    if (has_min_udp_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->min_udp_port());
    }

    // optional uint32 max_udp_port = 13;
    if (has_max_udp_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_udp_port());
    }

    // optional uint32 version = 14;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BootstrapRequest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:tenon.dht.protobuf.BootstrapRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const BootstrapRequest* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const BootstrapRequest>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:tenon.dht.protobuf.BootstrapRequest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:tenon.dht.protobuf.BootstrapRequest)
    MergeFrom(*source);
  }
}

void BootstrapRequest::MergeFrom(const BootstrapRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tenon.dht.protobuf.BootstrapRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_local_ip();
      local_ip_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.local_ip_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_node_id();
      node_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.node_id_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_uid();
      uid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.uid_);
    }
    if (cached_has_bits & 0x00000008u) {
      set_has_node_tag();
      node_tag_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.node_tag_);
    }
    if (cached_has_bits & 0x00000010u) {
      local_port_ = from.local_port_;
    }
    if (cached_has_bits & 0x00000020u) {
      nat_type_ = from.nat_type_;
    }
    if (cached_has_bits & 0x00000040u) {
      get_init_msg_ = from.get_init_msg_;
    }
    if (cached_has_bits & 0x00000080u) {
      min_svr_port_ = from.min_svr_port_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 65280u) {
    if (cached_has_bits & 0x00000100u) {
      max_svr_port_ = from.max_svr_port_;
    }
    if (cached_has_bits & 0x00000200u) {
      min_route_port_ = from.min_route_port_;
    }
    if (cached_has_bits & 0x00000400u) {
      max_route_port_ = from.max_route_port_;
    }
    if (cached_has_bits & 0x00000800u) {
      public_port_ = from.public_port_;
    }
    if (cached_has_bits & 0x00001000u) {
      node_weight_ = from.node_weight_;
    }
    if (cached_has_bits & 0x00002000u) {
      min_udp_port_ = from.min_udp_port_;
    }
    if (cached_has_bits & 0x00004000u) {
      max_udp_port_ = from.max_udp_port_;
    }
    if (cached_has_bits & 0x00008000u) {
      version_ = from.version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void BootstrapRequest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:tenon.dht.protobuf.BootstrapRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BootstrapRequest::CopyFrom(const BootstrapRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tenon.dht.protobuf.BootstrapRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BootstrapRequest::IsInitialized() const {
  return true;
}

void BootstrapRequest::Swap(BootstrapRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BootstrapRequest::InternalSwap(BootstrapRequest* other) {
  using std::swap;
  local_ip_.Swap(&other->local_ip_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  node_id_.Swap(&other->node_id_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  uid_.Swap(&other->uid_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  node_tag_.Swap(&other->node_tag_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(local_port_, other->local_port_);
  swap(nat_type_, other->nat_type_);
  swap(get_init_msg_, other->get_init_msg_);
  swap(min_svr_port_, other->min_svr_port_);
  swap(max_svr_port_, other->max_svr_port_);
  swap(min_route_port_, other->min_route_port_);
  swap(max_route_port_, other->max_route_port_);
  swap(public_port_, other->public_port_);
  swap(node_weight_, other->node_weight_);
  swap(min_udp_port_, other->min_udp_port_);
  swap(max_udp_port_, other->max_udp_port_);
  swap(version_, other->version_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata BootstrapRequest::GetMetadata() const {
  protobuf_dht_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_dht_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void RelayVpnNodeInfo::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RelayVpnNodeInfo::kIpFieldNumber;
const int RelayVpnNodeInfo::kDhkeyFieldNumber;
const int RelayVpnNodeInfo::kPubkeyFieldNumber;
const int RelayVpnNodeInfo::kCountryFieldNumber;
const int RelayVpnNodeInfo::kMinSvrPortFieldNumber;
const int RelayVpnNodeInfo::kMaxSvrPortFieldNumber;
const int RelayVpnNodeInfo::kMinRoutePortFieldNumber;
const int RelayVpnNodeInfo::kMaxRoutePortFieldNumber;
const int RelayVpnNodeInfo::kNodeWeightFieldNumber;
const int RelayVpnNodeInfo::kMinUdpPortFieldNumber;
const int RelayVpnNodeInfo::kMaxUdpPortFieldNumber;
const int RelayVpnNodeInfo::kNodeTagFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RelayVpnNodeInfo::RelayVpnNodeInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_dht_2eproto::scc_info_RelayVpnNodeInfo.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:tenon.dht.protobuf.RelayVpnNodeInfo)
}
RelayVpnNodeInfo::RelayVpnNodeInfo(const RelayVpnNodeInfo& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ip_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_ip()) {
    ip_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ip_);
  }
  dhkey_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_dhkey()) {
    dhkey_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.dhkey_);
  }
  pubkey_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_pubkey()) {
    pubkey_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.pubkey_);
  }
  country_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_country()) {
    country_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.country_);
  }
  node_tag_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_node_tag()) {
    node_tag_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.node_tag_);
  }
  ::memcpy(&min_svr_port_, &from.min_svr_port_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_udp_port_) -
    reinterpret_cast<char*>(&min_svr_port_)) + sizeof(max_udp_port_));
  // @@protoc_insertion_point(copy_constructor:tenon.dht.protobuf.RelayVpnNodeInfo)
}

void RelayVpnNodeInfo::SharedCtor() {
  ip_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  dhkey_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  pubkey_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  country_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  node_tag_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&min_svr_port_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&max_udp_port_) -
      reinterpret_cast<char*>(&min_svr_port_)) + sizeof(max_udp_port_));
}

RelayVpnNodeInfo::~RelayVpnNodeInfo() {
  // @@protoc_insertion_point(destructor:tenon.dht.protobuf.RelayVpnNodeInfo)
  SharedDtor();
}

void RelayVpnNodeInfo::SharedDtor() {
  ip_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  dhkey_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  pubkey_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  country_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  node_tag_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void RelayVpnNodeInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* RelayVpnNodeInfo::descriptor() {
  ::protobuf_dht_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_dht_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const RelayVpnNodeInfo& RelayVpnNodeInfo::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_dht_2eproto::scc_info_RelayVpnNodeInfo.base);
  return *internal_default_instance();
}


void RelayVpnNodeInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:tenon.dht.protobuf.RelayVpnNodeInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      ip_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      dhkey_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      pubkey_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      country_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000010u) {
      node_tag_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 224u) {
    ::memset(&min_svr_port_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&min_route_port_) -
        reinterpret_cast<char*>(&min_svr_port_)) + sizeof(min_route_port_));
  }
  if (cached_has_bits & 3840u) {
    ::memset(&max_route_port_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&max_udp_port_) -
        reinterpret_cast<char*>(&max_route_port_)) + sizeof(max_udp_port_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool RelayVpnNodeInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tenon.dht.protobuf.RelayVpnNodeInfo)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes ip = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ip()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes dhkey = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_dhkey()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes pubkey = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_pubkey()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes country = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_country()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 min_svr_port = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {
          set_has_min_svr_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &min_svr_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 max_svr_port = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u /* 48 & 0xFF */)) {
          set_has_max_svr_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_svr_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 min_route_port = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(56u /* 56 & 0xFF */)) {
          set_has_min_route_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &min_route_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 max_route_port = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(64u /* 64 & 0xFF */)) {
          set_has_max_route_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_route_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 node_weight = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(72u /* 72 & 0xFF */)) {
          set_has_node_weight();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &node_weight_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 min_udp_port = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(80u /* 80 & 0xFF */)) {
          set_has_min_udp_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &min_udp_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 max_udp_port = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(88u /* 88 & 0xFF */)) {
          set_has_max_udp_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_udp_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes node_tag = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(98u /* 98 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_node_tag()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tenon.dht.protobuf.RelayVpnNodeInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tenon.dht.protobuf.RelayVpnNodeInfo)
  return false;
#undef DO_
}

void RelayVpnNodeInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tenon.dht.protobuf.RelayVpnNodeInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes ip = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->ip(), output);
  }

  // optional bytes dhkey = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->dhkey(), output);
  }

  // optional bytes pubkey = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->pubkey(), output);
  }

  // optional bytes country = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->country(), output);
  }

  // optional uint32 min_svr_port = 5;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->min_svr_port(), output);
  }

  // optional uint32 max_svr_port = 6;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->max_svr_port(), output);
  }

  // optional uint32 min_route_port = 7;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->min_route_port(), output);
  }

  // optional uint32 max_route_port = 8;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->max_route_port(), output);
  }

  // optional uint32 node_weight = 9;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->node_weight(), output);
  }

  // optional uint32 min_udp_port = 10;
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->min_udp_port(), output);
  }

  // optional uint32 max_udp_port = 11;
  if (cached_has_bits & 0x00000800u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->max_udp_port(), output);
  }

  // optional bytes node_tag = 12;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      12, this->node_tag(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tenon.dht.protobuf.RelayVpnNodeInfo)
}

::google::protobuf::uint8* RelayVpnNodeInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:tenon.dht.protobuf.RelayVpnNodeInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes ip = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->ip(), target);
  }

  // optional bytes dhkey = 2;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->dhkey(), target);
  }

  // optional bytes pubkey = 3;
  if (cached_has_bits & 0x00000004u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->pubkey(), target);
  }

  // optional bytes country = 4;
  if (cached_has_bits & 0x00000008u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->country(), target);
  }

  // optional uint32 min_svr_port = 5;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->min_svr_port(), target);
  }

  // optional uint32 max_svr_port = 6;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->max_svr_port(), target);
  }

  // optional uint32 min_route_port = 7;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->min_route_port(), target);
  }

  // optional uint32 max_route_port = 8;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->max_route_port(), target);
  }

  // optional uint32 node_weight = 9;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->node_weight(), target);
  }

  // optional uint32 min_udp_port = 10;
  if (cached_has_bits & 0x00000400u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->min_udp_port(), target);
  }

  // optional uint32 max_udp_port = 11;
  if (cached_has_bits & 0x00000800u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(11, this->max_udp_port(), target);
  }

  // optional bytes node_tag = 12;
  if (cached_has_bits & 0x00000010u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        12, this->node_tag(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tenon.dht.protobuf.RelayVpnNodeInfo)
  return target;
}

size_t RelayVpnNodeInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tenon.dht.protobuf.RelayVpnNodeInfo)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 255u) {
    // optional bytes ip = 1;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->ip());
    }

    // optional bytes dhkey = 2;
    if (has_dhkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->dhkey());
    }

    // optional bytes pubkey = 3;
    if (has_pubkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->pubkey());
    }

    // optional bytes country = 4;
    if (has_country()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->country());
    }

    // optional bytes node_tag = 12;
    if (has_node_tag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->node_tag());
    }

    // optional uint32 min_svr_port = 5;
    if (has_min_svr_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->min_svr_port());
    }

    // optional uint32 max_svr_port = 6;
    if (has_max_svr_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_svr_port());
    }

    // optional uint32 min_route_port = 7;
    if (has_min_route_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->min_route_port());
    }

  }
  if (_has_bits_[8 / 32] & 3840u) {
    // optional uint32 max_route_port = 8;
    if (has_max_route_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_route_port());
    }

    // optional uint32 node_weight = 9;
    if (has_node_weight()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->node_weight());
    }

    // optional uint32 min_udp_port = 10;
    if (has_min_udp_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->min_udp_port());
    }

    // optional uint32 max_udp_port = 11;
    if (has_max_udp_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_udp_port());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RelayVpnNodeInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:tenon.dht.protobuf.RelayVpnNodeInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const RelayVpnNodeInfo* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const RelayVpnNodeInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:tenon.dht.protobuf.RelayVpnNodeInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:tenon.dht.protobuf.RelayVpnNodeInfo)
    MergeFrom(*source);
  }
}

void RelayVpnNodeInfo::MergeFrom(const RelayVpnNodeInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tenon.dht.protobuf.RelayVpnNodeInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_ip();
      ip_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ip_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_dhkey();
      dhkey_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.dhkey_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_pubkey();
      pubkey_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.pubkey_);
    }
    if (cached_has_bits & 0x00000008u) {
      set_has_country();
      country_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.country_);
    }
    if (cached_has_bits & 0x00000010u) {
      set_has_node_tag();
      node_tag_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.node_tag_);
    }
    if (cached_has_bits & 0x00000020u) {
      min_svr_port_ = from.min_svr_port_;
    }
    if (cached_has_bits & 0x00000040u) {
      max_svr_port_ = from.max_svr_port_;
    }
    if (cached_has_bits & 0x00000080u) {
      min_route_port_ = from.min_route_port_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 3840u) {
    if (cached_has_bits & 0x00000100u) {
      max_route_port_ = from.max_route_port_;
    }
    if (cached_has_bits & 0x00000200u) {
      node_weight_ = from.node_weight_;
    }
    if (cached_has_bits & 0x00000400u) {
      min_udp_port_ = from.min_udp_port_;
    }
    if (cached_has_bits & 0x00000800u) {
      max_udp_port_ = from.max_udp_port_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void RelayVpnNodeInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:tenon.dht.protobuf.RelayVpnNodeInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RelayVpnNodeInfo::CopyFrom(const RelayVpnNodeInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tenon.dht.protobuf.RelayVpnNodeInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RelayVpnNodeInfo::IsInitialized() const {
  return true;
}

void RelayVpnNodeInfo::Swap(RelayVpnNodeInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RelayVpnNodeInfo::InternalSwap(RelayVpnNodeInfo* other) {
  using std::swap;
  ip_.Swap(&other->ip_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  dhkey_.Swap(&other->dhkey_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  pubkey_.Swap(&other->pubkey_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  country_.Swap(&other->country_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  node_tag_.Swap(&other->node_tag_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(min_svr_port_, other->min_svr_port_);
  swap(max_svr_port_, other->max_svr_port_);
  swap(min_route_port_, other->min_route_port_);
  swap(max_route_port_, other->max_route_port_);
  swap(node_weight_, other->node_weight_);
  swap(min_udp_port_, other->min_udp_port_);
  swap(max_udp_port_, other->max_udp_port_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata RelayVpnNodeInfo::GetMetadata() const {
  protobuf_dht_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_dht_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void VpnNodeInfo::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int VpnNodeInfo::kIpFieldNumber;
const int VpnNodeInfo::kDhkeyFieldNumber;
const int VpnNodeInfo::kPubkeyFieldNumber;
const int VpnNodeInfo::kCountryFieldNumber;
const int VpnNodeInfo::kMinSvrPortFieldNumber;
const int VpnNodeInfo::kMaxSvrPortFieldNumber;
const int VpnNodeInfo::kMinRoutePortFieldNumber;
const int VpnNodeInfo::kMaxRoutePortFieldNumber;
const int VpnNodeInfo::kNodeWeightFieldNumber;
const int VpnNodeInfo::kMinUdpPortFieldNumber;
const int VpnNodeInfo::kMaxUdpPortFieldNumber;
const int VpnNodeInfo::kRelayVpnNodesFieldNumber;
const int VpnNodeInfo::kNodeTagFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

VpnNodeInfo::VpnNodeInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_dht_2eproto::scc_info_VpnNodeInfo.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:tenon.dht.protobuf.VpnNodeInfo)
}
VpnNodeInfo::VpnNodeInfo(const VpnNodeInfo& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      relay_vpn_nodes_(from.relay_vpn_nodes_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ip_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_ip()) {
    ip_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ip_);
  }
  dhkey_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_dhkey()) {
    dhkey_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.dhkey_);
  }
  pubkey_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_pubkey()) {
    pubkey_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.pubkey_);
  }
  country_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_country()) {
    country_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.country_);
  }
  node_tag_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_node_tag()) {
    node_tag_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.node_tag_);
  }
  ::memcpy(&min_svr_port_, &from.min_svr_port_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_udp_port_) -
    reinterpret_cast<char*>(&min_svr_port_)) + sizeof(max_udp_port_));
  // @@protoc_insertion_point(copy_constructor:tenon.dht.protobuf.VpnNodeInfo)
}

void VpnNodeInfo::SharedCtor() {
  ip_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  dhkey_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  pubkey_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  country_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  node_tag_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&min_svr_port_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&max_udp_port_) -
      reinterpret_cast<char*>(&min_svr_port_)) + sizeof(max_udp_port_));
}

VpnNodeInfo::~VpnNodeInfo() {
  // @@protoc_insertion_point(destructor:tenon.dht.protobuf.VpnNodeInfo)
  SharedDtor();
}

void VpnNodeInfo::SharedDtor() {
  ip_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  dhkey_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  pubkey_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  country_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  node_tag_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void VpnNodeInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* VpnNodeInfo::descriptor() {
  ::protobuf_dht_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_dht_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const VpnNodeInfo& VpnNodeInfo::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_dht_2eproto::scc_info_VpnNodeInfo.base);
  return *internal_default_instance();
}


void VpnNodeInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:tenon.dht.protobuf.VpnNodeInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  relay_vpn_nodes_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      ip_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      dhkey_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      pubkey_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      country_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000010u) {
      node_tag_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 224u) {
    ::memset(&min_svr_port_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&min_route_port_) -
        reinterpret_cast<char*>(&min_svr_port_)) + sizeof(min_route_port_));
  }
  if (cached_has_bits & 3840u) {
    ::memset(&max_route_port_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&max_udp_port_) -
        reinterpret_cast<char*>(&max_route_port_)) + sizeof(max_udp_port_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool VpnNodeInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tenon.dht.protobuf.VpnNodeInfo)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes ip = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_ip()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes dhkey = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_dhkey()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes pubkey = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_pubkey()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes country = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_country()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 min_svr_port = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {
          set_has_min_svr_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &min_svr_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 max_svr_port = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u /* 48 & 0xFF */)) {
          set_has_max_svr_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_svr_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 min_route_port = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(56u /* 56 & 0xFF */)) {
          set_has_min_route_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &min_route_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 max_route_port = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(64u /* 64 & 0xFF */)) {
          set_has_max_route_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_route_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 node_weight = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(72u /* 72 & 0xFF */)) {
          set_has_node_weight();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &node_weight_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 min_udp_port = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(80u /* 80 & 0xFF */)) {
          set_has_min_udp_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &min_udp_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 max_udp_port = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(88u /* 88 & 0xFF */)) {
          set_has_max_udp_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_udp_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .tenon.dht.protobuf.RelayVpnNodeInfo relay_vpn_nodes = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(98u /* 98 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_relay_vpn_nodes()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes node_tag = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(106u /* 106 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_node_tag()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tenon.dht.protobuf.VpnNodeInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tenon.dht.protobuf.VpnNodeInfo)
  return false;
#undef DO_
}

void VpnNodeInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tenon.dht.protobuf.VpnNodeInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes ip = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->ip(), output);
  }

  // optional bytes dhkey = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->dhkey(), output);
  }

  // optional bytes pubkey = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->pubkey(), output);
  }

  // optional bytes country = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->country(), output);
  }

  // optional uint32 min_svr_port = 5;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->min_svr_port(), output);
  }

  // optional uint32 max_svr_port = 6;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->max_svr_port(), output);
  }

  // optional uint32 min_route_port = 7;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->min_route_port(), output);
  }

  // optional uint32 max_route_port = 8;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->max_route_port(), output);
  }

  // optional uint32 node_weight = 9;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->node_weight(), output);
  }

  // optional uint32 min_udp_port = 10;
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->min_udp_port(), output);
  }

  // optional uint32 max_udp_port = 11;
  if (cached_has_bits & 0x00000800u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->max_udp_port(), output);
  }

  // repeated .tenon.dht.protobuf.RelayVpnNodeInfo relay_vpn_nodes = 12;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->relay_vpn_nodes_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12,
      this->relay_vpn_nodes(static_cast<int>(i)),
      output);
  }

  // optional bytes node_tag = 13;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      13, this->node_tag(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tenon.dht.protobuf.VpnNodeInfo)
}

::google::protobuf::uint8* VpnNodeInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:tenon.dht.protobuf.VpnNodeInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes ip = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->ip(), target);
  }

  // optional bytes dhkey = 2;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->dhkey(), target);
  }

  // optional bytes pubkey = 3;
  if (cached_has_bits & 0x00000004u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->pubkey(), target);
  }

  // optional bytes country = 4;
  if (cached_has_bits & 0x00000008u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->country(), target);
  }

  // optional uint32 min_svr_port = 5;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->min_svr_port(), target);
  }

  // optional uint32 max_svr_port = 6;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->max_svr_port(), target);
  }

  // optional uint32 min_route_port = 7;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->min_route_port(), target);
  }

  // optional uint32 max_route_port = 8;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->max_route_port(), target);
  }

  // optional uint32 node_weight = 9;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->node_weight(), target);
  }

  // optional uint32 min_udp_port = 10;
  if (cached_has_bits & 0x00000400u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->min_udp_port(), target);
  }

  // optional uint32 max_udp_port = 11;
  if (cached_has_bits & 0x00000800u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(11, this->max_udp_port(), target);
  }

  // repeated .tenon.dht.protobuf.RelayVpnNodeInfo relay_vpn_nodes = 12;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->relay_vpn_nodes_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        12, this->relay_vpn_nodes(static_cast<int>(i)), deterministic, target);
  }

  // optional bytes node_tag = 13;
  if (cached_has_bits & 0x00000010u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        13, this->node_tag(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tenon.dht.protobuf.VpnNodeInfo)
  return target;
}

size_t VpnNodeInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tenon.dht.protobuf.VpnNodeInfo)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // repeated .tenon.dht.protobuf.RelayVpnNodeInfo relay_vpn_nodes = 12;
  {
    unsigned int count = static_cast<unsigned int>(this->relay_vpn_nodes_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->relay_vpn_nodes(static_cast<int>(i)));
    }
  }

  if (_has_bits_[0 / 32] & 255u) {
    // optional bytes ip = 1;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->ip());
    }

    // optional bytes dhkey = 2;
    if (has_dhkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->dhkey());
    }

    // optional bytes pubkey = 3;
    if (has_pubkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->pubkey());
    }

    // optional bytes country = 4;
    if (has_country()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->country());
    }

    // optional bytes node_tag = 13;
    if (has_node_tag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->node_tag());
    }

    // optional uint32 min_svr_port = 5;
    if (has_min_svr_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->min_svr_port());
    }

    // optional uint32 max_svr_port = 6;
    if (has_max_svr_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_svr_port());
    }

    // optional uint32 min_route_port = 7;
    if (has_min_route_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->min_route_port());
    }

  }
  if (_has_bits_[8 / 32] & 3840u) {
    // optional uint32 max_route_port = 8;
    if (has_max_route_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_route_port());
    }

    // optional uint32 node_weight = 9;
    if (has_node_weight()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->node_weight());
    }

    // optional uint32 min_udp_port = 10;
    if (has_min_udp_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->min_udp_port());
    }

    // optional uint32 max_udp_port = 11;
    if (has_max_udp_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_udp_port());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VpnNodeInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:tenon.dht.protobuf.VpnNodeInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const VpnNodeInfo* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const VpnNodeInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:tenon.dht.protobuf.VpnNodeInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:tenon.dht.protobuf.VpnNodeInfo)
    MergeFrom(*source);
  }
}

void VpnNodeInfo::MergeFrom(const VpnNodeInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tenon.dht.protobuf.VpnNodeInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  relay_vpn_nodes_.MergeFrom(from.relay_vpn_nodes_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_ip();
      ip_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ip_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_dhkey();
      dhkey_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.dhkey_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_pubkey();
      pubkey_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.pubkey_);
    }
    if (cached_has_bits & 0x00000008u) {
      set_has_country();
      country_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.country_);
    }
    if (cached_has_bits & 0x00000010u) {
      set_has_node_tag();
      node_tag_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.node_tag_);
    }
    if (cached_has_bits & 0x00000020u) {
      min_svr_port_ = from.min_svr_port_;
    }
    if (cached_has_bits & 0x00000040u) {
      max_svr_port_ = from.max_svr_port_;
    }
    if (cached_has_bits & 0x00000080u) {
      min_route_port_ = from.min_route_port_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 3840u) {
    if (cached_has_bits & 0x00000100u) {
      max_route_port_ = from.max_route_port_;
    }
    if (cached_has_bits & 0x00000200u) {
      node_weight_ = from.node_weight_;
    }
    if (cached_has_bits & 0x00000400u) {
      min_udp_port_ = from.min_udp_port_;
    }
    if (cached_has_bits & 0x00000800u) {
      max_udp_port_ = from.max_udp_port_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void VpnNodeInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:tenon.dht.protobuf.VpnNodeInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VpnNodeInfo::CopyFrom(const VpnNodeInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tenon.dht.protobuf.VpnNodeInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VpnNodeInfo::IsInitialized() const {
  return true;
}

void VpnNodeInfo::Swap(VpnNodeInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void VpnNodeInfo::InternalSwap(VpnNodeInfo* other) {
  using std::swap;
  CastToBase(&relay_vpn_nodes_)->InternalSwap(CastToBase(&other->relay_vpn_nodes_));
  ip_.Swap(&other->ip_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  dhkey_.Swap(&other->dhkey_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  pubkey_.Swap(&other->pubkey_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  country_.Swap(&other->country_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  node_tag_.Swap(&other->node_tag_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(min_svr_port_, other->min_svr_port_);
  swap(max_svr_port_, other->max_svr_port_);
  swap(min_route_port_, other->min_route_port_);
  swap(max_route_port_, other->max_route_port_);
  swap(node_weight_, other->node_weight_);
  swap(min_udp_port_, other->min_udp_port_);
  swap(max_udp_port_, other->max_udp_port_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata VpnNodeInfo::GetMetadata() const {
  protobuf_dht_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_dht_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void InitMessage::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int InitMessage::kVersionInfoFieldNumber;
const int InitMessage::kRouteNodesFieldNumber;
const int InitMessage::kVpnNodesFieldNumber;
const int InitMessage::kUseConfNodesFieldNumber;
const int InitMessage::kVpnNodeCountFieldNumber;
const int InitMessage::kVpnCountSvrFieldNumber;
const int InitMessage::kInitBlocksFieldNumber;
const int InitMessage::kBftNodesFieldNumber;
const int InitMessage::kVipRouteNodesFieldNumber;
const int InitMessage::kVipVpnNodesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

InitMessage::InitMessage()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_dht_2eproto::scc_info_InitMessage.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:tenon.dht.protobuf.InitMessage)
}
InitMessage::InitMessage(const InitMessage& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      route_nodes_(from.route_nodes_),
      vpn_nodes_(from.vpn_nodes_),
      vip_route_nodes_(from.vip_route_nodes_),
      vip_vpn_nodes_(from.vip_vpn_nodes_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  version_info_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_version_info()) {
    version_info_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.version_info_);
  }
  vpn_node_count_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_vpn_node_count()) {
    vpn_node_count_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.vpn_node_count_);
  }
  vpn_count_svr_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_vpn_count_svr()) {
    vpn_count_svr_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.vpn_count_svr_);
  }
  init_blocks_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_init_blocks()) {
    init_blocks_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.init_blocks_);
  }
  bft_nodes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_bft_nodes()) {
    bft_nodes_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.bft_nodes_);
  }
  use_conf_nodes_ = from.use_conf_nodes_;
  // @@protoc_insertion_point(copy_constructor:tenon.dht.protobuf.InitMessage)
}

void InitMessage::SharedCtor() {
  version_info_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  vpn_node_count_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  vpn_count_svr_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  init_blocks_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  bft_nodes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  use_conf_nodes_ = false;
}

InitMessage::~InitMessage() {
  // @@protoc_insertion_point(destructor:tenon.dht.protobuf.InitMessage)
  SharedDtor();
}

void InitMessage::SharedDtor() {
  version_info_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  vpn_node_count_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  vpn_count_svr_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  init_blocks_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  bft_nodes_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void InitMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* InitMessage::descriptor() {
  ::protobuf_dht_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_dht_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const InitMessage& InitMessage::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_dht_2eproto::scc_info_InitMessage.base);
  return *internal_default_instance();
}


void InitMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:tenon.dht.protobuf.InitMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  route_nodes_.Clear();
  vpn_nodes_.Clear();
  vip_route_nodes_.Clear();
  vip_vpn_nodes_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      version_info_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      vpn_node_count_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      vpn_count_svr_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      init_blocks_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000010u) {
      bft_nodes_.ClearNonDefaultToEmptyNoArena();
    }
  }
  use_conf_nodes_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool InitMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tenon.dht.protobuf.InitMessage)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes version_info = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_version_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .tenon.dht.protobuf.VpnNodeInfo route_nodes = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_route_nodes()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .tenon.dht.protobuf.VpnNodeInfo vpn_nodes = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_vpn_nodes()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool use_conf_nodes = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          set_has_use_conf_nodes();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &use_conf_nodes_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes vpn_node_count = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_vpn_node_count()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes vpn_count_svr = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_vpn_count_svr()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes init_blocks = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u /* 58 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_init_blocks()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes bft_nodes = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(66u /* 66 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_bft_nodes()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .tenon.dht.protobuf.VpnNodeInfo vip_route_nodes = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(74u /* 74 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_vip_route_nodes()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .tenon.dht.protobuf.VpnNodeInfo vip_vpn_nodes = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(82u /* 82 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_vip_vpn_nodes()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tenon.dht.protobuf.InitMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tenon.dht.protobuf.InitMessage)
  return false;
#undef DO_
}

void InitMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tenon.dht.protobuf.InitMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes version_info = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->version_info(), output);
  }

  // repeated .tenon.dht.protobuf.VpnNodeInfo route_nodes = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->route_nodes_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->route_nodes(static_cast<int>(i)),
      output);
  }

  // repeated .tenon.dht.protobuf.VpnNodeInfo vpn_nodes = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->vpn_nodes_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3,
      this->vpn_nodes(static_cast<int>(i)),
      output);
  }

  // optional bool use_conf_nodes = 4;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->use_conf_nodes(), output);
  }

  // optional bytes vpn_node_count = 5;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->vpn_node_count(), output);
  }

  // optional bytes vpn_count_svr = 6;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      6, this->vpn_count_svr(), output);
  }

  // optional bytes init_blocks = 7;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      7, this->init_blocks(), output);
  }

  // optional bytes bft_nodes = 8;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      8, this->bft_nodes(), output);
  }

  // repeated .tenon.dht.protobuf.VpnNodeInfo vip_route_nodes = 9;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->vip_route_nodes_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9,
      this->vip_route_nodes(static_cast<int>(i)),
      output);
  }

  // repeated .tenon.dht.protobuf.VpnNodeInfo vip_vpn_nodes = 10;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->vip_vpn_nodes_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10,
      this->vip_vpn_nodes(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tenon.dht.protobuf.InitMessage)
}

::google::protobuf::uint8* InitMessage::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:tenon.dht.protobuf.InitMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes version_info = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->version_info(), target);
  }

  // repeated .tenon.dht.protobuf.VpnNodeInfo route_nodes = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->route_nodes_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->route_nodes(static_cast<int>(i)), deterministic, target);
  }

  // repeated .tenon.dht.protobuf.VpnNodeInfo vpn_nodes = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->vpn_nodes_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, this->vpn_nodes(static_cast<int>(i)), deterministic, target);
  }

  // optional bool use_conf_nodes = 4;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->use_conf_nodes(), target);
  }

  // optional bytes vpn_node_count = 5;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->vpn_node_count(), target);
  }

  // optional bytes vpn_count_svr = 6;
  if (cached_has_bits & 0x00000004u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        6, this->vpn_count_svr(), target);
  }

  // optional bytes init_blocks = 7;
  if (cached_has_bits & 0x00000008u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        7, this->init_blocks(), target);
  }

  // optional bytes bft_nodes = 8;
  if (cached_has_bits & 0x00000010u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        8, this->bft_nodes(), target);
  }

  // repeated .tenon.dht.protobuf.VpnNodeInfo vip_route_nodes = 9;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->vip_route_nodes_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        9, this->vip_route_nodes(static_cast<int>(i)), deterministic, target);
  }

  // repeated .tenon.dht.protobuf.VpnNodeInfo vip_vpn_nodes = 10;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->vip_vpn_nodes_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        10, this->vip_vpn_nodes(static_cast<int>(i)), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tenon.dht.protobuf.InitMessage)
  return target;
}

size_t InitMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tenon.dht.protobuf.InitMessage)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // repeated .tenon.dht.protobuf.VpnNodeInfo route_nodes = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->route_nodes_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->route_nodes(static_cast<int>(i)));
    }
  }

  // repeated .tenon.dht.protobuf.VpnNodeInfo vpn_nodes = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->vpn_nodes_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->vpn_nodes(static_cast<int>(i)));
    }
  }

  // repeated .tenon.dht.protobuf.VpnNodeInfo vip_route_nodes = 9;
  {
    unsigned int count = static_cast<unsigned int>(this->vip_route_nodes_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->vip_route_nodes(static_cast<int>(i)));
    }
  }

  // repeated .tenon.dht.protobuf.VpnNodeInfo vip_vpn_nodes = 10;
  {
    unsigned int count = static_cast<unsigned int>(this->vip_vpn_nodes_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->vip_vpn_nodes(static_cast<int>(i)));
    }
  }

  if (_has_bits_[0 / 32] & 63u) {
    // optional bytes version_info = 1;
    if (has_version_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->version_info());
    }

    // optional bytes vpn_node_count = 5;
    if (has_vpn_node_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->vpn_node_count());
    }

    // optional bytes vpn_count_svr = 6;
    if (has_vpn_count_svr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->vpn_count_svr());
    }

    // optional bytes init_blocks = 7;
    if (has_init_blocks()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->init_blocks());
    }

    // optional bytes bft_nodes = 8;
    if (has_bft_nodes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->bft_nodes());
    }

    // optional bool use_conf_nodes = 4;
    if (has_use_conf_nodes()) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InitMessage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:tenon.dht.protobuf.InitMessage)
  GOOGLE_DCHECK_NE(&from, this);
  const InitMessage* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const InitMessage>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:tenon.dht.protobuf.InitMessage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:tenon.dht.protobuf.InitMessage)
    MergeFrom(*source);
  }
}

void InitMessage::MergeFrom(const InitMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tenon.dht.protobuf.InitMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  route_nodes_.MergeFrom(from.route_nodes_);
  vpn_nodes_.MergeFrom(from.vpn_nodes_);
  vip_route_nodes_.MergeFrom(from.vip_route_nodes_);
  vip_vpn_nodes_.MergeFrom(from.vip_vpn_nodes_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 63u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_version_info();
      version_info_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.version_info_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_vpn_node_count();
      vpn_node_count_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.vpn_node_count_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_vpn_count_svr();
      vpn_count_svr_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.vpn_count_svr_);
    }
    if (cached_has_bits & 0x00000008u) {
      set_has_init_blocks();
      init_blocks_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.init_blocks_);
    }
    if (cached_has_bits & 0x00000010u) {
      set_has_bft_nodes();
      bft_nodes_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.bft_nodes_);
    }
    if (cached_has_bits & 0x00000020u) {
      use_conf_nodes_ = from.use_conf_nodes_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void InitMessage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:tenon.dht.protobuf.InitMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InitMessage::CopyFrom(const InitMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tenon.dht.protobuf.InitMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InitMessage::IsInitialized() const {
  return true;
}

void InitMessage::Swap(InitMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void InitMessage::InternalSwap(InitMessage* other) {
  using std::swap;
  CastToBase(&route_nodes_)->InternalSwap(CastToBase(&other->route_nodes_));
  CastToBase(&vpn_nodes_)->InternalSwap(CastToBase(&other->vpn_nodes_));
  CastToBase(&vip_route_nodes_)->InternalSwap(CastToBase(&other->vip_route_nodes_));
  CastToBase(&vip_vpn_nodes_)->InternalSwap(CastToBase(&other->vip_vpn_nodes_));
  version_info_.Swap(&other->version_info_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  vpn_node_count_.Swap(&other->vpn_node_count_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  vpn_count_svr_.Swap(&other->vpn_count_svr_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  init_blocks_.Swap(&other->init_blocks_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  bft_nodes_.Swap(&other->bft_nodes_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(use_conf_nodes_, other->use_conf_nodes_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata InitMessage::GetMetadata() const {
  protobuf_dht_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_dht_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void BootstrapResponse::InitAsDefaultInstance() {
  ::tenon::dht::protobuf::_BootstrapResponse_default_instance_._instance.get_mutable()->init_message_ = const_cast< ::tenon::dht::protobuf::InitMessage*>(
      ::tenon::dht::protobuf::InitMessage::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BootstrapResponse::kNodeIdFieldNumber;
const int BootstrapResponse::kNatTypeFieldNumber;
const int BootstrapResponse::kLocalIpFieldNumber;
const int BootstrapResponse::kLocalPortFieldNumber;
const int BootstrapResponse::kPublicIpFieldNumber;
const int BootstrapResponse::kPublicPortFieldNumber;
const int BootstrapResponse::kCountryCodeFieldNumber;
const int BootstrapResponse::kInitMessageFieldNumber;
const int BootstrapResponse::kMinSvrPortFieldNumber;
const int BootstrapResponse::kMaxSvrPortFieldNumber;
const int BootstrapResponse::kMinRoutePortFieldNumber;
const int BootstrapResponse::kMaxRoutePortFieldNumber;
const int BootstrapResponse::kPeerPublicPortFieldNumber;
const int BootstrapResponse::kNodeWeightFieldNumber;
const int BootstrapResponse::kMinUdpPortFieldNumber;
const int BootstrapResponse::kMaxUdpPortFieldNumber;
const int BootstrapResponse::kNodeTagFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BootstrapResponse::BootstrapResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_dht_2eproto::scc_info_BootstrapResponse.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:tenon.dht.protobuf.BootstrapResponse)
}
BootstrapResponse::BootstrapResponse(const BootstrapResponse& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  node_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_node_id()) {
    node_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.node_id_);
  }
  local_ip_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_local_ip()) {
    local_ip_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.local_ip_);
  }
  public_ip_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_public_ip()) {
    public_ip_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.public_ip_);
  }
  node_tag_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_node_tag()) {
    node_tag_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.node_tag_);
  }
  if (from.has_init_message()) {
    init_message_ = new ::tenon::dht::protobuf::InitMessage(*from.init_message_);
  } else {
    init_message_ = NULL;
  }
  ::memcpy(&nat_type_, &from.nat_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_udp_port_) -
    reinterpret_cast<char*>(&nat_type_)) + sizeof(max_udp_port_));
  // @@protoc_insertion_point(copy_constructor:tenon.dht.protobuf.BootstrapResponse)
}

void BootstrapResponse::SharedCtor() {
  node_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  local_ip_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  public_ip_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  node_tag_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&init_message_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&max_udp_port_) -
      reinterpret_cast<char*>(&init_message_)) + sizeof(max_udp_port_));
}

BootstrapResponse::~BootstrapResponse() {
  // @@protoc_insertion_point(destructor:tenon.dht.protobuf.BootstrapResponse)
  SharedDtor();
}

void BootstrapResponse::SharedDtor() {
  node_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  local_ip_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  public_ip_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  node_tag_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete init_message_;
}

void BootstrapResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* BootstrapResponse::descriptor() {
  ::protobuf_dht_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_dht_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const BootstrapResponse& BootstrapResponse::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_dht_2eproto::scc_info_BootstrapResponse.base);
  return *internal_default_instance();
}


void BootstrapResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:tenon.dht.protobuf.BootstrapResponse)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      node_id_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      local_ip_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      public_ip_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      node_tag_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(init_message_ != NULL);
      init_message_->Clear();
    }
  }
  if (cached_has_bits & 224u) {
    ::memset(&nat_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&public_port_) -
        reinterpret_cast<char*>(&nat_type_)) + sizeof(public_port_));
  }
  if (cached_has_bits & 65280u) {
    ::memset(&country_code_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&min_udp_port_) -
        reinterpret_cast<char*>(&country_code_)) + sizeof(min_udp_port_));
  }
  max_udp_port_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool BootstrapResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tenon.dht.protobuf.BootstrapResponse)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes node_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_node_id()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 nat_type = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_nat_type();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &nat_type_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string local_ip = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_local_ip()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->local_ip().data(), static_cast<int>(this->local_ip().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "tenon.dht.protobuf.BootstrapResponse.local_ip");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 local_port = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          set_has_local_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &local_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string public_ip = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_public_ip()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->public_ip().data(), static_cast<int>(this->public_ip().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "tenon.dht.protobuf.BootstrapResponse.public_ip");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 public_port = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u /* 48 & 0xFF */)) {
          set_has_public_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &public_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 country_code = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(56u /* 56 & 0xFF */)) {
          set_has_country_code();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &country_code_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .tenon.dht.protobuf.InitMessage init_message = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(66u /* 66 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_init_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 min_svr_port = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(72u /* 72 & 0xFF */)) {
          set_has_min_svr_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &min_svr_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 max_svr_port = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(80u /* 80 & 0xFF */)) {
          set_has_max_svr_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_svr_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 min_route_port = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(88u /* 88 & 0xFF */)) {
          set_has_min_route_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &min_route_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 max_route_port = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(96u /* 96 & 0xFF */)) {
          set_has_max_route_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_route_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 peer_public_port = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(104u /* 104 & 0xFF */)) {
          set_has_peer_public_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &peer_public_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 node_weight = 14;
      case 14: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(112u /* 112 & 0xFF */)) {
          set_has_node_weight();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &node_weight_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 min_udp_port = 15;
      case 15: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(120u /* 120 & 0xFF */)) {
          set_has_min_udp_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &min_udp_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 max_udp_port = 16;
      case 16: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(128u /* 128 & 0xFF */)) {
          set_has_max_udp_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_udp_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes node_tag = 17;
      case 17: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(138u /* 138 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_node_tag()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tenon.dht.protobuf.BootstrapResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tenon.dht.protobuf.BootstrapResponse)
  return false;
#undef DO_
}

void BootstrapResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tenon.dht.protobuf.BootstrapResponse)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes node_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->node_id(), output);
  }

  // optional int32 nat_type = 2;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->nat_type(), output);
  }

  // optional string local_ip = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->local_ip().data(), static_cast<int>(this->local_ip().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "tenon.dht.protobuf.BootstrapResponse.local_ip");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->local_ip(), output);
  }

  // optional int32 local_port = 4;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->local_port(), output);
  }

  // optional string public_ip = 5;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->public_ip().data(), static_cast<int>(this->public_ip().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "tenon.dht.protobuf.BootstrapResponse.public_ip");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->public_ip(), output);
  }

  // optional int32 public_port = 6;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->public_port(), output);
  }

  // optional int32 country_code = 7;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->country_code(), output);
  }

  // optional .tenon.dht.protobuf.InitMessage init_message = 8;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->_internal_init_message(), output);
  }

  // optional uint32 min_svr_port = 9;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->min_svr_port(), output);
  }

  // optional uint32 max_svr_port = 10;
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->max_svr_port(), output);
  }

  // optional uint32 min_route_port = 11;
  if (cached_has_bits & 0x00000800u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->min_route_port(), output);
  }

  // optional uint32 max_route_port = 12;
  if (cached_has_bits & 0x00001000u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->max_route_port(), output);
  }

  // optional int32 peer_public_port = 13;
  if (cached_has_bits & 0x00002000u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(13, this->peer_public_port(), output);
  }

  // optional uint32 node_weight = 14;
  if (cached_has_bits & 0x00004000u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(14, this->node_weight(), output);
  }

  // optional uint32 min_udp_port = 15;
  if (cached_has_bits & 0x00008000u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(15, this->min_udp_port(), output);
  }

  // optional uint32 max_udp_port = 16;
  if (cached_has_bits & 0x00010000u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(16, this->max_udp_port(), output);
  }

  // optional bytes node_tag = 17;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      17, this->node_tag(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tenon.dht.protobuf.BootstrapResponse)
}

::google::protobuf::uint8* BootstrapResponse::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:tenon.dht.protobuf.BootstrapResponse)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes node_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->node_id(), target);
  }

  // optional int32 nat_type = 2;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->nat_type(), target);
  }

  // optional string local_ip = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->local_ip().data(), static_cast<int>(this->local_ip().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "tenon.dht.protobuf.BootstrapResponse.local_ip");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->local_ip(), target);
  }

  // optional int32 local_port = 4;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->local_port(), target);
  }

  // optional string public_ip = 5;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->public_ip().data(), static_cast<int>(this->public_ip().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "tenon.dht.protobuf.BootstrapResponse.public_ip");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->public_ip(), target);
  }

  // optional int32 public_port = 6;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->public_port(), target);
  }

  // optional int32 country_code = 7;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->country_code(), target);
  }

  // optional .tenon.dht.protobuf.InitMessage init_message = 8;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        8, this->_internal_init_message(), deterministic, target);
  }

  // optional uint32 min_svr_port = 9;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->min_svr_port(), target);
  }

  // optional uint32 max_svr_port = 10;
  if (cached_has_bits & 0x00000400u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->max_svr_port(), target);
  }

  // optional uint32 min_route_port = 11;
  if (cached_has_bits & 0x00000800u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(11, this->min_route_port(), target);
  }

  // optional uint32 max_route_port = 12;
  if (cached_has_bits & 0x00001000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(12, this->max_route_port(), target);
  }

  // optional int32 peer_public_port = 13;
  if (cached_has_bits & 0x00002000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(13, this->peer_public_port(), target);
  }

  // optional uint32 node_weight = 14;
  if (cached_has_bits & 0x00004000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(14, this->node_weight(), target);
  }

  // optional uint32 min_udp_port = 15;
  if (cached_has_bits & 0x00008000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(15, this->min_udp_port(), target);
  }

  // optional uint32 max_udp_port = 16;
  if (cached_has_bits & 0x00010000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(16, this->max_udp_port(), target);
  }

  // optional bytes node_tag = 17;
  if (cached_has_bits & 0x00000008u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        17, this->node_tag(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tenon.dht.protobuf.BootstrapResponse)
  return target;
}

size_t BootstrapResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tenon.dht.protobuf.BootstrapResponse)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 255u) {
    // optional bytes node_id = 1;
    if (has_node_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->node_id());
    }

    // optional string local_ip = 3;
    if (has_local_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->local_ip());
    }

    // optional string public_ip = 5;
    if (has_public_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->public_ip());
    }

    // optional bytes node_tag = 17;
    if (has_node_tag()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->node_tag());
    }

    // optional .tenon.dht.protobuf.InitMessage init_message = 8;
    if (has_init_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *init_message_);
    }

    // optional int32 nat_type = 2;
    if (has_nat_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->nat_type());
    }

    // optional int32 local_port = 4;
    if (has_local_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->local_port());
    }

    // optional int32 public_port = 6;
    if (has_public_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->public_port());
    }

  }
  if (_has_bits_[8 / 32] & 65280u) {
    // optional int32 country_code = 7;
    if (has_country_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->country_code());
    }

    // optional uint32 min_svr_port = 9;
    if (has_min_svr_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->min_svr_port());
    }

    // optional uint32 max_svr_port = 10;
    if (has_max_svr_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_svr_port());
    }

    // optional uint32 min_route_port = 11;
    if (has_min_route_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->min_route_port());
    }

    // optional uint32 max_route_port = 12;
    if (has_max_route_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_route_port());
    }

    // optional int32 peer_public_port = 13;
    if (has_peer_public_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->peer_public_port());
    }

    // optional uint32 node_weight = 14;
    if (has_node_weight()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->node_weight());
    }

    // optional uint32 min_udp_port = 15;
    if (has_min_udp_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->min_udp_port());
    }

  }
  // optional uint32 max_udp_port = 16;
  if (has_max_udp_port()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->max_udp_port());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BootstrapResponse::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:tenon.dht.protobuf.BootstrapResponse)
  GOOGLE_DCHECK_NE(&from, this);
  const BootstrapResponse* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const BootstrapResponse>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:tenon.dht.protobuf.BootstrapResponse)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:tenon.dht.protobuf.BootstrapResponse)
    MergeFrom(*source);
  }
}

void BootstrapResponse::MergeFrom(const BootstrapResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tenon.dht.protobuf.BootstrapResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_node_id();
      node_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.node_id_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_local_ip();
      local_ip_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.local_ip_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_public_ip();
      public_ip_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.public_ip_);
    }
    if (cached_has_bits & 0x00000008u) {
      set_has_node_tag();
      node_tag_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.node_tag_);
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_init_message()->::tenon::dht::protobuf::InitMessage::MergeFrom(from.init_message());
    }
    if (cached_has_bits & 0x00000020u) {
      nat_type_ = from.nat_type_;
    }
    if (cached_has_bits & 0x00000040u) {
      local_port_ = from.local_port_;
    }
    if (cached_has_bits & 0x00000080u) {
      public_port_ = from.public_port_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 65280u) {
    if (cached_has_bits & 0x00000100u) {
      country_code_ = from.country_code_;
    }
    if (cached_has_bits & 0x00000200u) {
      min_svr_port_ = from.min_svr_port_;
    }
    if (cached_has_bits & 0x00000400u) {
      max_svr_port_ = from.max_svr_port_;
    }
    if (cached_has_bits & 0x00000800u) {
      min_route_port_ = from.min_route_port_;
    }
    if (cached_has_bits & 0x00001000u) {
      max_route_port_ = from.max_route_port_;
    }
    if (cached_has_bits & 0x00002000u) {
      peer_public_port_ = from.peer_public_port_;
    }
    if (cached_has_bits & 0x00004000u) {
      node_weight_ = from.node_weight_;
    }
    if (cached_has_bits & 0x00008000u) {
      min_udp_port_ = from.min_udp_port_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00010000u) {
    set_max_udp_port(from.max_udp_port());
  }
}

void BootstrapResponse::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:tenon.dht.protobuf.BootstrapResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BootstrapResponse::CopyFrom(const BootstrapResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tenon.dht.protobuf.BootstrapResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BootstrapResponse::IsInitialized() const {
  return true;
}

void BootstrapResponse::Swap(BootstrapResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BootstrapResponse::InternalSwap(BootstrapResponse* other) {
  using std::swap;
  node_id_.Swap(&other->node_id_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  local_ip_.Swap(&other->local_ip_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  public_ip_.Swap(&other->public_ip_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  node_tag_.Swap(&other->node_tag_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(init_message_, other->init_message_);
  swap(nat_type_, other->nat_type_);
  swap(local_port_, other->local_port_);
  swap(public_port_, other->public_port_);
  swap(country_code_, other->country_code_);
  swap(min_svr_port_, other->min_svr_port_);
  swap(max_svr_port_, other->max_svr_port_);
  swap(min_route_port_, other->min_route_port_);
  swap(max_route_port_, other->max_route_port_);
  swap(peer_public_port_, other->peer_public_port_);
  swap(node_weight_, other->node_weight_);
  swap(min_udp_port_, other->min_udp_port_);
  swap(max_udp_port_, other->max_udp_port_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata BootstrapResponse::GetMetadata() const {
  protobuf_dht_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_dht_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void RefreshNeighborsRequest::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RefreshNeighborsRequest::kCountFieldNumber;
const int RefreshNeighborsRequest::kDesDhtKeyFieldNumber;
const int RefreshNeighborsRequest::kBloomfilter1FieldNumber;
const int RefreshNeighborsRequest::kBloomfilterFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RefreshNeighborsRequest::RefreshNeighborsRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_dht_2eproto::scc_info_RefreshNeighborsRequest.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:tenon.dht.protobuf.RefreshNeighborsRequest)
}
RefreshNeighborsRequest::RefreshNeighborsRequest(const RefreshNeighborsRequest& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      bloomfilter1_(from.bloomfilter1_),
      bloomfilter_(from.bloomfilter_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  des_dht_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_des_dht_key()) {
    des_dht_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.des_dht_key_);
  }
  count_ = from.count_;
  // @@protoc_insertion_point(copy_constructor:tenon.dht.protobuf.RefreshNeighborsRequest)
}

void RefreshNeighborsRequest::SharedCtor() {
  des_dht_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  count_ = 0u;
}

RefreshNeighborsRequest::~RefreshNeighborsRequest() {
  // @@protoc_insertion_point(destructor:tenon.dht.protobuf.RefreshNeighborsRequest)
  SharedDtor();
}

void RefreshNeighborsRequest::SharedDtor() {
  des_dht_key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void RefreshNeighborsRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* RefreshNeighborsRequest::descriptor() {
  ::protobuf_dht_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_dht_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const RefreshNeighborsRequest& RefreshNeighborsRequest::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_dht_2eproto::scc_info_RefreshNeighborsRequest.base);
  return *internal_default_instance();
}


void RefreshNeighborsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:tenon.dht.protobuf.RefreshNeighborsRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  bloomfilter1_.Clear();
  bloomfilter_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    des_dht_key_.ClearNonDefaultToEmptyNoArena();
  }
  count_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool RefreshNeighborsRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tenon.dht.protobuf.RefreshNeighborsRequest)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 count = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_count();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes des_dht_key = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_des_dht_key()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated uint64 bloomfilter1 = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 24u, input, this->mutable_bloomfilter1())));
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_bloomfilter1())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated uint64 bloomfilter = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 32u, input, this->mutable_bloomfilter())));
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_bloomfilter())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tenon.dht.protobuf.RefreshNeighborsRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tenon.dht.protobuf.RefreshNeighborsRequest)
  return false;
#undef DO_
}

void RefreshNeighborsRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tenon.dht.protobuf.RefreshNeighborsRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 count = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->count(), output);
  }

  // optional bytes des_dht_key = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->des_dht_key(), output);
  }

  // repeated uint64 bloomfilter1 = 3;
  for (int i = 0, n = this->bloomfilter1_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      3, this->bloomfilter1(i), output);
  }

  // repeated uint64 bloomfilter = 4;
  for (int i = 0, n = this->bloomfilter_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      4, this->bloomfilter(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tenon.dht.protobuf.RefreshNeighborsRequest)
}

::google::protobuf::uint8* RefreshNeighborsRequest::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:tenon.dht.protobuf.RefreshNeighborsRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 count = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->count(), target);
  }

  // optional bytes des_dht_key = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->des_dht_key(), target);
  }

  // repeated uint64 bloomfilter1 = 3;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt64ToArray(3, this->bloomfilter1_, target);

  // repeated uint64 bloomfilter = 4;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt64ToArray(4, this->bloomfilter_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tenon.dht.protobuf.RefreshNeighborsRequest)
  return target;
}

size_t RefreshNeighborsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tenon.dht.protobuf.RefreshNeighborsRequest)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // repeated uint64 bloomfilter1 = 3;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt64Size(this->bloomfilter1_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->bloomfilter1_size());
    total_size += data_size;
  }

  // repeated uint64 bloomfilter = 4;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt64Size(this->bloomfilter_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->bloomfilter_size());
    total_size += data_size;
  }

  if (_has_bits_[0 / 32] & 3u) {
    // optional bytes des_dht_key = 2;
    if (has_des_dht_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->des_dht_key());
    }

    // optional uint32 count = 1;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RefreshNeighborsRequest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:tenon.dht.protobuf.RefreshNeighborsRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const RefreshNeighborsRequest* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const RefreshNeighborsRequest>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:tenon.dht.protobuf.RefreshNeighborsRequest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:tenon.dht.protobuf.RefreshNeighborsRequest)
    MergeFrom(*source);
  }
}

void RefreshNeighborsRequest::MergeFrom(const RefreshNeighborsRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tenon.dht.protobuf.RefreshNeighborsRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  bloomfilter1_.MergeFrom(from.bloomfilter1_);
  bloomfilter_.MergeFrom(from.bloomfilter_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_des_dht_key();
      des_dht_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.des_dht_key_);
    }
    if (cached_has_bits & 0x00000002u) {
      count_ = from.count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void RefreshNeighborsRequest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:tenon.dht.protobuf.RefreshNeighborsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RefreshNeighborsRequest::CopyFrom(const RefreshNeighborsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tenon.dht.protobuf.RefreshNeighborsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RefreshNeighborsRequest::IsInitialized() const {
  return true;
}

void RefreshNeighborsRequest::Swap(RefreshNeighborsRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RefreshNeighborsRequest::InternalSwap(RefreshNeighborsRequest* other) {
  using std::swap;
  bloomfilter1_.InternalSwap(&other->bloomfilter1_);
  bloomfilter_.InternalSwap(&other->bloomfilter_);
  des_dht_key_.Swap(&other->des_dht_key_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(count_, other->count_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata RefreshNeighborsRequest::GetMetadata() const {
  protobuf_dht_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_dht_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void NodeInfo::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NodeInfo::kPublicIpFieldNumber;
const int NodeInfo::kPublicPortFieldNumber;
const int NodeInfo::kLocalIpFieldNumber;
const int NodeInfo::kLocalPortFieldNumber;
const int NodeInfo::kPublicKeyFieldNumber;
const int NodeInfo::kNatTypeFieldNumber;
const int NodeInfo::kDhtKeyFieldNumber;
const int NodeInfo::kMinSvrPortFieldNumber;
const int NodeInfo::kMaxSvrPortFieldNumber;
const int NodeInfo::kMinRoutePortFieldNumber;
const int NodeInfo::kMaxRoutePortFieldNumber;
const int NodeInfo::kNodeWeightFieldNumber;
const int NodeInfo::kMinUdpPortFieldNumber;
const int NodeInfo::kMaxUdpPortFieldNumber;
const int NodeInfo::kNodeTagFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NodeInfo::NodeInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_dht_2eproto::scc_info_NodeInfo.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:tenon.dht.protobuf.NodeInfo)
}
NodeInfo::NodeInfo(const NodeInfo& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  public_ip_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_public_ip()) {
    public_ip_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.public_ip_);
  }
  local_ip_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_local_ip()) {
    local_ip_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.local_ip_);
  }
  public_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_public_key()) {
    public_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.public_key_);
  }
  dht_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_dht_key()) {
    dht_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.dht_key_);
  }
  node_tag_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_node_tag()) {
    node_tag_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.node_tag_);
  }
  ::memcpy(&public_port_, &from.public_port_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_udp_port_) -
    reinterpret_cast<char*>(&public_port_)) + sizeof(max_udp_port_));
  // @@protoc_insertion_point(copy_constructor:tenon.dht.protobuf.NodeInfo)
}

void NodeInfo::SharedCtor() {
  public_ip_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  local_ip_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  public_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  dht_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  node_tag_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&public_port_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&max_udp_port_) -
      reinterpret_cast<char*>(&public_port_)) + sizeof(max_udp_port_));
}

NodeInfo::~NodeInfo() {
  // @@protoc_insertion_point(destructor:tenon.dht.protobuf.NodeInfo)
  SharedDtor();
}

void NodeInfo::SharedDtor() {
  public_ip_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  local_ip_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  public_key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  dht_key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  node_tag_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void NodeInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* NodeInfo::descriptor() {
  ::protobuf_dht_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_dht_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const NodeInfo& NodeInfo::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_dht_2eproto::scc_info_NodeInfo.base);
  return *internal_default_instance();
}


void NodeInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:tenon.dht.protobuf.NodeInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      public_ip_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      local_ip_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      public_key_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      dht_key_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000010u) {
      node_tag_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 224u) {
    ::memset(&public_port_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&nat_type_) -
        reinterpret_cast<char*>(&public_port_)) + sizeof(nat_type_));
  }
  if (cached_has_bits & 32512u) {
    ::memset(&min_svr_port_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&max_udp_port_) -
        reinterpret_cast<char*>(&min_svr_port_)) + sizeof(max_udp_port_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool NodeInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tenon.dht.protobuf.NodeInfo)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes public_ip = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_public_ip()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 public_port = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_public_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &public_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes local_ip = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_local_ip()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 local_port = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          set_has_local_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &local_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes public_key = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_public_key()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 nat_type = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u /* 48 & 0xFF */)) {
          set_has_nat_type();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &nat_type_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes dht_key = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u /* 58 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_dht_key()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 min_svr_port = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(64u /* 64 & 0xFF */)) {
          set_has_min_svr_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &min_svr_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 max_svr_port = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(72u /* 72 & 0xFF */)) {
          set_has_max_svr_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_svr_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 min_route_port = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(80u /* 80 & 0xFF */)) {
          set_has_min_route_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &min_route_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 max_route_port = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(88u /* 88 & 0xFF */)) {
          set_has_max_route_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_route_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 node_weight = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(96u /* 96 & 0xFF */)) {
          set_has_node_weight();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &node_weight_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 min_udp_port = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(104u /* 104 & 0xFF */)) {
          set_has_min_udp_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &min_udp_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 max_udp_port = 14;
      case 14: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(112u /* 112 & 0xFF */)) {
          set_has_max_udp_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_udp_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes node_tag = 15;
      case 15: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(122u /* 122 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_node_tag()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tenon.dht.protobuf.NodeInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tenon.dht.protobuf.NodeInfo)
  return false;
#undef DO_
}

void NodeInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tenon.dht.protobuf.NodeInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes public_ip = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->public_ip(), output);
  }

  // optional int32 public_port = 2;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->public_port(), output);
  }

  // optional bytes local_ip = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->local_ip(), output);
  }

  // optional int32 local_port = 4;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->local_port(), output);
  }

  // optional bytes public_key = 5;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->public_key(), output);
  }

  // optional int32 nat_type = 6;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->nat_type(), output);
  }

  // optional bytes dht_key = 7;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      7, this->dht_key(), output);
  }

  // optional uint32 min_svr_port = 8;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->min_svr_port(), output);
  }

  // optional uint32 max_svr_port = 9;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->max_svr_port(), output);
  }

  // optional uint32 min_route_port = 10;
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->min_route_port(), output);
  }

  // optional uint32 max_route_port = 11;
  if (cached_has_bits & 0x00000800u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->max_route_port(), output);
  }

  // optional uint32 node_weight = 12;
  if (cached_has_bits & 0x00001000u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->node_weight(), output);
  }

  // optional uint32 min_udp_port = 13;
  if (cached_has_bits & 0x00002000u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(13, this->min_udp_port(), output);
  }

  // optional uint32 max_udp_port = 14;
  if (cached_has_bits & 0x00004000u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(14, this->max_udp_port(), output);
  }

  // optional bytes node_tag = 15;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      15, this->node_tag(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tenon.dht.protobuf.NodeInfo)
}

::google::protobuf::uint8* NodeInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:tenon.dht.protobuf.NodeInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes public_ip = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->public_ip(), target);
  }

  // optional int32 public_port = 2;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->public_port(), target);
  }

  // optional bytes local_ip = 3;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->local_ip(), target);
  }

  // optional int32 local_port = 4;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->local_port(), target);
  }

  // optional bytes public_key = 5;
  if (cached_has_bits & 0x00000004u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->public_key(), target);
  }

  // optional int32 nat_type = 6;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->nat_type(), target);
  }

  // optional bytes dht_key = 7;
  if (cached_has_bits & 0x00000008u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        7, this->dht_key(), target);
  }

  // optional uint32 min_svr_port = 8;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->min_svr_port(), target);
  }

  // optional uint32 max_svr_port = 9;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->max_svr_port(), target);
  }

  // optional uint32 min_route_port = 10;
  if (cached_has_bits & 0x00000400u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->min_route_port(), target);
  }

  // optional uint32 max_route_port = 11;
  if (cached_has_bits & 0x00000800u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(11, this->max_route_port(), target);
  }

  // optional uint32 node_weight = 12;
  if (cached_has_bits & 0x00001000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(12, this->node_weight(), target);
  }

  // optional uint32 min_udp_port = 13;
  if (cached_has_bits & 0x00002000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(13, this->min_udp_port(), target);
  }

  // optional uint32 max_udp_port = 14;
  if (cached_has_bits & 0x00004000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(14, this->max_udp_port(), target);
  }

  // optional bytes node_tag = 15;
  if (cached_has_bits & 0x00000010u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        15, this->node_tag(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tenon.dht.protobuf.NodeInfo)
  return target;
}

size_t NodeInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tenon.dht.protobuf.NodeInfo)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 255u) {
    // optional bytes public_ip = 1;
    if (has_public_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->public_ip());
    }

    // optional bytes local_ip = 3;
    if (has_local_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->local_ip());
    }

    // optional bytes public_key = 5;
    if (has_public_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->public_key());
    }

    // optional bytes dht_key = 7;
    if (has_dht_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->dht_key());
    }

    // optional bytes node_tag = 15;
    if (has_node_tag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->node_tag());
    }

    // optional int32 public_port = 2;
    if (has_public_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->public_port());
    }

    // optional int32 local_port = 4;
    if (has_local_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->local_port());
    }

    // optional int32 nat_type = 6;
    if (has_nat_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->nat_type());
    }

  }
  if (_has_bits_[8 / 32] & 32512u) {
    // optional uint32 min_svr_port = 8;
    if (has_min_svr_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->min_svr_port());
    }

    // optional uint32 max_svr_port = 9;
    if (has_max_svr_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_svr_port());
    }

    // optional uint32 min_route_port = 10;
    if (has_min_route_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->min_route_port());
    }

    // optional uint32 max_route_port = 11;
    if (has_max_route_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_route_port());
    }

    // optional uint32 node_weight = 12;
    if (has_node_weight()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->node_weight());
    }

    // optional uint32 min_udp_port = 13;
    if (has_min_udp_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->min_udp_port());
    }

    // optional uint32 max_udp_port = 14;
    if (has_max_udp_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_udp_port());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NodeInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:tenon.dht.protobuf.NodeInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const NodeInfo* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const NodeInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:tenon.dht.protobuf.NodeInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:tenon.dht.protobuf.NodeInfo)
    MergeFrom(*source);
  }
}

void NodeInfo::MergeFrom(const NodeInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tenon.dht.protobuf.NodeInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_public_ip();
      public_ip_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.public_ip_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_local_ip();
      local_ip_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.local_ip_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_public_key();
      public_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.public_key_);
    }
    if (cached_has_bits & 0x00000008u) {
      set_has_dht_key();
      dht_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.dht_key_);
    }
    if (cached_has_bits & 0x00000010u) {
      set_has_node_tag();
      node_tag_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.node_tag_);
    }
    if (cached_has_bits & 0x00000020u) {
      public_port_ = from.public_port_;
    }
    if (cached_has_bits & 0x00000040u) {
      local_port_ = from.local_port_;
    }
    if (cached_has_bits & 0x00000080u) {
      nat_type_ = from.nat_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 32512u) {
    if (cached_has_bits & 0x00000100u) {
      min_svr_port_ = from.min_svr_port_;
    }
    if (cached_has_bits & 0x00000200u) {
      max_svr_port_ = from.max_svr_port_;
    }
    if (cached_has_bits & 0x00000400u) {
      min_route_port_ = from.min_route_port_;
    }
    if (cached_has_bits & 0x00000800u) {
      max_route_port_ = from.max_route_port_;
    }
    if (cached_has_bits & 0x00001000u) {
      node_weight_ = from.node_weight_;
    }
    if (cached_has_bits & 0x00002000u) {
      min_udp_port_ = from.min_udp_port_;
    }
    if (cached_has_bits & 0x00004000u) {
      max_udp_port_ = from.max_udp_port_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void NodeInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:tenon.dht.protobuf.NodeInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NodeInfo::CopyFrom(const NodeInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tenon.dht.protobuf.NodeInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodeInfo::IsInitialized() const {
  return true;
}

void NodeInfo::Swap(NodeInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NodeInfo::InternalSwap(NodeInfo* other) {
  using std::swap;
  public_ip_.Swap(&other->public_ip_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  local_ip_.Swap(&other->local_ip_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  public_key_.Swap(&other->public_key_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  dht_key_.Swap(&other->dht_key_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  node_tag_.Swap(&other->node_tag_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(public_port_, other->public_port_);
  swap(local_port_, other->local_port_);
  swap(nat_type_, other->nat_type_);
  swap(min_svr_port_, other->min_svr_port_);
  swap(max_svr_port_, other->max_svr_port_);
  swap(min_route_port_, other->min_route_port_);
  swap(max_route_port_, other->max_route_port_);
  swap(node_weight_, other->node_weight_);
  swap(min_udp_port_, other->min_udp_port_);
  swap(max_udp_port_, other->max_udp_port_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata NodeInfo::GetMetadata() const {
  protobuf_dht_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_dht_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void RefreshNeighborsResponse::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RefreshNeighborsResponse::kNodesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RefreshNeighborsResponse::RefreshNeighborsResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_dht_2eproto::scc_info_RefreshNeighborsResponse.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:tenon.dht.protobuf.RefreshNeighborsResponse)
}
RefreshNeighborsResponse::RefreshNeighborsResponse(const RefreshNeighborsResponse& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      nodes_(from.nodes_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:tenon.dht.protobuf.RefreshNeighborsResponse)
}

void RefreshNeighborsResponse::SharedCtor() {
}

RefreshNeighborsResponse::~RefreshNeighborsResponse() {
  // @@protoc_insertion_point(destructor:tenon.dht.protobuf.RefreshNeighborsResponse)
  SharedDtor();
}

void RefreshNeighborsResponse::SharedDtor() {
}

void RefreshNeighborsResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* RefreshNeighborsResponse::descriptor() {
  ::protobuf_dht_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_dht_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const RefreshNeighborsResponse& RefreshNeighborsResponse::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_dht_2eproto::scc_info_RefreshNeighborsResponse.base);
  return *internal_default_instance();
}


void RefreshNeighborsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:tenon.dht.protobuf.RefreshNeighborsResponse)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nodes_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool RefreshNeighborsResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tenon.dht.protobuf.RefreshNeighborsResponse)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .tenon.dht.protobuf.NodeInfo nodes = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_nodes()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tenon.dht.protobuf.RefreshNeighborsResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tenon.dht.protobuf.RefreshNeighborsResponse)
  return false;
#undef DO_
}

void RefreshNeighborsResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tenon.dht.protobuf.RefreshNeighborsResponse)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .tenon.dht.protobuf.NodeInfo nodes = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->nodes_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->nodes(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tenon.dht.protobuf.RefreshNeighborsResponse)
}

::google::protobuf::uint8* RefreshNeighborsResponse::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:tenon.dht.protobuf.RefreshNeighborsResponse)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .tenon.dht.protobuf.NodeInfo nodes = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->nodes_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->nodes(static_cast<int>(i)), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tenon.dht.protobuf.RefreshNeighborsResponse)
  return target;
}

size_t RefreshNeighborsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tenon.dht.protobuf.RefreshNeighborsResponse)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // repeated .tenon.dht.protobuf.NodeInfo nodes = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->nodes_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->nodes(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RefreshNeighborsResponse::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:tenon.dht.protobuf.RefreshNeighborsResponse)
  GOOGLE_DCHECK_NE(&from, this);
  const RefreshNeighborsResponse* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const RefreshNeighborsResponse>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:tenon.dht.protobuf.RefreshNeighborsResponse)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:tenon.dht.protobuf.RefreshNeighborsResponse)
    MergeFrom(*source);
  }
}

void RefreshNeighborsResponse::MergeFrom(const RefreshNeighborsResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tenon.dht.protobuf.RefreshNeighborsResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  nodes_.MergeFrom(from.nodes_);
}

void RefreshNeighborsResponse::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:tenon.dht.protobuf.RefreshNeighborsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RefreshNeighborsResponse::CopyFrom(const RefreshNeighborsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tenon.dht.protobuf.RefreshNeighborsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RefreshNeighborsResponse::IsInitialized() const {
  return true;
}

void RefreshNeighborsResponse::Swap(RefreshNeighborsResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RefreshNeighborsResponse::InternalSwap(RefreshNeighborsResponse* other) {
  using std::swap;
  CastToBase(&nodes_)->InternalSwap(CastToBase(&other->nodes_));
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata RefreshNeighborsResponse::GetMetadata() const {
  protobuf_dht_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_dht_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void HeartbeatRequest::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int HeartbeatRequest::kDhtKeyHashFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

HeartbeatRequest::HeartbeatRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_dht_2eproto::scc_info_HeartbeatRequest.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:tenon.dht.protobuf.HeartbeatRequest)
}
HeartbeatRequest::HeartbeatRequest(const HeartbeatRequest& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  dht_key_hash_ = from.dht_key_hash_;
  // @@protoc_insertion_point(copy_constructor:tenon.dht.protobuf.HeartbeatRequest)
}

void HeartbeatRequest::SharedCtor() {
  dht_key_hash_ = GOOGLE_ULONGLONG(0);
}

HeartbeatRequest::~HeartbeatRequest() {
  // @@protoc_insertion_point(destructor:tenon.dht.protobuf.HeartbeatRequest)
  SharedDtor();
}

void HeartbeatRequest::SharedDtor() {
}

void HeartbeatRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* HeartbeatRequest::descriptor() {
  ::protobuf_dht_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_dht_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const HeartbeatRequest& HeartbeatRequest::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_dht_2eproto::scc_info_HeartbeatRequest.base);
  return *internal_default_instance();
}


void HeartbeatRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:tenon.dht.protobuf.HeartbeatRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  dht_key_hash_ = GOOGLE_ULONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool HeartbeatRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tenon.dht.protobuf.HeartbeatRequest)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dht_key_hash = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_dht_key_hash();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dht_key_hash_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tenon.dht.protobuf.HeartbeatRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tenon.dht.protobuf.HeartbeatRequest)
  return false;
#undef DO_
}

void HeartbeatRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tenon.dht.protobuf.HeartbeatRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dht_key_hash = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->dht_key_hash(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tenon.dht.protobuf.HeartbeatRequest)
}

::google::protobuf::uint8* HeartbeatRequest::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:tenon.dht.protobuf.HeartbeatRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dht_key_hash = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->dht_key_hash(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tenon.dht.protobuf.HeartbeatRequest)
  return target;
}

size_t HeartbeatRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tenon.dht.protobuf.HeartbeatRequest)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // optional uint64 dht_key_hash = 1;
  if (has_dht_key_hash()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->dht_key_hash());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HeartbeatRequest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:tenon.dht.protobuf.HeartbeatRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const HeartbeatRequest* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const HeartbeatRequest>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:tenon.dht.protobuf.HeartbeatRequest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:tenon.dht.protobuf.HeartbeatRequest)
    MergeFrom(*source);
  }
}

void HeartbeatRequest::MergeFrom(const HeartbeatRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tenon.dht.protobuf.HeartbeatRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_dht_key_hash()) {
    set_dht_key_hash(from.dht_key_hash());
  }
}

void HeartbeatRequest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:tenon.dht.protobuf.HeartbeatRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HeartbeatRequest::CopyFrom(const HeartbeatRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tenon.dht.protobuf.HeartbeatRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeartbeatRequest::IsInitialized() const {
  return true;
}

void HeartbeatRequest::Swap(HeartbeatRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void HeartbeatRequest::InternalSwap(HeartbeatRequest* other) {
  using std::swap;
  swap(dht_key_hash_, other->dht_key_hash_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata HeartbeatRequest::GetMetadata() const {
  protobuf_dht_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_dht_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void HeartbeatResponse::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int HeartbeatResponse::kDhtKeyHashFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

HeartbeatResponse::HeartbeatResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_dht_2eproto::scc_info_HeartbeatResponse.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:tenon.dht.protobuf.HeartbeatResponse)
}
HeartbeatResponse::HeartbeatResponse(const HeartbeatResponse& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  dht_key_hash_ = from.dht_key_hash_;
  // @@protoc_insertion_point(copy_constructor:tenon.dht.protobuf.HeartbeatResponse)
}

void HeartbeatResponse::SharedCtor() {
  dht_key_hash_ = GOOGLE_ULONGLONG(0);
}

HeartbeatResponse::~HeartbeatResponse() {
  // @@protoc_insertion_point(destructor:tenon.dht.protobuf.HeartbeatResponse)
  SharedDtor();
}

void HeartbeatResponse::SharedDtor() {
}

void HeartbeatResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* HeartbeatResponse::descriptor() {
  ::protobuf_dht_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_dht_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const HeartbeatResponse& HeartbeatResponse::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_dht_2eproto::scc_info_HeartbeatResponse.base);
  return *internal_default_instance();
}


void HeartbeatResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:tenon.dht.protobuf.HeartbeatResponse)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  dht_key_hash_ = GOOGLE_ULONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool HeartbeatResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tenon.dht.protobuf.HeartbeatResponse)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 dht_key_hash = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_dht_key_hash();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dht_key_hash_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tenon.dht.protobuf.HeartbeatResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tenon.dht.protobuf.HeartbeatResponse)
  return false;
#undef DO_
}

void HeartbeatResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tenon.dht.protobuf.HeartbeatResponse)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dht_key_hash = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->dht_key_hash(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tenon.dht.protobuf.HeartbeatResponse)
}

::google::protobuf::uint8* HeartbeatResponse::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:tenon.dht.protobuf.HeartbeatResponse)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 dht_key_hash = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->dht_key_hash(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tenon.dht.protobuf.HeartbeatResponse)
  return target;
}

size_t HeartbeatResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tenon.dht.protobuf.HeartbeatResponse)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // optional uint64 dht_key_hash = 1;
  if (has_dht_key_hash()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->dht_key_hash());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HeartbeatResponse::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:tenon.dht.protobuf.HeartbeatResponse)
  GOOGLE_DCHECK_NE(&from, this);
  const HeartbeatResponse* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const HeartbeatResponse>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:tenon.dht.protobuf.HeartbeatResponse)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:tenon.dht.protobuf.HeartbeatResponse)
    MergeFrom(*source);
  }
}

void HeartbeatResponse::MergeFrom(const HeartbeatResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tenon.dht.protobuf.HeartbeatResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_dht_key_hash()) {
    set_dht_key_hash(from.dht_key_hash());
  }
}

void HeartbeatResponse::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:tenon.dht.protobuf.HeartbeatResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HeartbeatResponse::CopyFrom(const HeartbeatResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tenon.dht.protobuf.HeartbeatResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeartbeatResponse::IsInitialized() const {
  return true;
}

void HeartbeatResponse::Swap(HeartbeatResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void HeartbeatResponse::InternalSwap(HeartbeatResponse* other) {
  using std::swap;
  swap(dht_key_hash_, other->dht_key_hash_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata HeartbeatResponse::GetMetadata() const {
  protobuf_dht_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_dht_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void ConnectReqeust::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ConnectReqeust::kLocalIpFieldNumber;
const int ConnectReqeust::kLocalPortFieldNumber;
const int ConnectReqeust::kPublicIpFieldNumber;
const int ConnectReqeust::kPublicPortFieldNumber;
const int ConnectReqeust::kNatTypeFieldNumber;
const int ConnectReqeust::kIdFieldNumber;
const int ConnectReqeust::kDhtKeyFieldNumber;
const int ConnectReqeust::kDirectFieldNumber;
const int ConnectReqeust::kMinSvrPortFieldNumber;
const int ConnectReqeust::kMaxSvrPortFieldNumber;
const int ConnectReqeust::kMinRoutePortFieldNumber;
const int ConnectReqeust::kMaxRoutePortFieldNumber;
const int ConnectReqeust::kNodeWeightFieldNumber;
const int ConnectReqeust::kMinUdpPortFieldNumber;
const int ConnectReqeust::kMaxUdpPortFieldNumber;
const int ConnectReqeust::kNodeTagFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ConnectReqeust::ConnectReqeust()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_dht_2eproto::scc_info_ConnectReqeust.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:tenon.dht.protobuf.ConnectReqeust)
}
ConnectReqeust::ConnectReqeust(const ConnectReqeust& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  local_ip_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_local_ip()) {
    local_ip_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.local_ip_);
  }
  public_ip_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_public_ip()) {
    public_ip_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.public_ip_);
  }
  id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_id()) {
    id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.id_);
  }
  dht_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_dht_key()) {
    dht_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.dht_key_);
  }
  node_tag_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_node_tag()) {
    node_tag_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.node_tag_);
  }
  ::memcpy(&local_port_, &from.local_port_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_udp_port_) -
    reinterpret_cast<char*>(&local_port_)) + sizeof(max_udp_port_));
  // @@protoc_insertion_point(copy_constructor:tenon.dht.protobuf.ConnectReqeust)
}

void ConnectReqeust::SharedCtor() {
  local_ip_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  public_ip_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  dht_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  node_tag_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&local_port_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&max_udp_port_) -
      reinterpret_cast<char*>(&local_port_)) + sizeof(max_udp_port_));
}

ConnectReqeust::~ConnectReqeust() {
  // @@protoc_insertion_point(destructor:tenon.dht.protobuf.ConnectReqeust)
  SharedDtor();
}

void ConnectReqeust::SharedDtor() {
  local_ip_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  public_ip_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  dht_key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  node_tag_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void ConnectReqeust::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* ConnectReqeust::descriptor() {
  ::protobuf_dht_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_dht_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ConnectReqeust& ConnectReqeust::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_dht_2eproto::scc_info_ConnectReqeust.base);
  return *internal_default_instance();
}


void ConnectReqeust::Clear() {
// @@protoc_insertion_point(message_clear_start:tenon.dht.protobuf.ConnectReqeust)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      local_ip_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      public_ip_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      id_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      dht_key_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000010u) {
      node_tag_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 224u) {
    ::memset(&local_port_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&nat_type_) -
        reinterpret_cast<char*>(&local_port_)) + sizeof(nat_type_));
  }
  if (cached_has_bits & 65280u) {
    ::memset(&direct_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&max_udp_port_) -
        reinterpret_cast<char*>(&direct_)) + sizeof(max_udp_port_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ConnectReqeust::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tenon.dht.protobuf.ConnectReqeust)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes local_ip = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_local_ip()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 local_port = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_local_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &local_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes public_ip = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_public_ip()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 public_port = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          set_has_public_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &public_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 nat_type = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {
          set_has_nat_type();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &nat_type_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes id = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_id()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes dht_key = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u /* 58 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_dht_key()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool direct = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(64u /* 64 & 0xFF */)) {
          set_has_direct();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &direct_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 min_svr_port = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(72u /* 72 & 0xFF */)) {
          set_has_min_svr_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &min_svr_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 max_svr_port = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(80u /* 80 & 0xFF */)) {
          set_has_max_svr_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_svr_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 min_route_port = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(88u /* 88 & 0xFF */)) {
          set_has_min_route_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &min_route_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 max_route_port = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(96u /* 96 & 0xFF */)) {
          set_has_max_route_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_route_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 node_weight = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(104u /* 104 & 0xFF */)) {
          set_has_node_weight();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &node_weight_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 min_udp_port = 14;
      case 14: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(112u /* 112 & 0xFF */)) {
          set_has_min_udp_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &min_udp_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 max_udp_port = 15;
      case 15: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(120u /* 120 & 0xFF */)) {
          set_has_max_udp_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_udp_port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes node_tag = 16;
      case 16: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(130u /* 130 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_node_tag()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tenon.dht.protobuf.ConnectReqeust)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tenon.dht.protobuf.ConnectReqeust)
  return false;
#undef DO_
}

void ConnectReqeust::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tenon.dht.protobuf.ConnectReqeust)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes local_ip = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->local_ip(), output);
  }

  // optional int32 local_port = 2;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->local_port(), output);
  }

  // optional bytes public_ip = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->public_ip(), output);
  }

  // optional int32 public_port = 4;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->public_port(), output);
  }

  // optional int32 nat_type = 5;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->nat_type(), output);
  }

  // optional bytes id = 6;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      6, this->id(), output);
  }

  // optional bytes dht_key = 7;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      7, this->dht_key(), output);
  }

  // optional bool direct = 8;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->direct(), output);
  }

  // optional uint32 min_svr_port = 9;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->min_svr_port(), output);
  }

  // optional uint32 max_svr_port = 10;
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->max_svr_port(), output);
  }

  // optional uint32 min_route_port = 11;
  if (cached_has_bits & 0x00000800u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->min_route_port(), output);
  }

  // optional uint32 max_route_port = 12;
  if (cached_has_bits & 0x00001000u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->max_route_port(), output);
  }

  // optional uint32 node_weight = 13;
  if (cached_has_bits & 0x00002000u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(13, this->node_weight(), output);
  }

  // optional uint32 min_udp_port = 14;
  if (cached_has_bits & 0x00004000u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(14, this->min_udp_port(), output);
  }

  // optional uint32 max_udp_port = 15;
  if (cached_has_bits & 0x00008000u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(15, this->max_udp_port(), output);
  }

  // optional bytes node_tag = 16;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      16, this->node_tag(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tenon.dht.protobuf.ConnectReqeust)
}

::google::protobuf::uint8* ConnectReqeust::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:tenon.dht.protobuf.ConnectReqeust)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes local_ip = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->local_ip(), target);
  }

  // optional int32 local_port = 2;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->local_port(), target);
  }

  // optional bytes public_ip = 3;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->public_ip(), target);
  }

  // optional int32 public_port = 4;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->public_port(), target);
  }

  // optional int32 nat_type = 5;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->nat_type(), target);
  }

  // optional bytes id = 6;
  if (cached_has_bits & 0x00000004u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        6, this->id(), target);
  }

  // optional bytes dht_key = 7;
  if (cached_has_bits & 0x00000008u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        7, this->dht_key(), target);
  }

  // optional bool direct = 8;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(8, this->direct(), target);
  }

  // optional uint32 min_svr_port = 9;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->min_svr_port(), target);
  }

  // optional uint32 max_svr_port = 10;
  if (cached_has_bits & 0x00000400u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->max_svr_port(), target);
  }

  // optional uint32 min_route_port = 11;
  if (cached_has_bits & 0x00000800u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(11, this->min_route_port(), target);
  }

  // optional uint32 max_route_port = 12;
  if (cached_has_bits & 0x00001000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(12, this->max_route_port(), target);
  }

  // optional uint32 node_weight = 13;
  if (cached_has_bits & 0x00002000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(13, this->node_weight(), target);
  }

  // optional uint32 min_udp_port = 14;
  if (cached_has_bits & 0x00004000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(14, this->min_udp_port(), target);
  }

  // optional uint32 max_udp_port = 15;
  if (cached_has_bits & 0x00008000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(15, this->max_udp_port(), target);
  }

  // optional bytes node_tag = 16;
  if (cached_has_bits & 0x00000010u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        16, this->node_tag(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tenon.dht.protobuf.ConnectReqeust)
  return target;
}

size_t ConnectReqeust::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tenon.dht.protobuf.ConnectReqeust)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 255u) {
    // optional bytes local_ip = 1;
    if (has_local_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->local_ip());
    }

    // optional bytes public_ip = 3;
    if (has_public_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->public_ip());
    }

    // optional bytes id = 6;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->id());
    }

    // optional bytes dht_key = 7;
    if (has_dht_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->dht_key());
    }

    // optional bytes node_tag = 16;
    if (has_node_tag()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->node_tag());
    }

    // optional int32 local_port = 2;
    if (has_local_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->local_port());
    }

    // optional int32 public_port = 4;
    if (has_public_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->public_port());
    }

    // optional int32 nat_type = 5;
    if (has_nat_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->nat_type());
    }

  }
  if (_has_bits_[8 / 32] & 65280u) {
    // optional bool direct = 8;
    if (has_direct()) {
      total_size += 1 + 1;
    }

    // optional uint32 min_svr_port = 9;
    if (has_min_svr_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->min_svr_port());
    }

    // optional uint32 max_svr_port = 10;
    if (has_max_svr_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_svr_port());
    }

    // optional uint32 min_route_port = 11;
    if (has_min_route_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->min_route_port());
    }

    // optional uint32 max_route_port = 12;
    if (has_max_route_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_route_port());
    }

    // optional uint32 node_weight = 13;
    if (has_node_weight()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->node_weight());
    }

    // optional uint32 min_udp_port = 14;
    if (has_min_udp_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->min_udp_port());
    }

    // optional uint32 max_udp_port = 15;
    if (has_max_udp_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_udp_port());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConnectReqeust::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:tenon.dht.protobuf.ConnectReqeust)
  GOOGLE_DCHECK_NE(&from, this);
  const ConnectReqeust* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ConnectReqeust>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:tenon.dht.protobuf.ConnectReqeust)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:tenon.dht.protobuf.ConnectReqeust)
    MergeFrom(*source);
  }
}

void ConnectReqeust::MergeFrom(const ConnectReqeust& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tenon.dht.protobuf.ConnectReqeust)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_local_ip();
      local_ip_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.local_ip_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_public_ip();
      public_ip_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.public_ip_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_id();
      id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.id_);
    }
    if (cached_has_bits & 0x00000008u) {
      set_has_dht_key();
      dht_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.dht_key_);
    }
    if (cached_has_bits & 0x00000010u) {
      set_has_node_tag();
      node_tag_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.node_tag_);
    }
    if (cached_has_bits & 0x00000020u) {
      local_port_ = from.local_port_;
    }
    if (cached_has_bits & 0x00000040u) {
      public_port_ = from.public_port_;
    }
    if (cached_has_bits & 0x00000080u) {
      nat_type_ = from.nat_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 65280u) {
    if (cached_has_bits & 0x00000100u) {
      direct_ = from.direct_;
    }
    if (cached_has_bits & 0x00000200u) {
      min_svr_port_ = from.min_svr_port_;
    }
    if (cached_has_bits & 0x00000400u) {
      max_svr_port_ = from.max_svr_port_;
    }
    if (cached_has_bits & 0x00000800u) {
      min_route_port_ = from.min_route_port_;
    }
    if (cached_has_bits & 0x00001000u) {
      max_route_port_ = from.max_route_port_;
    }
    if (cached_has_bits & 0x00002000u) {
      node_weight_ = from.node_weight_;
    }
    if (cached_has_bits & 0x00004000u) {
      min_udp_port_ = from.min_udp_port_;
    }
    if (cached_has_bits & 0x00008000u) {
      max_udp_port_ = from.max_udp_port_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ConnectReqeust::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:tenon.dht.protobuf.ConnectReqeust)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ConnectReqeust::CopyFrom(const ConnectReqeust& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tenon.dht.protobuf.ConnectReqeust)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectReqeust::IsInitialized() const {
  return true;
}

void ConnectReqeust::Swap(ConnectReqeust* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ConnectReqeust::InternalSwap(ConnectReqeust* other) {
  using std::swap;
  local_ip_.Swap(&other->local_ip_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  public_ip_.Swap(&other->public_ip_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  id_.Swap(&other->id_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  dht_key_.Swap(&other->dht_key_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  node_tag_.Swap(&other->node_tag_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(local_port_, other->local_port_);
  swap(public_port_, other->public_port_);
  swap(nat_type_, other->nat_type_);
  swap(direct_, other->direct_);
  swap(min_svr_port_, other->min_svr_port_);
  swap(max_svr_port_, other->max_svr_port_);
  swap(min_route_port_, other->min_route_port_);
  swap(max_route_port_, other->max_route_port_);
  swap(node_weight_, other->node_weight_);
  swap(min_udp_port_, other->min_udp_port_);
  swap(max_udp_port_, other->max_udp_port_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata ConnectReqeust::GetMetadata() const {
  protobuf_dht_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_dht_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void DhtMessage::InitAsDefaultInstance() {
  ::tenon::dht::protobuf::_DhtMessage_default_instance_._instance.get_mutable()->bootstrap_req_ = const_cast< ::tenon::dht::protobuf::BootstrapRequest*>(
      ::tenon::dht::protobuf::BootstrapRequest::internal_default_instance());
  ::tenon::dht::protobuf::_DhtMessage_default_instance_._instance.get_mutable()->bootstrap_res_ = const_cast< ::tenon::dht::protobuf::BootstrapResponse*>(
      ::tenon::dht::protobuf::BootstrapResponse::internal_default_instance());
  ::tenon::dht::protobuf::_DhtMessage_default_instance_._instance.get_mutable()->refresh_neighbors_req_ = const_cast< ::tenon::dht::protobuf::RefreshNeighborsRequest*>(
      ::tenon::dht::protobuf::RefreshNeighborsRequest::internal_default_instance());
  ::tenon::dht::protobuf::_DhtMessage_default_instance_._instance.get_mutable()->refresh_neighbors_res_ = const_cast< ::tenon::dht::protobuf::RefreshNeighborsResponse*>(
      ::tenon::dht::protobuf::RefreshNeighborsResponse::internal_default_instance());
  ::tenon::dht::protobuf::_DhtMessage_default_instance_._instance.get_mutable()->connect_req_ = const_cast< ::tenon::dht::protobuf::ConnectReqeust*>(
      ::tenon::dht::protobuf::ConnectReqeust::internal_default_instance());
  ::tenon::dht::protobuf::_DhtMessage_default_instance_._instance.get_mutable()->heartbeat_req_ = const_cast< ::tenon::dht::protobuf::HeartbeatRequest*>(
      ::tenon::dht::protobuf::HeartbeatRequest::internal_default_instance());
  ::tenon::dht::protobuf::_DhtMessage_default_instance_._instance.get_mutable()->heartbeat_res_ = const_cast< ::tenon::dht::protobuf::HeartbeatResponse*>(
      ::tenon::dht::protobuf::HeartbeatResponse::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DhtMessage::kBootstrapReqFieldNumber;
const int DhtMessage::kBootstrapResFieldNumber;
const int DhtMessage::kRefreshNeighborsReqFieldNumber;
const int DhtMessage::kRefreshNeighborsResFieldNumber;
const int DhtMessage::kConnectReqFieldNumber;
const int DhtMessage::kHeartbeatReqFieldNumber;
const int DhtMessage::kHeartbeatResFieldNumber;
const int DhtMessage::kNetworksFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DhtMessage::DhtMessage()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_dht_2eproto::scc_info_DhtMessage.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:tenon.dht.protobuf.DhtMessage)
}
DhtMessage::DhtMessage(const DhtMessage& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      networks_(from.networks_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_bootstrap_req()) {
    bootstrap_req_ = new ::tenon::dht::protobuf::BootstrapRequest(*from.bootstrap_req_);
  } else {
    bootstrap_req_ = NULL;
  }
  if (from.has_bootstrap_res()) {
    bootstrap_res_ = new ::tenon::dht::protobuf::BootstrapResponse(*from.bootstrap_res_);
  } else {
    bootstrap_res_ = NULL;
  }
  if (from.has_refresh_neighbors_req()) {
    refresh_neighbors_req_ = new ::tenon::dht::protobuf::RefreshNeighborsRequest(*from.refresh_neighbors_req_);
  } else {
    refresh_neighbors_req_ = NULL;
  }
  if (from.has_refresh_neighbors_res()) {
    refresh_neighbors_res_ = new ::tenon::dht::protobuf::RefreshNeighborsResponse(*from.refresh_neighbors_res_);
  } else {
    refresh_neighbors_res_ = NULL;
  }
  if (from.has_connect_req()) {
    connect_req_ = new ::tenon::dht::protobuf::ConnectReqeust(*from.connect_req_);
  } else {
    connect_req_ = NULL;
  }
  if (from.has_heartbeat_req()) {
    heartbeat_req_ = new ::tenon::dht::protobuf::HeartbeatRequest(*from.heartbeat_req_);
  } else {
    heartbeat_req_ = NULL;
  }
  if (from.has_heartbeat_res()) {
    heartbeat_res_ = new ::tenon::dht::protobuf::HeartbeatResponse(*from.heartbeat_res_);
  } else {
    heartbeat_res_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:tenon.dht.protobuf.DhtMessage)
}

void DhtMessage::SharedCtor() {
  ::memset(&bootstrap_req_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&heartbeat_res_) -
      reinterpret_cast<char*>(&bootstrap_req_)) + sizeof(heartbeat_res_));
}

DhtMessage::~DhtMessage() {
  // @@protoc_insertion_point(destructor:tenon.dht.protobuf.DhtMessage)
  SharedDtor();
}

void DhtMessage::SharedDtor() {
  if (this != internal_default_instance()) delete bootstrap_req_;
  if (this != internal_default_instance()) delete bootstrap_res_;
  if (this != internal_default_instance()) delete refresh_neighbors_req_;
  if (this != internal_default_instance()) delete refresh_neighbors_res_;
  if (this != internal_default_instance()) delete connect_req_;
  if (this != internal_default_instance()) delete heartbeat_req_;
  if (this != internal_default_instance()) delete heartbeat_res_;
}

void DhtMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* DhtMessage::descriptor() {
  ::protobuf_dht_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_dht_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const DhtMessage& DhtMessage::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_dht_2eproto::scc_info_DhtMessage.base);
  return *internal_default_instance();
}


void DhtMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:tenon.dht.protobuf.DhtMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  networks_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 127u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(bootstrap_req_ != NULL);
      bootstrap_req_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(bootstrap_res_ != NULL);
      bootstrap_res_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(refresh_neighbors_req_ != NULL);
      refresh_neighbors_req_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(refresh_neighbors_res_ != NULL);
      refresh_neighbors_res_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(connect_req_ != NULL);
      connect_req_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(heartbeat_req_ != NULL);
      heartbeat_req_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(heartbeat_res_ != NULL);
      heartbeat_res_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool DhtMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tenon.dht.protobuf.DhtMessage)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .tenon.dht.protobuf.BootstrapRequest bootstrap_req = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_bootstrap_req()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .tenon.dht.protobuf.BootstrapResponse bootstrap_res = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_bootstrap_res()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .tenon.dht.protobuf.RefreshNeighborsRequest refresh_neighbors_req = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_refresh_neighbors_req()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .tenon.dht.protobuf.RefreshNeighborsResponse refresh_neighbors_res = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_refresh_neighbors_res()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .tenon.dht.protobuf.ConnectReqeust connect_req = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_connect_req()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .tenon.dht.protobuf.HeartbeatRequest heartbeat_req = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_heartbeat_req()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .tenon.dht.protobuf.HeartbeatResponse heartbeat_res = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u /* 58 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_heartbeat_res()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated uint32 networks = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(64u /* 64 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 64u, input, this->mutable_networks())));
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(66u /* 66 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_networks())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tenon.dht.protobuf.DhtMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tenon.dht.protobuf.DhtMessage)
  return false;
#undef DO_
}

void DhtMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tenon.dht.protobuf.DhtMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .tenon.dht.protobuf.BootstrapRequest bootstrap_req = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->_internal_bootstrap_req(), output);
  }

  // optional .tenon.dht.protobuf.BootstrapResponse bootstrap_res = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->_internal_bootstrap_res(), output);
  }

  // optional .tenon.dht.protobuf.RefreshNeighborsRequest refresh_neighbors_req = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->_internal_refresh_neighbors_req(), output);
  }

  // optional .tenon.dht.protobuf.RefreshNeighborsResponse refresh_neighbors_res = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->_internal_refresh_neighbors_res(), output);
  }

  // optional .tenon.dht.protobuf.ConnectReqeust connect_req = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->_internal_connect_req(), output);
  }

  // optional .tenon.dht.protobuf.HeartbeatRequest heartbeat_req = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->_internal_heartbeat_req(), output);
  }

  // optional .tenon.dht.protobuf.HeartbeatResponse heartbeat_res = 7;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->_internal_heartbeat_res(), output);
  }

  // repeated uint32 networks = 8;
  for (int i = 0, n = this->networks_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      8, this->networks(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tenon.dht.protobuf.DhtMessage)
}

::google::protobuf::uint8* DhtMessage::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:tenon.dht.protobuf.DhtMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .tenon.dht.protobuf.BootstrapRequest bootstrap_req = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->_internal_bootstrap_req(), deterministic, target);
  }

  // optional .tenon.dht.protobuf.BootstrapResponse bootstrap_res = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->_internal_bootstrap_res(), deterministic, target);
  }

  // optional .tenon.dht.protobuf.RefreshNeighborsRequest refresh_neighbors_req = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, this->_internal_refresh_neighbors_req(), deterministic, target);
  }

  // optional .tenon.dht.protobuf.RefreshNeighborsResponse refresh_neighbors_res = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, this->_internal_refresh_neighbors_res(), deterministic, target);
  }

  // optional .tenon.dht.protobuf.ConnectReqeust connect_req = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, this->_internal_connect_req(), deterministic, target);
  }

  // optional .tenon.dht.protobuf.HeartbeatRequest heartbeat_req = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, this->_internal_heartbeat_req(), deterministic, target);
  }

  // optional .tenon.dht.protobuf.HeartbeatResponse heartbeat_res = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        7, this->_internal_heartbeat_res(), deterministic, target);
  }

  // repeated uint32 networks = 8;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt32ToArray(8, this->networks_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tenon.dht.protobuf.DhtMessage)
  return target;
}

size_t DhtMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tenon.dht.protobuf.DhtMessage)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // repeated uint32 networks = 8;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->networks_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->networks_size());
    total_size += data_size;
  }

  if (_has_bits_[0 / 32] & 127u) {
    // optional .tenon.dht.protobuf.BootstrapRequest bootstrap_req = 1;
    if (has_bootstrap_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *bootstrap_req_);
    }

    // optional .tenon.dht.protobuf.BootstrapResponse bootstrap_res = 2;
    if (has_bootstrap_res()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *bootstrap_res_);
    }

    // optional .tenon.dht.protobuf.RefreshNeighborsRequest refresh_neighbors_req = 3;
    if (has_refresh_neighbors_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *refresh_neighbors_req_);
    }

    // optional .tenon.dht.protobuf.RefreshNeighborsResponse refresh_neighbors_res = 4;
    if (has_refresh_neighbors_res()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *refresh_neighbors_res_);
    }

    // optional .tenon.dht.protobuf.ConnectReqeust connect_req = 5;
    if (has_connect_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *connect_req_);
    }

    // optional .tenon.dht.protobuf.HeartbeatRequest heartbeat_req = 6;
    if (has_heartbeat_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *heartbeat_req_);
    }

    // optional .tenon.dht.protobuf.HeartbeatResponse heartbeat_res = 7;
    if (has_heartbeat_res()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *heartbeat_res_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DhtMessage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:tenon.dht.protobuf.DhtMessage)
  GOOGLE_DCHECK_NE(&from, this);
  const DhtMessage* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const DhtMessage>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:tenon.dht.protobuf.DhtMessage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:tenon.dht.protobuf.DhtMessage)
    MergeFrom(*source);
  }
}

void DhtMessage::MergeFrom(const DhtMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tenon.dht.protobuf.DhtMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  networks_.MergeFrom(from.networks_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 127u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_bootstrap_req()->::tenon::dht::protobuf::BootstrapRequest::MergeFrom(from.bootstrap_req());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_bootstrap_res()->::tenon::dht::protobuf::BootstrapResponse::MergeFrom(from.bootstrap_res());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_refresh_neighbors_req()->::tenon::dht::protobuf::RefreshNeighborsRequest::MergeFrom(from.refresh_neighbors_req());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_refresh_neighbors_res()->::tenon::dht::protobuf::RefreshNeighborsResponse::MergeFrom(from.refresh_neighbors_res());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_connect_req()->::tenon::dht::protobuf::ConnectReqeust::MergeFrom(from.connect_req());
    }
    if (cached_has_bits & 0x00000020u) {
      mutable_heartbeat_req()->::tenon::dht::protobuf::HeartbeatRequest::MergeFrom(from.heartbeat_req());
    }
    if (cached_has_bits & 0x00000040u) {
      mutable_heartbeat_res()->::tenon::dht::protobuf::HeartbeatResponse::MergeFrom(from.heartbeat_res());
    }
  }
}

void DhtMessage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:tenon.dht.protobuf.DhtMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DhtMessage::CopyFrom(const DhtMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tenon.dht.protobuf.DhtMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DhtMessage::IsInitialized() const {
  return true;
}

void DhtMessage::Swap(DhtMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DhtMessage::InternalSwap(DhtMessage* other) {
  using std::swap;
  networks_.InternalSwap(&other->networks_);
  swap(bootstrap_req_, other->bootstrap_req_);
  swap(bootstrap_res_, other->bootstrap_res_);
  swap(refresh_neighbors_req_, other->refresh_neighbors_req_);
  swap(refresh_neighbors_res_, other->refresh_neighbors_res_);
  swap(connect_req_, other->connect_req_);
  swap(heartbeat_req_, other->heartbeat_req_);
  swap(heartbeat_res_, other->heartbeat_res_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata DhtMessage::GetMetadata() const {
  protobuf_dht_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_dht_2eproto::file_level_metadata[kIndexInFileMessages];
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace protobuf
}  // namespace dht
}  // namespace tenon
namespace google {
namespace protobuf {
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::tenon::dht::protobuf::BootstrapRequest* Arena::CreateMaybeMessage< ::tenon::dht::protobuf::BootstrapRequest >(Arena* arena) {
  return Arena::CreateInternal< ::tenon::dht::protobuf::BootstrapRequest >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::tenon::dht::protobuf::RelayVpnNodeInfo* Arena::CreateMaybeMessage< ::tenon::dht::protobuf::RelayVpnNodeInfo >(Arena* arena) {
  return Arena::CreateInternal< ::tenon::dht::protobuf::RelayVpnNodeInfo >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::tenon::dht::protobuf::VpnNodeInfo* Arena::CreateMaybeMessage< ::tenon::dht::protobuf::VpnNodeInfo >(Arena* arena) {
  return Arena::CreateInternal< ::tenon::dht::protobuf::VpnNodeInfo >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::tenon::dht::protobuf::InitMessage* Arena::CreateMaybeMessage< ::tenon::dht::protobuf::InitMessage >(Arena* arena) {
  return Arena::CreateInternal< ::tenon::dht::protobuf::InitMessage >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::tenon::dht::protobuf::BootstrapResponse* Arena::CreateMaybeMessage< ::tenon::dht::protobuf::BootstrapResponse >(Arena* arena) {
  return Arena::CreateInternal< ::tenon::dht::protobuf::BootstrapResponse >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::tenon::dht::protobuf::RefreshNeighborsRequest* Arena::CreateMaybeMessage< ::tenon::dht::protobuf::RefreshNeighborsRequest >(Arena* arena) {
  return Arena::CreateInternal< ::tenon::dht::protobuf::RefreshNeighborsRequest >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::tenon::dht::protobuf::NodeInfo* Arena::CreateMaybeMessage< ::tenon::dht::protobuf::NodeInfo >(Arena* arena) {
  return Arena::CreateInternal< ::tenon::dht::protobuf::NodeInfo >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::tenon::dht::protobuf::RefreshNeighborsResponse* Arena::CreateMaybeMessage< ::tenon::dht::protobuf::RefreshNeighborsResponse >(Arena* arena) {
  return Arena::CreateInternal< ::tenon::dht::protobuf::RefreshNeighborsResponse >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::tenon::dht::protobuf::HeartbeatRequest* Arena::CreateMaybeMessage< ::tenon::dht::protobuf::HeartbeatRequest >(Arena* arena) {
  return Arena::CreateInternal< ::tenon::dht::protobuf::HeartbeatRequest >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::tenon::dht::protobuf::HeartbeatResponse* Arena::CreateMaybeMessage< ::tenon::dht::protobuf::HeartbeatResponse >(Arena* arena) {
  return Arena::CreateInternal< ::tenon::dht::protobuf::HeartbeatResponse >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::tenon::dht::protobuf::ConnectReqeust* Arena::CreateMaybeMessage< ::tenon::dht::protobuf::ConnectReqeust >(Arena* arena) {
  return Arena::CreateInternal< ::tenon::dht::protobuf::ConnectReqeust >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::tenon::dht::protobuf::DhtMessage* Arena::CreateMaybeMessage< ::tenon::dht::protobuf::DhtMessage >(Arena* arena) {
  return Arena::CreateInternal< ::tenon::dht::protobuf::DhtMessage >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
