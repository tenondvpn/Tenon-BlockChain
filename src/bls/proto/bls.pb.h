// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bls.proto

#ifndef PROTOBUF_INCLUDED_bls_2eproto
#define PROTOBUF_INCLUDED_bls_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_bls_2eproto 

namespace protobuf_bls_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_bls_2eproto
namespace bls {
namespace block {
namespace protobuf {
class AgainstParticipant;
class AgainstParticipantDefaultTypeInternal;
extern AgainstParticipantDefaultTypeInternal _AgainstParticipant_default_instance_;
class BlsMessage;
class BlsMessageDefaultTypeInternal;
extern BlsMessageDefaultTypeInternal _BlsMessage_default_instance_;
class SwapSecKeyReq;
class SwapSecKeyReqDefaultTypeInternal;
extern SwapSecKeyReqDefaultTypeInternal _SwapSecKeyReq_default_instance_;
class VerifyVecBrdReq;
class VerifyVecBrdReqDefaultTypeInternal;
extern VerifyVecBrdReqDefaultTypeInternal _VerifyVecBrdReq_default_instance_;
class VerifyVecItem;
class VerifyVecItemDefaultTypeInternal;
extern VerifyVecItemDefaultTypeInternal _VerifyVecItem_default_instance_;
}  // namespace protobuf
}  // namespace block
}  // namespace bls
namespace google {
namespace protobuf {
template<> ::bls::block::protobuf::AgainstParticipant* Arena::CreateMaybeMessage<::bls::block::protobuf::AgainstParticipant>(Arena*);
template<> ::bls::block::protobuf::BlsMessage* Arena::CreateMaybeMessage<::bls::block::protobuf::BlsMessage>(Arena*);
template<> ::bls::block::protobuf::SwapSecKeyReq* Arena::CreateMaybeMessage<::bls::block::protobuf::SwapSecKeyReq>(Arena*);
template<> ::bls::block::protobuf::VerifyVecBrdReq* Arena::CreateMaybeMessage<::bls::block::protobuf::VerifyVecBrdReq>(Arena*);
template<> ::bls::block::protobuf::VerifyVecItem* Arena::CreateMaybeMessage<::bls::block::protobuf::VerifyVecItem>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace bls {
namespace block {
namespace protobuf {

// ===================================================================

class VerifyVecItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bls.block.protobuf.VerifyVecItem) */ {
 public:
  VerifyVecItem();
  virtual ~VerifyVecItem();

  VerifyVecItem(const VerifyVecItem& from);

  inline VerifyVecItem& operator=(const VerifyVecItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VerifyVecItem(VerifyVecItem&& from) noexcept
    : VerifyVecItem() {
    *this = ::std::move(from);
  }

  inline VerifyVecItem& operator=(VerifyVecItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VerifyVecItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VerifyVecItem* internal_default_instance() {
    return reinterpret_cast<const VerifyVecItem*>(
               &_VerifyVecItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(VerifyVecItem* other);
  friend void swap(VerifyVecItem& a, VerifyVecItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VerifyVecItem* New() const final {
    return CreateMaybeMessage<VerifyVecItem>(NULL);
  }

  VerifyVecItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VerifyVecItem>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VerifyVecItem& from);
  void MergeFrom(const VerifyVecItem& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerifyVecItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes x_c0 = 1;
  bool has_x_c0() const;
  void clear_x_c0();
  static const int kXC0FieldNumber = 1;
  const ::std::string& x_c0() const;
  void set_x_c0(const ::std::string& value);
  #if LANG_CXX11
  void set_x_c0(::std::string&& value);
  #endif
  void set_x_c0(const char* value);
  void set_x_c0(const void* value, size_t size);
  ::std::string* mutable_x_c0();
  ::std::string* release_x_c0();
  void set_allocated_x_c0(::std::string* x_c0);

  // optional bytes x_c1 = 2;
  bool has_x_c1() const;
  void clear_x_c1();
  static const int kXC1FieldNumber = 2;
  const ::std::string& x_c1() const;
  void set_x_c1(const ::std::string& value);
  #if LANG_CXX11
  void set_x_c1(::std::string&& value);
  #endif
  void set_x_c1(const char* value);
  void set_x_c1(const void* value, size_t size);
  ::std::string* mutable_x_c1();
  ::std::string* release_x_c1();
  void set_allocated_x_c1(::std::string* x_c1);

  // optional bytes y_c0 = 3;
  bool has_y_c0() const;
  void clear_y_c0();
  static const int kYC0FieldNumber = 3;
  const ::std::string& y_c0() const;
  void set_y_c0(const ::std::string& value);
  #if LANG_CXX11
  void set_y_c0(::std::string&& value);
  #endif
  void set_y_c0(const char* value);
  void set_y_c0(const void* value, size_t size);
  ::std::string* mutable_y_c0();
  ::std::string* release_y_c0();
  void set_allocated_y_c0(::std::string* y_c0);

  // optional bytes y_c1 = 4;
  bool has_y_c1() const;
  void clear_y_c1();
  static const int kYC1FieldNumber = 4;
  const ::std::string& y_c1() const;
  void set_y_c1(const ::std::string& value);
  #if LANG_CXX11
  void set_y_c1(::std::string&& value);
  #endif
  void set_y_c1(const char* value);
  void set_y_c1(const void* value, size_t size);
  ::std::string* mutable_y_c1();
  ::std::string* release_y_c1();
  void set_allocated_y_c1(::std::string* y_c1);

  // optional bytes z_c0 = 5;
  bool has_z_c0() const;
  void clear_z_c0();
  static const int kZC0FieldNumber = 5;
  const ::std::string& z_c0() const;
  void set_z_c0(const ::std::string& value);
  #if LANG_CXX11
  void set_z_c0(::std::string&& value);
  #endif
  void set_z_c0(const char* value);
  void set_z_c0(const void* value, size_t size);
  ::std::string* mutable_z_c0();
  ::std::string* release_z_c0();
  void set_allocated_z_c0(::std::string* z_c0);

  // optional bytes z_c1 = 6;
  bool has_z_c1() const;
  void clear_z_c1();
  static const int kZC1FieldNumber = 6;
  const ::std::string& z_c1() const;
  void set_z_c1(const ::std::string& value);
  #if LANG_CXX11
  void set_z_c1(::std::string&& value);
  #endif
  void set_z_c1(const char* value);
  void set_z_c1(const void* value, size_t size);
  ::std::string* mutable_z_c1();
  ::std::string* release_z_c1();
  void set_allocated_z_c1(::std::string* z_c1);

  // @@protoc_insertion_point(class_scope:bls.block.protobuf.VerifyVecItem)
 private:
  void set_has_x_c0();
  void clear_has_x_c0();
  void set_has_x_c1();
  void clear_has_x_c1();
  void set_has_y_c0();
  void clear_has_y_c0();
  void set_has_y_c1();
  void clear_has_y_c1();
  void set_has_z_c0();
  void clear_has_z_c0();
  void set_has_z_c1();
  void clear_has_z_c1();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr x_c0_;
  ::google::protobuf::internal::ArenaStringPtr x_c1_;
  ::google::protobuf::internal::ArenaStringPtr y_c0_;
  ::google::protobuf::internal::ArenaStringPtr y_c1_;
  ::google::protobuf::internal::ArenaStringPtr z_c0_;
  ::google::protobuf::internal::ArenaStringPtr z_c1_;
  friend struct ::protobuf_bls_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VerifyVecBrdReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bls.block.protobuf.VerifyVecBrdReq) */ {
 public:
  VerifyVecBrdReq();
  virtual ~VerifyVecBrdReq();

  VerifyVecBrdReq(const VerifyVecBrdReq& from);

  inline VerifyVecBrdReq& operator=(const VerifyVecBrdReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VerifyVecBrdReq(VerifyVecBrdReq&& from) noexcept
    : VerifyVecBrdReq() {
    *this = ::std::move(from);
  }

  inline VerifyVecBrdReq& operator=(VerifyVecBrdReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VerifyVecBrdReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VerifyVecBrdReq* internal_default_instance() {
    return reinterpret_cast<const VerifyVecBrdReq*>(
               &_VerifyVecBrdReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(VerifyVecBrdReq* other);
  friend void swap(VerifyVecBrdReq& a, VerifyVecBrdReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VerifyVecBrdReq* New() const final {
    return CreateMaybeMessage<VerifyVecBrdReq>(NULL);
  }

  VerifyVecBrdReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VerifyVecBrdReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VerifyVecBrdReq& from);
  void MergeFrom(const VerifyVecBrdReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerifyVecBrdReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .bls.block.protobuf.VerifyVecItem verify_vec = 1;
  int verify_vec_size() const;
  void clear_verify_vec();
  static const int kVerifyVecFieldNumber = 1;
  ::bls::block::protobuf::VerifyVecItem* mutable_verify_vec(int index);
  ::google::protobuf::RepeatedPtrField< ::bls::block::protobuf::VerifyVecItem >*
      mutable_verify_vec();
  const ::bls::block::protobuf::VerifyVecItem& verify_vec(int index) const;
  ::bls::block::protobuf::VerifyVecItem* add_verify_vec();
  const ::google::protobuf::RepeatedPtrField< ::bls::block::protobuf::VerifyVecItem >&
      verify_vec() const;

  // @@protoc_insertion_point(class_scope:bls.block.protobuf.VerifyVecBrdReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::bls::block::protobuf::VerifyVecItem > verify_vec_;
  friend struct ::protobuf_bls_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SwapSecKeyReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bls.block.protobuf.SwapSecKeyReq) */ {
 public:
  SwapSecKeyReq();
  virtual ~SwapSecKeyReq();

  SwapSecKeyReq(const SwapSecKeyReq& from);

  inline SwapSecKeyReq& operator=(const SwapSecKeyReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SwapSecKeyReq(SwapSecKeyReq&& from) noexcept
    : SwapSecKeyReq() {
    *this = ::std::move(from);
  }

  inline SwapSecKeyReq& operator=(SwapSecKeyReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SwapSecKeyReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwapSecKeyReq* internal_default_instance() {
    return reinterpret_cast<const SwapSecKeyReq*>(
               &_SwapSecKeyReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(SwapSecKeyReq* other);
  friend void swap(SwapSecKeyReq& a, SwapSecKeyReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SwapSecKeyReq* New() const final {
    return CreateMaybeMessage<SwapSecKeyReq>(NULL);
  }

  SwapSecKeyReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SwapSecKeyReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SwapSecKeyReq& from);
  void MergeFrom(const SwapSecKeyReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwapSecKeyReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes sec_key = 1;
  bool has_sec_key() const;
  void clear_sec_key();
  static const int kSecKeyFieldNumber = 1;
  const ::std::string& sec_key() const;
  void set_sec_key(const ::std::string& value);
  #if LANG_CXX11
  void set_sec_key(::std::string&& value);
  #endif
  void set_sec_key(const char* value);
  void set_sec_key(const void* value, size_t size);
  ::std::string* mutable_sec_key();
  ::std::string* release_sec_key();
  void set_allocated_sec_key(::std::string* sec_key);

  // @@protoc_insertion_point(class_scope:bls.block.protobuf.SwapSecKeyReq)
 private:
  void set_has_sec_key();
  void clear_has_sec_key();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr sec_key_;
  friend struct ::protobuf_bls_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AgainstParticipant : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bls.block.protobuf.AgainstParticipant) */ {
 public:
  AgainstParticipant();
  virtual ~AgainstParticipant();

  AgainstParticipant(const AgainstParticipant& from);

  inline AgainstParticipant& operator=(const AgainstParticipant& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AgainstParticipant(AgainstParticipant&& from) noexcept
    : AgainstParticipant() {
    *this = ::std::move(from);
  }

  inline AgainstParticipant& operator=(AgainstParticipant&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AgainstParticipant& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AgainstParticipant* internal_default_instance() {
    return reinterpret_cast<const AgainstParticipant*>(
               &_AgainstParticipant_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(AgainstParticipant* other);
  friend void swap(AgainstParticipant& a, AgainstParticipant& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AgainstParticipant* New() const final {
    return CreateMaybeMessage<AgainstParticipant>(NULL);
  }

  AgainstParticipant* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AgainstParticipant>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AgainstParticipant& from);
  void MergeFrom(const AgainstParticipant& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgainstParticipant* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 against_index = 1;
  bool has_against_index() const;
  void clear_against_index();
  static const int kAgainstIndexFieldNumber = 1;
  ::google::protobuf::uint32 against_index() const;
  void set_against_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:bls.block.protobuf.AgainstParticipant)
 private:
  void set_has_against_index();
  void clear_has_against_index();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 against_index_;
  friend struct ::protobuf_bls_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlsMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bls.block.protobuf.BlsMessage) */ {
 public:
  BlsMessage();
  virtual ~BlsMessage();

  BlsMessage(const BlsMessage& from);

  inline BlsMessage& operator=(const BlsMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlsMessage(BlsMessage&& from) noexcept
    : BlsMessage() {
    *this = ::std::move(from);
  }

  inline BlsMessage& operator=(BlsMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlsMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlsMessage* internal_default_instance() {
    return reinterpret_cast<const BlsMessage*>(
               &_BlsMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(BlsMessage* other);
  friend void swap(BlsMessage& a, BlsMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlsMessage* New() const final {
    return CreateMaybeMessage<BlsMessage>(NULL);
  }

  BlsMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BlsMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BlsMessage& from);
  void MergeFrom(const BlsMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlsMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes sign_ch = 5;
  bool has_sign_ch() const;
  void clear_sign_ch();
  static const int kSignChFieldNumber = 5;
  const ::std::string& sign_ch() const;
  void set_sign_ch(const ::std::string& value);
  #if LANG_CXX11
  void set_sign_ch(::std::string&& value);
  #endif
  void set_sign_ch(const char* value);
  void set_sign_ch(const void* value, size_t size);
  ::std::string* mutable_sign_ch();
  ::std::string* release_sign_ch();
  void set_allocated_sign_ch(::std::string* sign_ch);

  // optional bytes sign_res = 6;
  bool has_sign_res() const;
  void clear_sign_res();
  static const int kSignResFieldNumber = 6;
  const ::std::string& sign_res() const;
  void set_sign_res(const ::std::string& value);
  #if LANG_CXX11
  void set_sign_res(::std::string&& value);
  #endif
  void set_sign_res(const char* value);
  void set_sign_res(const void* value, size_t size);
  ::std::string* mutable_sign_res();
  ::std::string* release_sign_res();
  void set_allocated_sign_res(::std::string* sign_res);

  // optional .bls.block.protobuf.VerifyVecBrdReq verify_brd = 1;
  bool has_verify_brd() const;
  void clear_verify_brd();
  static const int kVerifyBrdFieldNumber = 1;
  private:
  const ::bls::block::protobuf::VerifyVecBrdReq& _internal_verify_brd() const;
  public:
  const ::bls::block::protobuf::VerifyVecBrdReq& verify_brd() const;
  ::bls::block::protobuf::VerifyVecBrdReq* release_verify_brd();
  ::bls::block::protobuf::VerifyVecBrdReq* mutable_verify_brd();
  void set_allocated_verify_brd(::bls::block::protobuf::VerifyVecBrdReq* verify_brd);

  // optional .bls.block.protobuf.SwapSecKeyReq swap_req = 2;
  bool has_swap_req() const;
  void clear_swap_req();
  static const int kSwapReqFieldNumber = 2;
  private:
  const ::bls::block::protobuf::SwapSecKeyReq& _internal_swap_req() const;
  public:
  const ::bls::block::protobuf::SwapSecKeyReq& swap_req() const;
  ::bls::block::protobuf::SwapSecKeyReq* release_swap_req();
  ::bls::block::protobuf::SwapSecKeyReq* mutable_swap_req();
  void set_allocated_swap_req(::bls::block::protobuf::SwapSecKeyReq* swap_req);

  // optional .bls.block.protobuf.AgainstParticipant against_req = 3;
  bool has_against_req() const;
  void clear_against_req();
  static const int kAgainstReqFieldNumber = 3;
  private:
  const ::bls::block::protobuf::AgainstParticipant& _internal_against_req() const;
  public:
  const ::bls::block::protobuf::AgainstParticipant& against_req() const;
  ::bls::block::protobuf::AgainstParticipant* release_against_req();
  ::bls::block::protobuf::AgainstParticipant* mutable_against_req();
  void set_allocated_against_req(::bls::block::protobuf::AgainstParticipant* against_req);

  // optional uint32 index = 4;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 4;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:bls.block.protobuf.BlsMessage)
 private:
  void set_has_verify_brd();
  void clear_has_verify_brd();
  void set_has_swap_req();
  void clear_has_swap_req();
  void set_has_against_req();
  void clear_has_against_req();
  void set_has_index();
  void clear_has_index();
  void set_has_sign_ch();
  void clear_has_sign_ch();
  void set_has_sign_res();
  void clear_has_sign_res();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr sign_ch_;
  ::google::protobuf::internal::ArenaStringPtr sign_res_;
  ::bls::block::protobuf::VerifyVecBrdReq* verify_brd_;
  ::bls::block::protobuf::SwapSecKeyReq* swap_req_;
  ::bls::block::protobuf::AgainstParticipant* against_req_;
  ::google::protobuf::uint32 index_;
  friend struct ::protobuf_bls_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// VerifyVecItem

// optional bytes x_c0 = 1;
inline bool VerifyVecItem::has_x_c0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VerifyVecItem::set_has_x_c0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VerifyVecItem::clear_has_x_c0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VerifyVecItem::clear_x_c0() {
  x_c0_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_x_c0();
}
inline const ::std::string& VerifyVecItem::x_c0() const {
  // @@protoc_insertion_point(field_get:bls.block.protobuf.VerifyVecItem.x_c0)
  return x_c0_.GetNoArena();
}
inline void VerifyVecItem::set_x_c0(const ::std::string& value) {
  set_has_x_c0();
  x_c0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bls.block.protobuf.VerifyVecItem.x_c0)
}
#if LANG_CXX11
inline void VerifyVecItem::set_x_c0(::std::string&& value) {
  set_has_x_c0();
  x_c0_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bls.block.protobuf.VerifyVecItem.x_c0)
}
#endif
inline void VerifyVecItem::set_x_c0(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_x_c0();
  x_c0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bls.block.protobuf.VerifyVecItem.x_c0)
}
inline void VerifyVecItem::set_x_c0(const void* value, size_t size) {
  set_has_x_c0();
  x_c0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bls.block.protobuf.VerifyVecItem.x_c0)
}
inline ::std::string* VerifyVecItem::mutable_x_c0() {
  set_has_x_c0();
  // @@protoc_insertion_point(field_mutable:bls.block.protobuf.VerifyVecItem.x_c0)
  return x_c0_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VerifyVecItem::release_x_c0() {
  // @@protoc_insertion_point(field_release:bls.block.protobuf.VerifyVecItem.x_c0)
  if (!has_x_c0()) {
    return NULL;
  }
  clear_has_x_c0();
  return x_c0_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VerifyVecItem::set_allocated_x_c0(::std::string* x_c0) {
  if (x_c0 != NULL) {
    set_has_x_c0();
  } else {
    clear_has_x_c0();
  }
  x_c0_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), x_c0);
  // @@protoc_insertion_point(field_set_allocated:bls.block.protobuf.VerifyVecItem.x_c0)
}

// optional bytes x_c1 = 2;
inline bool VerifyVecItem::has_x_c1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VerifyVecItem::set_has_x_c1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VerifyVecItem::clear_has_x_c1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VerifyVecItem::clear_x_c1() {
  x_c1_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_x_c1();
}
inline const ::std::string& VerifyVecItem::x_c1() const {
  // @@protoc_insertion_point(field_get:bls.block.protobuf.VerifyVecItem.x_c1)
  return x_c1_.GetNoArena();
}
inline void VerifyVecItem::set_x_c1(const ::std::string& value) {
  set_has_x_c1();
  x_c1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bls.block.protobuf.VerifyVecItem.x_c1)
}
#if LANG_CXX11
inline void VerifyVecItem::set_x_c1(::std::string&& value) {
  set_has_x_c1();
  x_c1_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bls.block.protobuf.VerifyVecItem.x_c1)
}
#endif
inline void VerifyVecItem::set_x_c1(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_x_c1();
  x_c1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bls.block.protobuf.VerifyVecItem.x_c1)
}
inline void VerifyVecItem::set_x_c1(const void* value, size_t size) {
  set_has_x_c1();
  x_c1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bls.block.protobuf.VerifyVecItem.x_c1)
}
inline ::std::string* VerifyVecItem::mutable_x_c1() {
  set_has_x_c1();
  // @@protoc_insertion_point(field_mutable:bls.block.protobuf.VerifyVecItem.x_c1)
  return x_c1_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VerifyVecItem::release_x_c1() {
  // @@protoc_insertion_point(field_release:bls.block.protobuf.VerifyVecItem.x_c1)
  if (!has_x_c1()) {
    return NULL;
  }
  clear_has_x_c1();
  return x_c1_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VerifyVecItem::set_allocated_x_c1(::std::string* x_c1) {
  if (x_c1 != NULL) {
    set_has_x_c1();
  } else {
    clear_has_x_c1();
  }
  x_c1_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), x_c1);
  // @@protoc_insertion_point(field_set_allocated:bls.block.protobuf.VerifyVecItem.x_c1)
}

// optional bytes y_c0 = 3;
inline bool VerifyVecItem::has_y_c0() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VerifyVecItem::set_has_y_c0() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VerifyVecItem::clear_has_y_c0() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VerifyVecItem::clear_y_c0() {
  y_c0_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_y_c0();
}
inline const ::std::string& VerifyVecItem::y_c0() const {
  // @@protoc_insertion_point(field_get:bls.block.protobuf.VerifyVecItem.y_c0)
  return y_c0_.GetNoArena();
}
inline void VerifyVecItem::set_y_c0(const ::std::string& value) {
  set_has_y_c0();
  y_c0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bls.block.protobuf.VerifyVecItem.y_c0)
}
#if LANG_CXX11
inline void VerifyVecItem::set_y_c0(::std::string&& value) {
  set_has_y_c0();
  y_c0_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bls.block.protobuf.VerifyVecItem.y_c0)
}
#endif
inline void VerifyVecItem::set_y_c0(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_y_c0();
  y_c0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bls.block.protobuf.VerifyVecItem.y_c0)
}
inline void VerifyVecItem::set_y_c0(const void* value, size_t size) {
  set_has_y_c0();
  y_c0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bls.block.protobuf.VerifyVecItem.y_c0)
}
inline ::std::string* VerifyVecItem::mutable_y_c0() {
  set_has_y_c0();
  // @@protoc_insertion_point(field_mutable:bls.block.protobuf.VerifyVecItem.y_c0)
  return y_c0_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VerifyVecItem::release_y_c0() {
  // @@protoc_insertion_point(field_release:bls.block.protobuf.VerifyVecItem.y_c0)
  if (!has_y_c0()) {
    return NULL;
  }
  clear_has_y_c0();
  return y_c0_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VerifyVecItem::set_allocated_y_c0(::std::string* y_c0) {
  if (y_c0 != NULL) {
    set_has_y_c0();
  } else {
    clear_has_y_c0();
  }
  y_c0_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), y_c0);
  // @@protoc_insertion_point(field_set_allocated:bls.block.protobuf.VerifyVecItem.y_c0)
}

// optional bytes y_c1 = 4;
inline bool VerifyVecItem::has_y_c1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VerifyVecItem::set_has_y_c1() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VerifyVecItem::clear_has_y_c1() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VerifyVecItem::clear_y_c1() {
  y_c1_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_y_c1();
}
inline const ::std::string& VerifyVecItem::y_c1() const {
  // @@protoc_insertion_point(field_get:bls.block.protobuf.VerifyVecItem.y_c1)
  return y_c1_.GetNoArena();
}
inline void VerifyVecItem::set_y_c1(const ::std::string& value) {
  set_has_y_c1();
  y_c1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bls.block.protobuf.VerifyVecItem.y_c1)
}
#if LANG_CXX11
inline void VerifyVecItem::set_y_c1(::std::string&& value) {
  set_has_y_c1();
  y_c1_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bls.block.protobuf.VerifyVecItem.y_c1)
}
#endif
inline void VerifyVecItem::set_y_c1(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_y_c1();
  y_c1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bls.block.protobuf.VerifyVecItem.y_c1)
}
inline void VerifyVecItem::set_y_c1(const void* value, size_t size) {
  set_has_y_c1();
  y_c1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bls.block.protobuf.VerifyVecItem.y_c1)
}
inline ::std::string* VerifyVecItem::mutable_y_c1() {
  set_has_y_c1();
  // @@protoc_insertion_point(field_mutable:bls.block.protobuf.VerifyVecItem.y_c1)
  return y_c1_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VerifyVecItem::release_y_c1() {
  // @@protoc_insertion_point(field_release:bls.block.protobuf.VerifyVecItem.y_c1)
  if (!has_y_c1()) {
    return NULL;
  }
  clear_has_y_c1();
  return y_c1_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VerifyVecItem::set_allocated_y_c1(::std::string* y_c1) {
  if (y_c1 != NULL) {
    set_has_y_c1();
  } else {
    clear_has_y_c1();
  }
  y_c1_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), y_c1);
  // @@protoc_insertion_point(field_set_allocated:bls.block.protobuf.VerifyVecItem.y_c1)
}

// optional bytes z_c0 = 5;
inline bool VerifyVecItem::has_z_c0() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VerifyVecItem::set_has_z_c0() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VerifyVecItem::clear_has_z_c0() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VerifyVecItem::clear_z_c0() {
  z_c0_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_z_c0();
}
inline const ::std::string& VerifyVecItem::z_c0() const {
  // @@protoc_insertion_point(field_get:bls.block.protobuf.VerifyVecItem.z_c0)
  return z_c0_.GetNoArena();
}
inline void VerifyVecItem::set_z_c0(const ::std::string& value) {
  set_has_z_c0();
  z_c0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bls.block.protobuf.VerifyVecItem.z_c0)
}
#if LANG_CXX11
inline void VerifyVecItem::set_z_c0(::std::string&& value) {
  set_has_z_c0();
  z_c0_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bls.block.protobuf.VerifyVecItem.z_c0)
}
#endif
inline void VerifyVecItem::set_z_c0(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_z_c0();
  z_c0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bls.block.protobuf.VerifyVecItem.z_c0)
}
inline void VerifyVecItem::set_z_c0(const void* value, size_t size) {
  set_has_z_c0();
  z_c0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bls.block.protobuf.VerifyVecItem.z_c0)
}
inline ::std::string* VerifyVecItem::mutable_z_c0() {
  set_has_z_c0();
  // @@protoc_insertion_point(field_mutable:bls.block.protobuf.VerifyVecItem.z_c0)
  return z_c0_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VerifyVecItem::release_z_c0() {
  // @@protoc_insertion_point(field_release:bls.block.protobuf.VerifyVecItem.z_c0)
  if (!has_z_c0()) {
    return NULL;
  }
  clear_has_z_c0();
  return z_c0_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VerifyVecItem::set_allocated_z_c0(::std::string* z_c0) {
  if (z_c0 != NULL) {
    set_has_z_c0();
  } else {
    clear_has_z_c0();
  }
  z_c0_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), z_c0);
  // @@protoc_insertion_point(field_set_allocated:bls.block.protobuf.VerifyVecItem.z_c0)
}

// optional bytes z_c1 = 6;
inline bool VerifyVecItem::has_z_c1() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VerifyVecItem::set_has_z_c1() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VerifyVecItem::clear_has_z_c1() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VerifyVecItem::clear_z_c1() {
  z_c1_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_z_c1();
}
inline const ::std::string& VerifyVecItem::z_c1() const {
  // @@protoc_insertion_point(field_get:bls.block.protobuf.VerifyVecItem.z_c1)
  return z_c1_.GetNoArena();
}
inline void VerifyVecItem::set_z_c1(const ::std::string& value) {
  set_has_z_c1();
  z_c1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bls.block.protobuf.VerifyVecItem.z_c1)
}
#if LANG_CXX11
inline void VerifyVecItem::set_z_c1(::std::string&& value) {
  set_has_z_c1();
  z_c1_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bls.block.protobuf.VerifyVecItem.z_c1)
}
#endif
inline void VerifyVecItem::set_z_c1(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_z_c1();
  z_c1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bls.block.protobuf.VerifyVecItem.z_c1)
}
inline void VerifyVecItem::set_z_c1(const void* value, size_t size) {
  set_has_z_c1();
  z_c1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bls.block.protobuf.VerifyVecItem.z_c1)
}
inline ::std::string* VerifyVecItem::mutable_z_c1() {
  set_has_z_c1();
  // @@protoc_insertion_point(field_mutable:bls.block.protobuf.VerifyVecItem.z_c1)
  return z_c1_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VerifyVecItem::release_z_c1() {
  // @@protoc_insertion_point(field_release:bls.block.protobuf.VerifyVecItem.z_c1)
  if (!has_z_c1()) {
    return NULL;
  }
  clear_has_z_c1();
  return z_c1_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VerifyVecItem::set_allocated_z_c1(::std::string* z_c1) {
  if (z_c1 != NULL) {
    set_has_z_c1();
  } else {
    clear_has_z_c1();
  }
  z_c1_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), z_c1);
  // @@protoc_insertion_point(field_set_allocated:bls.block.protobuf.VerifyVecItem.z_c1)
}

// -------------------------------------------------------------------

// VerifyVecBrdReq

// repeated .bls.block.protobuf.VerifyVecItem verify_vec = 1;
inline int VerifyVecBrdReq::verify_vec_size() const {
  return verify_vec_.size();
}
inline void VerifyVecBrdReq::clear_verify_vec() {
  verify_vec_.Clear();
}
inline ::bls::block::protobuf::VerifyVecItem* VerifyVecBrdReq::mutable_verify_vec(int index) {
  // @@protoc_insertion_point(field_mutable:bls.block.protobuf.VerifyVecBrdReq.verify_vec)
  return verify_vec_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::bls::block::protobuf::VerifyVecItem >*
VerifyVecBrdReq::mutable_verify_vec() {
  // @@protoc_insertion_point(field_mutable_list:bls.block.protobuf.VerifyVecBrdReq.verify_vec)
  return &verify_vec_;
}
inline const ::bls::block::protobuf::VerifyVecItem& VerifyVecBrdReq::verify_vec(int index) const {
  // @@protoc_insertion_point(field_get:bls.block.protobuf.VerifyVecBrdReq.verify_vec)
  return verify_vec_.Get(index);
}
inline ::bls::block::protobuf::VerifyVecItem* VerifyVecBrdReq::add_verify_vec() {
  // @@protoc_insertion_point(field_add:bls.block.protobuf.VerifyVecBrdReq.verify_vec)
  return verify_vec_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bls::block::protobuf::VerifyVecItem >&
VerifyVecBrdReq::verify_vec() const {
  // @@protoc_insertion_point(field_list:bls.block.protobuf.VerifyVecBrdReq.verify_vec)
  return verify_vec_;
}

// -------------------------------------------------------------------

// SwapSecKeyReq

// optional bytes sec_key = 1;
inline bool SwapSecKeyReq::has_sec_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SwapSecKeyReq::set_has_sec_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SwapSecKeyReq::clear_has_sec_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SwapSecKeyReq::clear_sec_key() {
  sec_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sec_key();
}
inline const ::std::string& SwapSecKeyReq::sec_key() const {
  // @@protoc_insertion_point(field_get:bls.block.protobuf.SwapSecKeyReq.sec_key)
  return sec_key_.GetNoArena();
}
inline void SwapSecKeyReq::set_sec_key(const ::std::string& value) {
  set_has_sec_key();
  sec_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bls.block.protobuf.SwapSecKeyReq.sec_key)
}
#if LANG_CXX11
inline void SwapSecKeyReq::set_sec_key(::std::string&& value) {
  set_has_sec_key();
  sec_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bls.block.protobuf.SwapSecKeyReq.sec_key)
}
#endif
inline void SwapSecKeyReq::set_sec_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sec_key();
  sec_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bls.block.protobuf.SwapSecKeyReq.sec_key)
}
inline void SwapSecKeyReq::set_sec_key(const void* value, size_t size) {
  set_has_sec_key();
  sec_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bls.block.protobuf.SwapSecKeyReq.sec_key)
}
inline ::std::string* SwapSecKeyReq::mutable_sec_key() {
  set_has_sec_key();
  // @@protoc_insertion_point(field_mutable:bls.block.protobuf.SwapSecKeyReq.sec_key)
  return sec_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SwapSecKeyReq::release_sec_key() {
  // @@protoc_insertion_point(field_release:bls.block.protobuf.SwapSecKeyReq.sec_key)
  if (!has_sec_key()) {
    return NULL;
  }
  clear_has_sec_key();
  return sec_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SwapSecKeyReq::set_allocated_sec_key(::std::string* sec_key) {
  if (sec_key != NULL) {
    set_has_sec_key();
  } else {
    clear_has_sec_key();
  }
  sec_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sec_key);
  // @@protoc_insertion_point(field_set_allocated:bls.block.protobuf.SwapSecKeyReq.sec_key)
}

// -------------------------------------------------------------------

// AgainstParticipant

// optional uint32 against_index = 1;
inline bool AgainstParticipant::has_against_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgainstParticipant::set_has_against_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgainstParticipant::clear_has_against_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgainstParticipant::clear_against_index() {
  against_index_ = 0u;
  clear_has_against_index();
}
inline ::google::protobuf::uint32 AgainstParticipant::against_index() const {
  // @@protoc_insertion_point(field_get:bls.block.protobuf.AgainstParticipant.against_index)
  return against_index_;
}
inline void AgainstParticipant::set_against_index(::google::protobuf::uint32 value) {
  set_has_against_index();
  against_index_ = value;
  // @@protoc_insertion_point(field_set:bls.block.protobuf.AgainstParticipant.against_index)
}

// -------------------------------------------------------------------

// BlsMessage

// optional .bls.block.protobuf.VerifyVecBrdReq verify_brd = 1;
inline bool BlsMessage::has_verify_brd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlsMessage::set_has_verify_brd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlsMessage::clear_has_verify_brd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlsMessage::clear_verify_brd() {
  if (verify_brd_ != NULL) verify_brd_->Clear();
  clear_has_verify_brd();
}
inline const ::bls::block::protobuf::VerifyVecBrdReq& BlsMessage::_internal_verify_brd() const {
  return *verify_brd_;
}
inline const ::bls::block::protobuf::VerifyVecBrdReq& BlsMessage::verify_brd() const {
  const ::bls::block::protobuf::VerifyVecBrdReq* p = verify_brd_;
  // @@protoc_insertion_point(field_get:bls.block.protobuf.BlsMessage.verify_brd)
  return p != NULL ? *p : *reinterpret_cast<const ::bls::block::protobuf::VerifyVecBrdReq*>(
      &::bls::block::protobuf::_VerifyVecBrdReq_default_instance_);
}
inline ::bls::block::protobuf::VerifyVecBrdReq* BlsMessage::release_verify_brd() {
  // @@protoc_insertion_point(field_release:bls.block.protobuf.BlsMessage.verify_brd)
  clear_has_verify_brd();
  ::bls::block::protobuf::VerifyVecBrdReq* temp = verify_brd_;
  verify_brd_ = NULL;
  return temp;
}
inline ::bls::block::protobuf::VerifyVecBrdReq* BlsMessage::mutable_verify_brd() {
  set_has_verify_brd();
  if (verify_brd_ == NULL) {
    auto* p = CreateMaybeMessage<::bls::block::protobuf::VerifyVecBrdReq>(GetArenaNoVirtual());
    verify_brd_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bls.block.protobuf.BlsMessage.verify_brd)
  return verify_brd_;
}
inline void BlsMessage::set_allocated_verify_brd(::bls::block::protobuf::VerifyVecBrdReq* verify_brd) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete verify_brd_;
  }
  if (verify_brd) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      verify_brd = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, verify_brd, submessage_arena);
    }
    set_has_verify_brd();
  } else {
    clear_has_verify_brd();
  }
  verify_brd_ = verify_brd;
  // @@protoc_insertion_point(field_set_allocated:bls.block.protobuf.BlsMessage.verify_brd)
}

// optional .bls.block.protobuf.SwapSecKeyReq swap_req = 2;
inline bool BlsMessage::has_swap_req() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BlsMessage::set_has_swap_req() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BlsMessage::clear_has_swap_req() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BlsMessage::clear_swap_req() {
  if (swap_req_ != NULL) swap_req_->Clear();
  clear_has_swap_req();
}
inline const ::bls::block::protobuf::SwapSecKeyReq& BlsMessage::_internal_swap_req() const {
  return *swap_req_;
}
inline const ::bls::block::protobuf::SwapSecKeyReq& BlsMessage::swap_req() const {
  const ::bls::block::protobuf::SwapSecKeyReq* p = swap_req_;
  // @@protoc_insertion_point(field_get:bls.block.protobuf.BlsMessage.swap_req)
  return p != NULL ? *p : *reinterpret_cast<const ::bls::block::protobuf::SwapSecKeyReq*>(
      &::bls::block::protobuf::_SwapSecKeyReq_default_instance_);
}
inline ::bls::block::protobuf::SwapSecKeyReq* BlsMessage::release_swap_req() {
  // @@protoc_insertion_point(field_release:bls.block.protobuf.BlsMessage.swap_req)
  clear_has_swap_req();
  ::bls::block::protobuf::SwapSecKeyReq* temp = swap_req_;
  swap_req_ = NULL;
  return temp;
}
inline ::bls::block::protobuf::SwapSecKeyReq* BlsMessage::mutable_swap_req() {
  set_has_swap_req();
  if (swap_req_ == NULL) {
    auto* p = CreateMaybeMessage<::bls::block::protobuf::SwapSecKeyReq>(GetArenaNoVirtual());
    swap_req_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bls.block.protobuf.BlsMessage.swap_req)
  return swap_req_;
}
inline void BlsMessage::set_allocated_swap_req(::bls::block::protobuf::SwapSecKeyReq* swap_req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete swap_req_;
  }
  if (swap_req) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      swap_req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, swap_req, submessage_arena);
    }
    set_has_swap_req();
  } else {
    clear_has_swap_req();
  }
  swap_req_ = swap_req;
  // @@protoc_insertion_point(field_set_allocated:bls.block.protobuf.BlsMessage.swap_req)
}

// optional .bls.block.protobuf.AgainstParticipant against_req = 3;
inline bool BlsMessage::has_against_req() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BlsMessage::set_has_against_req() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BlsMessage::clear_has_against_req() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BlsMessage::clear_against_req() {
  if (against_req_ != NULL) against_req_->Clear();
  clear_has_against_req();
}
inline const ::bls::block::protobuf::AgainstParticipant& BlsMessage::_internal_against_req() const {
  return *against_req_;
}
inline const ::bls::block::protobuf::AgainstParticipant& BlsMessage::against_req() const {
  const ::bls::block::protobuf::AgainstParticipant* p = against_req_;
  // @@protoc_insertion_point(field_get:bls.block.protobuf.BlsMessage.against_req)
  return p != NULL ? *p : *reinterpret_cast<const ::bls::block::protobuf::AgainstParticipant*>(
      &::bls::block::protobuf::_AgainstParticipant_default_instance_);
}
inline ::bls::block::protobuf::AgainstParticipant* BlsMessage::release_against_req() {
  // @@protoc_insertion_point(field_release:bls.block.protobuf.BlsMessage.against_req)
  clear_has_against_req();
  ::bls::block::protobuf::AgainstParticipant* temp = against_req_;
  against_req_ = NULL;
  return temp;
}
inline ::bls::block::protobuf::AgainstParticipant* BlsMessage::mutable_against_req() {
  set_has_against_req();
  if (against_req_ == NULL) {
    auto* p = CreateMaybeMessage<::bls::block::protobuf::AgainstParticipant>(GetArenaNoVirtual());
    against_req_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bls.block.protobuf.BlsMessage.against_req)
  return against_req_;
}
inline void BlsMessage::set_allocated_against_req(::bls::block::protobuf::AgainstParticipant* against_req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete against_req_;
  }
  if (against_req) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      against_req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, against_req, submessage_arena);
    }
    set_has_against_req();
  } else {
    clear_has_against_req();
  }
  against_req_ = against_req;
  // @@protoc_insertion_point(field_set_allocated:bls.block.protobuf.BlsMessage.against_req)
}

// optional uint32 index = 4;
inline bool BlsMessage::has_index() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BlsMessage::set_has_index() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BlsMessage::clear_has_index() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BlsMessage::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 BlsMessage::index() const {
  // @@protoc_insertion_point(field_get:bls.block.protobuf.BlsMessage.index)
  return index_;
}
inline void BlsMessage::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:bls.block.protobuf.BlsMessage.index)
}

// optional bytes sign_ch = 5;
inline bool BlsMessage::has_sign_ch() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlsMessage::set_has_sign_ch() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlsMessage::clear_has_sign_ch() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlsMessage::clear_sign_ch() {
  sign_ch_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sign_ch();
}
inline const ::std::string& BlsMessage::sign_ch() const {
  // @@protoc_insertion_point(field_get:bls.block.protobuf.BlsMessage.sign_ch)
  return sign_ch_.GetNoArena();
}
inline void BlsMessage::set_sign_ch(const ::std::string& value) {
  set_has_sign_ch();
  sign_ch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bls.block.protobuf.BlsMessage.sign_ch)
}
#if LANG_CXX11
inline void BlsMessage::set_sign_ch(::std::string&& value) {
  set_has_sign_ch();
  sign_ch_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bls.block.protobuf.BlsMessage.sign_ch)
}
#endif
inline void BlsMessage::set_sign_ch(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sign_ch();
  sign_ch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bls.block.protobuf.BlsMessage.sign_ch)
}
inline void BlsMessage::set_sign_ch(const void* value, size_t size) {
  set_has_sign_ch();
  sign_ch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bls.block.protobuf.BlsMessage.sign_ch)
}
inline ::std::string* BlsMessage::mutable_sign_ch() {
  set_has_sign_ch();
  // @@protoc_insertion_point(field_mutable:bls.block.protobuf.BlsMessage.sign_ch)
  return sign_ch_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlsMessage::release_sign_ch() {
  // @@protoc_insertion_point(field_release:bls.block.protobuf.BlsMessage.sign_ch)
  if (!has_sign_ch()) {
    return NULL;
  }
  clear_has_sign_ch();
  return sign_ch_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlsMessage::set_allocated_sign_ch(::std::string* sign_ch) {
  if (sign_ch != NULL) {
    set_has_sign_ch();
  } else {
    clear_has_sign_ch();
  }
  sign_ch_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sign_ch);
  // @@protoc_insertion_point(field_set_allocated:bls.block.protobuf.BlsMessage.sign_ch)
}

// optional bytes sign_res = 6;
inline bool BlsMessage::has_sign_res() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlsMessage::set_has_sign_res() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlsMessage::clear_has_sign_res() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlsMessage::clear_sign_res() {
  sign_res_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sign_res();
}
inline const ::std::string& BlsMessage::sign_res() const {
  // @@protoc_insertion_point(field_get:bls.block.protobuf.BlsMessage.sign_res)
  return sign_res_.GetNoArena();
}
inline void BlsMessage::set_sign_res(const ::std::string& value) {
  set_has_sign_res();
  sign_res_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bls.block.protobuf.BlsMessage.sign_res)
}
#if LANG_CXX11
inline void BlsMessage::set_sign_res(::std::string&& value) {
  set_has_sign_res();
  sign_res_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bls.block.protobuf.BlsMessage.sign_res)
}
#endif
inline void BlsMessage::set_sign_res(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sign_res();
  sign_res_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bls.block.protobuf.BlsMessage.sign_res)
}
inline void BlsMessage::set_sign_res(const void* value, size_t size) {
  set_has_sign_res();
  sign_res_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bls.block.protobuf.BlsMessage.sign_res)
}
inline ::std::string* BlsMessage::mutable_sign_res() {
  set_has_sign_res();
  // @@protoc_insertion_point(field_mutable:bls.block.protobuf.BlsMessage.sign_res)
  return sign_res_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlsMessage::release_sign_res() {
  // @@protoc_insertion_point(field_release:bls.block.protobuf.BlsMessage.sign_res)
  if (!has_sign_res()) {
    return NULL;
  }
  clear_has_sign_res();
  return sign_res_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlsMessage::set_allocated_sign_res(::std::string* sign_res) {
  if (sign_res != NULL) {
    set_has_sign_res();
  } else {
    clear_has_sign_res();
  }
  sign_res_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sign_res);
  // @@protoc_insertion_point(field_set_allocated:bls.block.protobuf.BlsMessage.sign_res)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace block
}  // namespace bls

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_bls_2eproto
